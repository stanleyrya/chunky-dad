name: Update Calendar Data

on:
  schedule:
    # Run every 2 hours to keep calendar data fresh
    - cron: '0 */2 * * *'
  workflow_dispatch: # Allow manual triggering
  push:
    paths:
      - 'js/city-config.js'
      - '.github/workflows/update-calendar-data.yml'

jobs:
  update-calendar-data:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Create calendar data directory
        run: mkdir -p data/calendars
      
      - name: Fetch calendar data
        run: |
          # Read city config and extract calendar IDs
          node << 'EOF'
          const fs = require('fs');
          const crypto = require('crypto');
          
          // Function to normalize iCal data by removing timestamps that change on every fetch
          function normalizeICalData(icalData) {
            return icalData
              // Remove DTSTAMP lines (these change on every fetch)
              .replace(/^DTSTAMP:.*$/gm, '')
              // Remove X-WR-CALNAME if it contains timestamps
              .replace(/^X-WR-CALNAME:.*$/gm, '')
              // Remove any other timestamp-like fields that might change
              .replace(/^LAST-MODIFIED:.*$/gm, '')
              // Normalize line endings
              .replace(/\r\n/g, '\n')
              .replace(/\r/g, '\n')
              // Remove empty lines created by removing timestamps
              .replace(/\n\n+/g, '\n');
          }
          
          // Function to generate content hash for comparison
          function getContentHash(data) {
            return crypto.createHash('sha256').update(data).digest('hex');
          }
          
          // Read the city config file
          const cityConfigContent = fs.readFileSync('js/city-config.js', 'utf8');
          
          // Extract CITY_CONFIG object (simple regex approach)
          const configMatch = cityConfigContent.match(/const CITY_CONFIG = ({[\s\S]*?});/);
          if (!configMatch) {
            console.error('Could not extract CITY_CONFIG');
            process.exit(1);
          }
          
          // Parse the config using eval (safe in CI environment)
          let cityConfig;
          try {
            // Use eval to parse the JavaScript object literal safely
            const configCode = `(${configMatch[1]})`;
            cityConfig = eval(configCode);
          } catch (e) {
            console.error('Could not parse city config:', e.message);
            console.error('Config match:', configMatch[1].substring(0, 200) + '...');
            process.exit(1);
          }
          
          // Create fetch script for each city
          const fetchPromises = [];
          let hasActualChanges = false;
          
          for (const [cityKey, config] of Object.entries(cityConfig)) {
            if (config.calendarId && config.visible) {
              console.log(`Fetching calendar for ${config.name} (${cityKey})`);
              
              const icalUrl = `https://calendar.google.com/calendar/ical/${config.calendarId}/public/basic.ics`;
              
              fetchPromises.push(
                fetch(icalUrl)
                  .then(response => {
                    if (!response.ok) {
                      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.text();
                  })
                  .then(icalData => {
                    if (!icalData || !icalData.includes('BEGIN:VCALENDAR')) {
                      throw new Error('Invalid iCal data received');
                    }
                    
                    // Normalize the new data for comparison
                    const normalizedNewData = normalizeICalData(icalData);
                    const newContentHash = getContentHash(normalizedNewData);
                    
                    // Check if file exists and compare content
                    const existingFilePath = `data/calendars/${cityKey}.ics`;
                    let hasChanged = true;
                    
                    if (fs.existsSync(existingFilePath)) {
                      const existingData = fs.readFileSync(existingFilePath, 'utf8');
                      const normalizedExistingData = normalizeICalData(existingData);
                      const existingContentHash = getContentHash(normalizedExistingData);
                      
                      hasChanged = newContentHash !== existingContentHash;
                      
                      if (hasChanged) {
                        console.log(`ðŸ“ Content changed for ${config.name}`);
                        hasActualChanges = true;
                      } else {
                        console.log(`â­ï¸  No content changes for ${config.name}`);
                      }
                    } else {
                      console.log(`ðŸ†• New calendar file for ${config.name}`);
                      hasActualChanges = true;
                    }
                    
                    // Only save if content has actually changed or file is new
                    if (hasChanged) {
                      fs.writeFileSync(existingFilePath, icalData);
                      console.log(`âœ“ Saved calendar data for ${config.name}: ${icalData.length} characters`);
                    }
                    
                    return { cityKey, config, icalData, hasChanged };
                  })
                  .catch(error => {
                    console.error(`âœ— Failed to fetch calendar for ${config.name}:`, error.message);
                    return { cityKey, config, error: error.message, hasChanged: false };
                  })
              );
            }
          }
          
          // Wait for all fetches to complete
          Promise.all(fetchPromises)
            .then(results => {
              // Only update summary if there were actual changes
              const changedResults = results.filter(r => r.hasChanged);
              
              if (changedResults.length === 0 && !results.some(r => r.error)) {
                console.log(`\nðŸŽ¯ No content changes detected across all calendars - skipping update`);
                process.exit(0);
              }
              
              const summary = {
                lastUpdated: new Date().toISOString(),
                cities: {}
              };
              
              let successCount = 0;
              let errorCount = 0;
              
              results.forEach(result => {
                if (result.error) {
                  summary.cities[result.cityKey] = {
                    name: result.config.name,
                    status: 'error',
                    error: result.error,
                    lastUpdated: new Date().toISOString()
                  };
                  errorCount++;
                } else {
                  summary.cities[result.cityKey] = {
                    name: result.config.name,
                    status: 'success',
                    dataLength: result.icalData.length,
                    eventCount: (result.icalData.match(/BEGIN:VEVENT/g) || []).length,
                    lastUpdated: new Date().toISOString()
                  };
                  successCount++;
                }
              });
              
              // Save summary
              fs.writeFileSync('data/calendars/update-summary.json', JSON.stringify(summary, null, 2));
              
              console.log(`\nðŸ“Š Update Summary:`);
              console.log(`âœ“ Successful: ${successCount}`);
              console.log(`âœ— Failed: ${errorCount}`);
              console.log(`ðŸ“… Total cities processed: ${results.length}`);
              console.log(`ðŸ”„ Cities with actual changes: ${changedResults.length}`);
              
              if (errorCount > 0) {
                console.log(`\nâš ï¸  Some calendar updates failed. Check the logs above for details.`);
              }
              
              // Generate today's events data for main page
              console.log(`\nðŸŽ¯ Generating today's events data...`);
              generateTodaysEvents(results, cityConfig);
            })
            .catch(error => {
              console.error('Fatal error during calendar updates:', error);
              process.exit(1);
            });
          
          // Function to generate today's events JSON
          function generateTodaysEvents(results, cityConfig) {
            const todaysEvents = {
              lastUpdated: new Date().toISOString(),
              todayEvents: [],
              tomorrowEvents: []
            };
            
            const today = new Date();
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);
            
            // Set time boundaries for today and tomorrow (local time)
            const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0);
            const todayEnd = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 23, 59, 59);
            const tomorrowStart = new Date(tomorrow.getFullYear(), tomorrow.getMonth(), tomorrow.getDate(), 0, 0, 0);
            const tomorrowEnd = new Date(tomorrow.getFullYear(), tomorrow.getMonth(), tomorrow.getDate(), 23, 59, 59);
            
            console.log(`ðŸ“… Processing events for today: ${todayStart.toISOString().split('T')[0]}`);
            console.log(`ðŸ“… Processing events for tomorrow: ${tomorrowStart.toISOString().split('T')[0]}`);
            
            let totalTodayEvents = 0;
            let totalTomorrowEvents = 0;
            
            // Process each city's calendar data
            results.forEach(result => {
              if (result.error || !result.icalData) return;
              
              try {
                // Parse the iCal data using simplified parser
                const events = parseICalEventsSimple(result.icalData, result.cityKey, cityConfig[result.cityKey]);
                
                // Filter events for today and tomorrow
                const cityTodayEvents = filterEventsForDate(events, todayStart, todayEnd);
                const cityTomorrowEvents = filterEventsForDate(events, tomorrowStart, tomorrowEnd);
                
                // Add city context to events
                cityTodayEvents.forEach(event => {
                  todaysEvents.todayEvents.push({
                    cityKey: result.cityKey,
                    cityName: result.config.name,
                    event: event
                  });
                  totalTodayEvents++;
                });
                
                cityTomorrowEvents.forEach(event => {
                  todaysEvents.tomorrowEvents.push({
                    cityKey: result.cityKey,
                    cityName: result.config.name,
                    event: event
                  });
                  totalTomorrowEvents++;
                });
                
                if (cityTodayEvents.length > 0 || cityTomorrowEvents.length > 0) {
                  console.log(`  ${result.config.name}: ${cityTodayEvents.length} today, ${cityTomorrowEvents.length} tomorrow`);
                }
              } catch (error) {
                console.error(`Error processing events for ${result.config.name}:`, error.message);
              }
            });
            
            // Sort events by time within each day
            todaysEvents.todayEvents.sort((a, b) => {
              const timeA = a.event.startDate ? new Date(a.event.startDate) : new Date();
              const timeB = b.event.startDate ? new Date(b.event.startDate) : new Date();
              return timeA - timeB;
            });
            
            todaysEvents.tomorrowEvents.sort((a, b) => {
              const timeA = a.event.startDate ? new Date(a.event.startDate) : new Date();
              const timeB = b.event.startDate ? new Date(b.event.startDate) : new Date();
              return timeA - timeB;
            });
            
            // Save today's events data
            fs.writeFileSync('data/today-events.json', JSON.stringify(todaysEvents, null, 2));
            
            console.log(`âœ“ Generated today's events data:`);
            console.log(`  ðŸ“… Today: ${totalTodayEvents} events across ${new Set(todaysEvents.todayEvents.map(e => e.cityKey)).size} cities`);
            console.log(`  ðŸ“… Tomorrow: ${totalTomorrowEvents} events across ${new Set(todaysEvents.tomorrowEvents.map(e => e.cityKey)).size} cities`);
          }
          
          // Simplified iCal parser for GitHub Actions (reuses core logic)
          function parseICalEventsSimple(icalText, cityKey, cityConfig) {
            const events = [];
            const lines = icalText.split('\n');
            let currentEvent = null;
            let inEvent = false;
            
            // Extract calendar timezone
            const calendarTimezoneMatch = icalText.match(/X-WR-TIMEZONE:(.+)/);
            const calendarTimezone = calendarTimezoneMatch ? calendarTimezoneMatch[1].trim() : null;
            
            for (let i = 0; i < lines.length; i++) {
              let line = lines[i];
              
              // Handle line continuation
              while (i + 1 < lines.length && (lines[i + 1].startsWith(' ') || lines[i + 1].startsWith('\t'))) {
                i++;
                line += lines[i].substring(1).replace(/\r$/, '');
              }
              
              line = line.replace(/\r$/, '');
              
              if (line === 'BEGIN:VEVENT') {
                inEvent = true;
                currentEvent = {};
              } else if (line === 'END:VEVENT' && currentEvent) {
                if (currentEvent.title && currentEvent.start) {
                  const eventData = parseEventDataSimple(currentEvent, cityKey, cityConfig, calendarTimezone);
                  if (eventData) {
                    events.push(eventData);
                  }
                }
                currentEvent = null;
                inEvent = false;
              } else if (inEvent && currentEvent) {
                parseEventLineSimple(line, currentEvent);
              }
            }
            
            return events;
          }
          
          // Parse individual event line (simplified)
          function parseEventLineSimple(line, currentEvent) {
            if (line.startsWith('SUMMARY:')) {
              currentEvent.title = line.substring(8).replace(/\\,/g, ',').replace(/\\;/g, ';');
            } else if (line.startsWith('DESCRIPTION:')) {
              currentEvent.description = line.substring(12).replace(/\\n/g, '\n').replace(/\\,/g, ',').replace(/\\;/g, ';');
            } else if (line.startsWith('LOCATION:')) {
              currentEvent.location = line.substring(9).replace(/\\,/g, ',').replace(/\\;/g, ';');
            } else if (line.startsWith('DTSTART')) {
              if (line.includes(';TZID=')) {
                const match = line.match(/DTSTART;TZID=([^:]+):(.+)/);
                if (match) {
                  currentEvent.startTimezone = match[1];
                  currentEvent.start = parseICalDateSimple(match[2], match[1]);
                }
              } else {
                const dateMatch = line.match(/DTSTART:(.+)/);
                if (dateMatch) {
                  currentEvent.start = parseICalDateSimple(dateMatch[1]);
                }
              }
            } else if (line.startsWith('DTEND')) {
              if (line.includes(';TZID=')) {
                const match = line.match(/DTEND;TZID=([^:]+):(.+)/);
                if (match) {
                  currentEvent.end = parseICalDateSimple(match[2], match[1]);
                }
              } else {
                const dateMatch = line.match(/DTEND:(.+)/);
                if (dateMatch) {
                  currentEvent.end = parseICalDateSimple(dateMatch[1]);
                }
              }
            } else if (line.startsWith('RRULE:')) {
              currentEvent.recurrence = line.substring(6);
            }
          }
          
          // Parse iCal date (simplified version)
          function parseICalDateSimple(icalDate, timezone = null) {
            if (!icalDate) return null;
            
            let dateStr = icalDate;
            const isUTC = dateStr.endsWith('Z');
            const cleanDate = dateStr.replace(/[TZ]/g, '');
            
            if (cleanDate.length >= 8) {
              const year = parseInt(cleanDate.substring(0, 4));
              const month = parseInt(cleanDate.substring(4, 6));
              const day = parseInt(cleanDate.substring(6, 8));
              const hour = parseInt(cleanDate.substring(8, 10) || '00');
              const minute = parseInt(cleanDate.substring(10, 12) || '00');
              const second = parseInt(cleanDate.substring(12, 14) || '00');
              
              if (isUTC) {
                // UTC time - convert to local time for comparison
                return new Date(Date.UTC(year, month - 1, day, hour, minute, second));
              } else {
                // Local time in calendar timezone
                return new Date(year, month - 1, day, hour, minute, second);
              }
            }
            
            return null;
          }
          
          // Parse event data (simplified)
          function parseEventDataSimple(calendarEvent, cityKey, cityConfig, calendarTimezone) {
            const eventData = {
              name: calendarEvent.title,
              startDate: calendarEvent.start,
              endDate: calendarEvent.end,
              recurring: !!calendarEvent.recurrence,
              cityKey: cityKey,
              cityName: cityConfig.name
            };
            
            // Parse description for venue info
            if (calendarEvent.description) {
              const lines = calendarEvent.description.split('\n');
              for (const line of lines) {
                const colonIndex = line.indexOf(':');
                if (colonIndex > 0) {
                  const key = line.substring(0, colonIndex).trim().toLowerCase();
                  const value = line.substring(colonIndex + 1).trim();
                  
                  if (['bar', 'location', 'host'].includes(key)) {
                    eventData.bar = value;
                  } else if (['cover', 'cost', 'price'].includes(key)) {
                    eventData.cover = value;
                  } else if (['tea', 'info', 'description'].includes(key)) {
                    eventData.tea = value;
                  }
                }
              }
            }
            
            // Parse coordinates
            if (calendarEvent.location) {
              const latlong = calendarEvent.location.split(",");
              if (latlong.length >= 2) {
                eventData.coordinates = { 
                  lat: parseFloat(latlong[0]?.trim()), 
                  lng: parseFloat(latlong[1]?.trim()) 
                };
              }
            }
            
            // Format time display
            if (eventData.startDate) {
              const start = new Date(eventData.startDate);
              const end = eventData.endDate ? new Date(eventData.endDate) : null;
              
              const formatTime = (date) => {
                const hours = date.getHours();
                const minutes = date.getMinutes();
                const ampm = hours >= 12 ? 'PM' : 'AM';
                const displayHours = hours % 12 || 12;
                const displayMinutes = minutes > 0 ? `:${minutes.toString().padStart(2, '0')}` : '';
                return `${displayHours}${displayMinutes}${ampm}`;
              };
              
              if (end) {
                eventData.time = `${formatTime(start)}-${formatTime(end)}`;
              } else {
                eventData.time = formatTime(start);
              }
              
              const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
              eventData.day = days[start.getDay()];
            }
            
            return eventData;
          }
          
          // Filter events for a specific date
          function filterEventsForDate(events, dateStart, dateEnd) {
            return events.filter(event => {
              if (!event.startDate) return false;
              
              const eventDate = new Date(event.startDate);
              
              // For recurring events, check if they occur on this date
              if (event.recurring && event.recurrence) {
                // Simple weekly recurring check
                if (event.recurrence.includes('FREQ=WEEKLY')) {
                  const eventDay = eventDate.getDay();
                  const targetDay = dateStart.getDay();
                  return eventDay === targetDay && eventDate <= dateEnd;
                }
                // Add more recurring logic as needed
              }
              
              // For one-time events, check if they fall within the date range
              return eventDate >= dateStart && eventDate <= dateEnd;
            });
          }
          EOF
      
      - name: Commit updated calendar data
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "Calendar Update Bot"
          
          # Add all calendar data files and today's events
          git add data/calendars/
          git add data/today-events.json
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No calendar data changes to commit"
            echo "CALENDAR_CHANGED=false" >> $GITHUB_ENV
          else
            # Count the number of changed files (excluding update-summary.json)
            CHANGED_FILES=$(git diff --staged --name-only | grep -v update-summary.json | wc -l)
            CHANGED_CALENDAR_FILES=$(git diff --staged --name-only | grep '\.ics$' | wc -l)
            
            git commit -m "ðŸ—“ï¸ Update calendar data - $(date -u '+%Y-%m-%d %H:%M UTC') (${CHANGED_CALENDAR_FILES} calendars changed)"
            git push
            echo "âœ“ Calendar data updated and committed (${CHANGED_FILES} files changed)"
            echo "CALENDAR_CHANGED=true" >> $GITHUB_ENV
          fi
      
      - name: Update test manifest only if calendar data changed
        run: |
          if [ "$CALENDAR_CHANGED" = "true" ] && [ -f "testing/generate-manifest.js" ]; then
            echo "Calendar data changed, updating test manifest..."
            cd testing
            node generate-manifest.js
            cd ..
            
            # Commit manifest updates if any
            if ! git diff --quiet testing/manifest.json; then
              git add testing/manifest.json
              git commit -m "ðŸ“‹ Update test manifest after calendar data update"
              git push
              echo "âœ“ Test manifest updated and committed"
            else
              echo "No manifest changes after regeneration"
            fi
          else
            echo "Skipping test manifest update - no calendar data changes"
          fi