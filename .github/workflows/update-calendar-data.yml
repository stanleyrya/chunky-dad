name: Update Calendar Data

on:
  schedule:
    # Run every 2 hours to keep calendar data fresh
    - cron: '0 */2 * * *'
  workflow_dispatch: # Allow manual triggering
  push:
    paths:
      - 'js/city-config.js'
      - '.github/workflows/update-calendar-data.yml'
      - 'tools/generate-event-pages.js'
      - 'tools/generate-og-images.js'
      - 'js/calendar-core.js'

jobs:
  update-calendar-data:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Create calendar data directory
        run: mkdir -p data/calendars
      
      - name: Fetch calendar data
        run: |
          # Read city config and extract calendar IDs
          node << 'EOF'
          const fs = require('fs');
          const crypto = require('crypto');
          
          // Function to normalize iCal data by removing timestamps that change on every fetch
          function normalizeICalData(icalData) {
            return icalData
              // Remove DTSTAMP lines (these change on every fetch)
              .replace(/^DTSTAMP:.*$/gm, '')
              // Remove X-WR-CALNAME if it contains timestamps
              .replace(/^X-WR-CALNAME:.*$/gm, '')
              // Remove any other timestamp-like fields that might change
              .replace(/^LAST-MODIFIED:.*$/gm, '')
              // Normalize line endings
              .replace(/\r\n/g, '\n')
              .replace(/\r/g, '\n')
              // Remove empty lines created by removing timestamps
              .replace(/\n\n+/g, '\n');
          }
          
          // Function to generate content hash for comparison
          function getContentHash(data) {
            return crypto.createHash('sha256').update(data).digest('hex');
          }
          
          // Read the city config file
          const cityConfigContent = fs.readFileSync('js/city-config.js', 'utf8');
          
          // Extract CITY_CONFIG object (simple regex approach)
          const configMatch = cityConfigContent.match(/const CITY_CONFIG = ({[\s\S]*?});/);
          if (!configMatch) {
            console.error('Could not extract CITY_CONFIG');
            process.exit(1);
          }
          
          // Parse the config using eval (safe in CI environment)
          let cityConfig;
          try {
            // Use eval to parse the JavaScript object literal safely
            const configCode = `(${configMatch[1]})`;
            cityConfig = eval(configCode);
          } catch (e) {
            console.error('Could not parse city config:', e.message);
            console.error('Config match:', configMatch[1].substring(0, 200) + '...');
            process.exit(1);
          }
          
          // Create fetch script for each city
          const fetchPromises = [];
          let hasActualChanges = false;
          
          for (const [cityKey, config] of Object.entries(cityConfig)) {
            if (config.calendarId && config.visible) {
              console.log(`Fetching calendar for ${config.name} (${cityKey})`);
              
              const icalUrl = `https://calendar.google.com/calendar/ical/${config.calendarId}/public/basic.ics`;
              
              fetchPromises.push(
                fetch(icalUrl)
                  .then(response => {
                    if (!response.ok) {
                      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.text();
                  })
                  .then(icalData => {
                    if (!icalData || !icalData.includes('BEGIN:VCALENDAR')) {
                      throw new Error('Invalid iCal data received');
                    }
                    
                    // Normalize the new data for comparison
                    const normalizedNewData = normalizeICalData(icalData);
                    const newContentHash = getContentHash(normalizedNewData);
                    
                    // Check if file exists and compare content
                    const existingFilePath = `data/calendars/${cityKey}.ics`;
                    let hasChanged = true;
                    
                    if (fs.existsSync(existingFilePath)) {
                      const existingData = fs.readFileSync(existingFilePath, 'utf8');
                      const normalizedExistingData = normalizeICalData(existingData);
                      const existingContentHash = getContentHash(normalizedExistingData);
                      
                      hasChanged = newContentHash !== existingContentHash;
                      
                      if (hasChanged) {
                        console.log(`📝 Content changed for ${config.name}`);
                        hasActualChanges = true;
                      } else {
                        console.log(`⏭️  No content changes for ${config.name}`);
                      }
                    } else {
                      console.log(`🆕 New calendar file for ${config.name}`);
                      hasActualChanges = true;
                    }
                    
                    // Only save if content has actually changed or file is new
                    if (hasChanged) {
                      fs.writeFileSync(existingFilePath, icalData);
                      console.log(`✓ Saved calendar data for ${config.name}: ${icalData.length} characters`);
                    }
                    
                    return { cityKey, config, icalData, hasChanged };
                  })
                  .catch(error => {
                    console.error(`✗ Failed to fetch calendar for ${config.name}:`, error.message);
                    return { cityKey, config, error: error.message, hasChanged: false };
                  })
              );
            }
          }
          
          // Wait for all fetches to complete
          Promise.all(fetchPromises)
            .then(results => {
              // Only update summary if there were actual changes
              const changedResults = results.filter(r => r.hasChanged);
              
              if (changedResults.length === 0 && !results.some(r => r.error)) {
                console.log(`\n🎯 No content changes detected across all calendars - skipping update`);
                process.exit(0);
              }
              
              const summary = {
                lastUpdated: new Date().toISOString(),
                cities: {}
              };
              
              let successCount = 0;
              let errorCount = 0;
              
              results.forEach(result => {
                if (result.error) {
                  summary.cities[result.cityKey] = {
                    name: result.config.name,
                    status: 'error',
                    error: result.error,
                    lastUpdated: new Date().toISOString()
                  };
                  errorCount++;
                } else {
                  summary.cities[result.cityKey] = {
                    name: result.config.name,
                    status: 'success',
                    dataLength: result.icalData.length,
                    eventCount: (result.icalData.match(/BEGIN:VEVENT/g) || []).length,
                    lastUpdated: new Date().toISOString()
                  };
                  successCount++;
                }
              });
              
              // Save summary
              fs.writeFileSync('data/calendars/update-summary.json', JSON.stringify(summary, null, 2));
              
              console.log(`\n📊 Update Summary:`);
              console.log(`✓ Successful: ${successCount}`);
              console.log(`✗ Failed: ${errorCount}`);
              console.log(`📅 Total cities processed: ${results.length}`);
              console.log(`🔄 Cities with actual changes: ${changedResults.length}`);
              
              if (errorCount > 0) {
                console.log(`\n⚠️  Some calendar updates failed. Check the logs above for details.`);
              }
            })
            .catch(error => {
              console.error('Fatal error during calendar updates:', error);
              process.exit(1);
            });
          EOF
      
      - name: Commit updated calendar data
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "Calendar Update Bot"
          
          # Add all calendar data files
          git add data/calendars/
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No calendar data changes to commit"
            echo "CALENDAR_CHANGED=false" >> $GITHUB_ENV
          else
            # Count the number of changed files (excluding update-summary.json)
            CHANGED_FILES=$(git diff --staged --name-only | grep -v update-summary.json | wc -l)
            CHANGED_CALENDAR_FILES=$(git diff --staged --name-only | grep '\.ics$' | wc -l)
            
            git commit -m "🗓️ Update calendar data - $(date -u '+%Y-%m-%d %H:%M UTC') (${CHANGED_CALENDAR_FILES} calendars changed)"
            git push
            echo "✓ Calendar data updated and committed (${CHANGED_FILES} files changed)"
            echo "CALENDAR_CHANGED=true" >> $GITHUB_ENV
          fi
      
      - name: Generate event pages
        env:
          EVENT_STUB_DAYS: '240'
          EVENT_STUB_PAST_DAYS: '7'
          EVENT_STUB_BUILD_ALL: 'true'
        run: |
          node tools/generate-event-pages.js
          # Stage generated event pages and capture deletions under city/slug dirs
          git add -A */*/ 2>/dev/null || true
          if git diff --staged --quiet; then
            echo "No event page changes to commit"
            echo "EVENT_PAGES_CHANGED=false" >> $GITHUB_ENV
          else
            git commit -m "🧩 Regenerate event pages from calendars"
            git push
            echo "EVENT_PAGES_CHANGED=true" >> $GITHUB_ENV
          fi

      - name: Install Node dependencies
        run: |
          npm install --no-audit --no-fund --prefer-offline

      - name: Generate OG images for events
        run: |
          node tools/generate-og-images.js
          git add -A img/og/ 2>/dev/null || true
          if git diff --staged --quiet; then
            echo "No OG image changes to commit"
          else
            git commit -m "🖼️ Generate/update OG images for events"
            git push
          fi
      
      - name: Update test manifest only if calendar data changed
        run: |
          if [ "$CALENDAR_CHANGED" = "true" ] && [ -f "testing/generate-manifest.js" ]; then
            echo "Calendar data changed, updating test manifest..."
            cd testing
            node generate-manifest.js
            cd ..
            
            # Commit manifest updates if any
            if ! git diff --quiet testing/manifest.json; then
              git add testing/manifest.json
              git commit -m "📋 Update test manifest after calendar data update"
              git push
              echo "✓ Test manifest updated and committed"
            else
              echo "No manifest changes after regeneration"
            fi
          else
            echo "Skipping test manifest update - no calendar data changes"
          fi