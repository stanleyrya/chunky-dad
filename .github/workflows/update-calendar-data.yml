name: Update Calendar Data

on:
  schedule:
    # Run every 2 hours to keep calendar data fresh
    - cron: '0 */2 * * *'
  workflow_dispatch: # Allow manual triggering
  push:
    paths:
      - 'js/city-config.js'
      - '.github/workflows/update-calendar-data.yml'
      - 'tools/generate-event-pages.js'
      - 'tools/generate-og-images.js'
      - 'js/calendar-core.js'

jobs:
  update-calendar-data:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Create calendar data directory
        run: mkdir -p data/calendars
      
      - name: Fetch calendar data
        run: |
          # Read city config and extract calendar IDs
          node << 'EOF'
          const fs = require('fs');
          const crypto = require('crypto');
          
          // Function to normalize iCal data by removing timestamps that change on every fetch
          function normalizeICalData(icalData) {
            return icalData
              // Remove DTSTAMP lines (these change on every fetch)
              .replace(/^DTSTAMP:.*$/gm, '')
              // Remove X-WR-CALNAME if it contains timestamps
              .replace(/^X-WR-CALNAME:.*$/gm, '')
              // Remove any other timestamp-like fields that might change
              .replace(/^LAST-MODIFIED:.*$/gm, '')
              // Normalize line endings
              .replace(/\r\n/g, '\n')
              .replace(/\r/g, '\n')
              // Remove empty lines created by removing timestamps
              .replace(/\n\n+/g, '\n');
          }
          
          // Function to generate content hash for comparison
          function getContentHash(data) {
            return crypto.createHash('sha256').update(data).digest('hex');
          }
          
          // Read the city config file
          const cityConfigContent = fs.readFileSync('js/city-config.js', 'utf8');
          
          // Extract CITY_CONFIG object (simple regex approach)
          const configMatch = cityConfigContent.match(/const CITY_CONFIG = ({[\s\S]*?});/);
          if (!configMatch) {
            console.error('Could not extract CITY_CONFIG');
            process.exit(1);
          }
          
          // Parse the config using eval (safe in CI environment)
          let cityConfig;
          try {
            // Use eval to parse the JavaScript object literal safely
            const configCode = `(${configMatch[1]})`;
            cityConfig = eval(configCode);
          } catch (e) {
            console.error('Could not parse city config:', e.message);
            console.error('Config match:', configMatch[1].substring(0, 200) + '...');
            process.exit(1);
          }
          
          // Create fetch script for each city
          const fetchPromises = [];
          let hasActualChanges = false;
          
          for (const [cityKey, config] of Object.entries(cityConfig)) {
            if (config.calendarId && config.visible) {
              console.log(`Fetching calendar for ${config.name} (${cityKey})`);
              
              const icalUrl = `https://calendar.google.com/calendar/ical/${config.calendarId}/public/basic.ics`;
              
              fetchPromises.push(
                fetch(icalUrl)
                  .then(response => {
                    if (!response.ok) {
                      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.text();
                  })
                  .then(icalData => {
                    if (!icalData || !icalData.includes('BEGIN:VCALENDAR')) {
                      throw new Error('Invalid iCal data received');
                    }
                    
                    // Normalize the new data for comparison
                    const normalizedNewData = normalizeICalData(icalData);
                    const newContentHash = getContentHash(normalizedNewData);
                    
                    // Check if file exists and compare content
                    const existingFilePath = `data/calendars/${cityKey}.ics`;
                    let hasChanged = true;
                    
                    if (fs.existsSync(existingFilePath)) {
                      const existingData = fs.readFileSync(existingFilePath, 'utf8');
                      const normalizedExistingData = normalizeICalData(existingData);
                      const existingContentHash = getContentHash(normalizedExistingData);
                      
                      hasChanged = newContentHash !== existingContentHash;
                      
                      if (hasChanged) {
                        console.log(`üìù Content changed for ${config.name}`);
                        hasActualChanges = true;
                      } else {
                        console.log(`‚è≠Ô∏è  No content changes for ${config.name}`);
                      }
                    } else {
                      console.log(`üÜï New calendar file for ${config.name}`);
                      hasActualChanges = true;
                    }
                    
                    // Only save if content has actually changed or file is new
                    if (hasChanged) {
                      fs.writeFileSync(existingFilePath, icalData);
                      console.log(`‚úì Saved calendar data for ${config.name}: ${icalData.length} characters`);
                    }
                    
                    return { cityKey, config, icalData, hasChanged };
                  })
                  .catch(error => {
                    console.error(`‚úó Failed to fetch calendar for ${config.name}:`, error.message);
                    return { cityKey, config, error: error.message, hasChanged: false };
                  })
              );
            }
          }
          
          // Wait for all fetches to complete
          Promise.all(fetchPromises)
            .then(results => {
              // Only update summary if there were actual changes
              const changedResults = results.filter(r => r.hasChanged);
              
              if (changedResults.length === 0 && !results.some(r => r.error)) {
                console.log(`\nüéØ No content changes detected across all calendars - skipping update`);
                process.exit(0);
              }
              
              const summary = {
                lastUpdated: new Date().toISOString(),
                cities: {}
              };
              
              let successCount = 0;
              let errorCount = 0;
              
              results.forEach(result => {
                if (result.error) {
                  summary.cities[result.cityKey] = {
                    name: result.config.name,
                    status: 'error',
                    error: result.error,
                    lastUpdated: new Date().toISOString()
                  };
                  errorCount++;
                } else {
                  summary.cities[result.cityKey] = {
                    name: result.config.name,
                    status: 'success',
                    dataLength: result.icalData.length,
                    eventCount: (result.icalData.match(/BEGIN:VEVENT/g) || []).length,
                    lastUpdated: new Date().toISOString()
                  };
                  successCount++;
                }
              });
              
              // Save summary
              fs.writeFileSync('data/calendars/update-summary.json', JSON.stringify(summary, null, 2));
              
              console.log(`\nüìä Update Summary:`);
              console.log(`‚úì Successful: ${successCount}`);
              console.log(`‚úó Failed: ${errorCount}`);
              console.log(`üìÖ Total cities processed: ${results.length}`);
              console.log(`üîÑ Cities with actual changes: ${changedResults.length}`);
              
              if (errorCount > 0) {
                console.log(`\n‚ö†Ô∏è  Some calendar updates failed. Check the logs above for details.`);
              }
            })
            .catch(error => {
              console.error('Fatal error during calendar updates:', error);
              process.exit(1);
            });
          EOF
      
      - name: Commit updated calendar data
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "Calendar Update Bot"
          
          # Add all calendar data files
          git add data/calendars/
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No calendar data changes to commit"
            echo "CALENDAR_CHANGED=false" >> $GITHUB_ENV
          else
            # Count the number of changed files (excluding update-summary.json)
            CHANGED_FILES=$(git diff --staged --name-only | grep -v update-summary.json | wc -l)
            CHANGED_CALENDAR_FILES=$(git diff --staged --name-only | grep '\.ics$' | wc -l)
            
            git commit -m "üóìÔ∏è Update calendar data - $(date -u '+%Y-%m-%d %H:%M UTC') (${CHANGED_CALENDAR_FILES} calendars changed)"
            git push
            echo "‚úì Calendar data updated and committed (${CHANGED_FILES} files changed)"
            echo "CALENDAR_CHANGED=true" >> $GITHUB_ENV
          fi
      
      - name: Generate event pages
        env:
          EVENT_STUB_DAYS: '240'
          EVENT_STUB_PAST_DAYS: '7'
          EVENT_STUB_BUILD_ALL: 'true'
        run: |
          node tools/generate-event-pages.js
          # Stage generated event pages and capture deletions under city/slug dirs
          git add -A */*/ 2>/dev/null || true
          if git diff --staged --quiet; then
            echo "No event page changes to commit"
            echo "EVENT_PAGES_CHANGED=false" >> $GITHUB_ENV
          else
            git commit -m "üß© Regenerate event pages from calendars"
            git push
            echo "EVENT_PAGES_CHANGED=true" >> $GITHUB_ENV
          fi

      - name: Install Node dependencies
        run: |
          npm install --no-audit --no-fund --prefer-offline

      - name: Generate OG images for events
        run: |
          node tools/generate-og-images.js
          git add -A img/og/ 2>/dev/null || true
          if git diff --staged --quiet; then
            echo "No OG image changes to commit"
          else
            git commit -m "üñºÔ∏è Generate/update OG images for events"
            git push
          fi
      
      - name: Update test manifest only if calendar data changed
        run: |
          if [ "$CALENDAR_CHANGED" = "true" ] && [ -f "testing/generate-manifest.js" ]; then
            echo "Calendar data changed, updating test manifest..."
            cd testing
            node generate-manifest.js
            cd ..
            
            # Commit manifest updates if any
            if ! git diff --quiet testing/manifest.json; then
              git add testing/manifest.json
              git commit -m "üìã Update test manifest after calendar data update"
              git push
              echo "‚úì Test manifest updated and committed"
            else
              echo "No manifest changes after regeneration"
            fi
          else
            echo "Skipping test manifest update - no calendar data changes"
          fi