<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="toolbox-icon" content="üõ†Ô∏è">
  <meta name="toolbox-description" content="Build chunky.dad calendar events and preview them instantly.">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-YKQBFFQR5E"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-YKQBFFQR5E');
  </script>
  <title>üõ†Ô∏è chunky.dad Event Builder</title>
  <link rel="stylesheet" href="../styles.css">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
  <style>
    :root {
      color-scheme: dark;
      --page-bg: #0b0d13;
      --panel-bg: #141826;
      --panel-raised: #1c2235;
      --text-primary: #f6f7ff;
      --text-secondary: #c4c8e4;
      --text-muted: #8e94b6;
      --accent: #ffa24a;
      --accent-strong: #ff7b2f;
      --border: rgba(255, 255, 255, 0.08);
      --soft: rgba(255, 162, 74, 0.12);
      --chip: rgba(255, 162, 74, 0.18);
      --sticky-header-offset: 6rem;
    }

    * {
      box-sizing: border-box;
    }

    html {
      overflow-x: hidden;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: 'Poppins', sans-serif;
      background: radial-gradient(circle at top, #1b2033 0%, #0b0d13 45%, #07090f 100%);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
    }

    .page-wrapper {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: calc(2.1rem + var(--sticky-header-offset)) 1.25rem 3.2rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .tool-header {
      background: var(--solid-primary);
      border-bottom: 1px solid rgba(255, 255, 255, 0.18);
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.35);
      height: auto;
    }

    .tool-header nav {
      width: 100%;
    }

    .tool-nav {
      gap: 0.6rem 1rem;
      flex-wrap: nowrap;
      height: auto;
      padding: 0.7rem 1rem 0.8rem;
    }

    .tool-nav .logo h1 {
      font-size: 1.45rem;
      line-height: 1.15;
    }

    .tool-brand-text {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: nowrap;
    }

    .tool-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem 0.85rem;
      align-items: center;
      justify-content: flex-end;
      flex: 1 1 auto;
      min-width: 0;
      margin-left: 0;
    }

    .tool-page-label {
      display: inline-flex;
      align-items: center;
      font-size: 0.7rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.85);
      white-space: nowrap;
      padding: 0.15rem 0.45rem;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.12);
    }

    .tool-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      align-items: center;
    }

    .tool-actions .action-button {
      font-size: 0.8rem;
      padding: 0.45rem 0.75rem;
      min-height: 34px;
      white-space: nowrap;
    }

    .tool-buttons .ghost-button {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text-primary);
      border-color: rgba(255, 255, 255, 0.24);
    }

    .tool-buttons .ghost-button:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.16);
      border-color: rgba(255, 255, 255, 0.34);
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      gap: 1.5rem;
      align-items: start;
    }

    .panel {
      background: var(--panel-bg);
      border-radius: 16px;
      padding: 1.2rem;
      border: 1px solid var(--border);
      box-shadow: 0 18px 38px rgba(0, 0, 0, 0.35);
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.8rem;
      margin-bottom: 0.75rem;
    }

    .panel-header h2 {
      margin: 0;
      font-size: 1.15rem;
      color: var(--text-primary);
    }

    .panel-subtitle {
      margin: 0.25rem 0 0;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    #event-form {
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 0.85rem;
      width: 100%;
    }

    details.form-section {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 0.6rem 0.75rem;
      background: rgba(10, 13, 22, 0.7);
      display: block;
      align-self: stretch;
      min-width: 100%;
      width: 100%;
      max-width: 100%;
      flex: 1 1 100%;
      margin-bottom: 0;
      transition: box-shadow 0.2s ease, background 0.2s ease, border-color 0.2s ease;
    }

    details.form-section[open] {
      background: var(--panel-raised);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
      border-color: rgba(255, 162, 74, 0.18);
    }

    details.form-section summary {
      list-style: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--text-primary);
      width: 100%;
    }

    .live-preview > details.form-section summary {
      font-size: 1.15rem;
    }

    details.form-section summary::-webkit-details-marker {
      display: none;
    }

    details.form-section summary::after {
      content: '‚ñæ';
      font-size: 0.85rem;
      color: var(--accent);
      transition: transform 0.2s ease;
    }

    details.form-section[open] summary::after {
      transform: rotate(180deg);
    }

    .section-body {
      display: grid;
      gap: 0.85rem;
      margin-top: 0.55rem;
    }

    .section-body .field-grid,
    .section-body .field-row {
      margin-bottom: 0;
    }

    .field-grid,
    .field-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 0.75rem;
      margin-bottom: 0.75rem;
    }

    .field-row.time-row {
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.5rem;
    }

    .field-row.time-row .field-group {
      flex-direction: row;
      align-items: center;
      gap: 0.5rem;
      min-width: 0;
    }

    .field-row.time-row .field-group label {
      margin: 0;
      font-size: 0.78rem;
      white-space: nowrap;
      min-width: 2.7rem;
    }

    .field-row.time-row input[type="datetime-local"] {
      padding: 0.35rem 0.5rem;
      font-size: 0.78rem;
      min-width: 0;
      flex: 1 1 0;
      width: auto;
      max-width: 100%;
    }

    .field-group {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      min-width: 0;
    }

    .field-group label {
      font-weight: 600;
      font-size: 0.85rem;
      color: var(--text-primary);
    }

    .field-group small {
      font-size: 0.72rem;
      color: var(--text-muted);
      line-height: 1.35;
    }

    .field-group small code {
      font-family: 'SFMono-Regular', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
      font-size: 0.72rem;
      padding: 0 0.25rem;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.08);
      color: var(--text-secondary);
    }

    .field-group.disabled {
      opacity: 0.55;
    }

    input[type="text"],
    input[type="url"],
    input[type="datetime-local"],
    input[type="number"],
    input[type="date"],
    select,
    textarea {
      font-family: inherit;
      font-size: 0.85rem;
      border: 1px solid rgba(255, 255, 255, 0.16);
      border-radius: 9px;
      padding: 0.5rem 0.65rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      background: #0d111a;
      color: var(--text-primary);
    }

    input[type="datetime-local"] {
      width: 100%;
      min-width: 0;
    }

    input::placeholder,
    textarea::placeholder {
      color: rgba(196, 200, 228, 0.6);
    }

    textarea {
      min-height: 96px;
      resize: vertical;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(108, 99, 255, 0.12);
    }

    .input-with-action {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .input-with-action input {
      flex: 1 1 auto;
      min-width: 0;
    }

    .field-actions {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.4rem 0.6rem;
      margin-top: 0.35rem;
    }

    .input-suffix {
      font-size: 0.75rem;
      color: var(--text-muted);
      padding: 0 0.35rem;
      white-space: nowrap;
    }

    .checkbox-label {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-weight: 500;
      color: var(--text-secondary);
      font-size: 0.82rem;
    }

    .time-notes {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem 0.7rem;
      margin: 0;
      font-size: 0.74rem;
      color: var(--text-muted);
    }

    .time-note strong {
      color: var(--text-primary);
      font-weight: 600;
    }

    input.is-invalid,
    textarea.is-invalid,
    select.is-invalid {
      border-color: rgba(244, 67, 54, 0.6);
      box-shadow: 0 0 0 3px rgba(244, 67, 54, 0.12);
    }

    .field-hint.is-error {
      color: #a12317;
    }

    .field-hint:empty {
      display: none;
    }

    .form-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.8rem;
      margin-top: 1rem;
    }

    .existing-event-panel {
      display: grid;
      gap: 0.85rem;
      min-width: 0;
    }

    .existing-event-panel .field-grid,
    .existing-event-panel .field-group,
    .existing-event-panel .field-actions {
      min-width: 0;
    }

    .existing-event-panel .field-grid {
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    }


    .existing-event-panel .existing-filter-input,
    .existing-event-panel select {
      width: 100%;
      max-width: 100%;
      min-width: 0;
      display: block;
      box-sizing: border-box;
    }

    /* Specific fix for date input overflow */
    #existing-date {
      width: 100%;
      min-width: 0;
      max-width: 100%;
      box-sizing: border-box;
    }

    .existing-event-panel .field-actions {
      margin-top: 0.2rem;
    }

    .existing-modal {
      margin: auto;
      width: min(760px, calc(100vw - 2rem));
      max-width: calc(100vw - 2rem);
      border: none;
      border-radius: 16px;
      padding: 0;
      background: var(--panel-bg);
      color: var(--text-primary);
      box-shadow: 0 28px 60px rgba(0, 0, 0, 0.55);
      max-height: 85vh;
      overflow-x: hidden;
    }

    .existing-modal::backdrop {
      background: rgba(8, 10, 16, 0.75);
      backdrop-filter: blur(4px);
    }

    .existing-modal__content {
      display: grid;
      gap: 1rem;
      padding: 1.2rem;
      max-height: 85vh;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .existing-modal__header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 1rem;
    }

    .existing-modal__header h2 {
      margin: 0;
      font-size: 1.05rem;
      color: var(--text-primary);
    }

    .existing-modal__close {
      padding: 0.35rem 0.55rem;
      min-width: 36px;
      justify-content: center;
    }

    .existing-selection-summary {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 0.6rem;
      padding: 0.6rem 0.75rem;
      border-radius: 10px;
      border: 1px solid rgba(255, 162, 74, 0.25);
      background: rgba(255, 162, 74, 0.08);
      font-size: 0.78rem;
      color: var(--text-secondary);
    }

    .existing-selection-summary strong {
      color: var(--text-primary);
    }

    .existing-selection-actions {
      display: inline-flex;
      gap: 0.4rem;
      flex-wrap: wrap;
    }

    .action-button.is-compact {
      font-size: 0.72rem;
      padding: 0.35rem 0.6rem;
    }

    .primary-actions {
      display: flex;
      gap: 0.6rem;
      flex-wrap: wrap;
    }

    button {
      font-family: inherit;
      font-size: 0.85rem;
      padding: 0.5rem 0.85rem;
      border-radius: 9px;
      border: none;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    .action-button {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      line-height: 1;
    }

    .action-button i {
      font-size: 1rem;
      line-height: 1;
    }

    .field-action {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      background: rgba(255, 162, 74, 0.12);
      color: var(--text-secondary);
      border: 1px solid rgba(255, 162, 74, 0.25);
      padding: 0.35rem 0.6rem;
      font-size: 0.72rem;
      border-radius: 8px;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      touch-action: manipulation;
      white-space: nowrap;
    }

    .field-action i {
      font-size: 0.85rem;
    }

    .field-action-inline {
      align-self: stretch;
      padding: 0 0.65rem;
      border-radius: 9px;
    }

    .field-action-inline span {
      display: none;
    }

    .field-toggle {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.74rem;
      color: var(--text-secondary);
      padding: 0.3rem 0.6rem;
      border-radius: 999px;
      background: rgba(255, 162, 74, 0.08);
      border: 1px solid rgba(255, 162, 74, 0.2);
      flex-wrap: wrap;
      max-width: 100%;
    }

    .field-toggle span {
      white-space: normal;
    }

    .field-toggle input {
      accent-color: var(--accent);
    }

    .field-toggle input:disabled {
      cursor: not-allowed;
    }

    .field-toggle input:disabled + span {
      opacity: 0.6;
    }

    .field-action:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      transform: none;
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.65;
      transform: none;
      box-shadow: none;
    }

    .primary-button {
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      color: #1b1308;
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.35);
    }

    .primary-button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 18px 36px rgba(0, 0, 0, 0.4);
    }

    .secondary-button {
      background: rgba(15, 20, 34, 0.9);
      color: var(--text-secondary);
      border: 1px solid rgba(255, 162, 74, 0.25);
    }

    .secondary-button:hover:not(:disabled) {
      transform: translateY(-1px);
    }

    .ghost-button {
      background: rgba(255, 162, 74, 0.08);
      color: var(--text-secondary);
      border: 1px solid rgba(255, 162, 74, 0.2);
      padding-inline: 0.75rem;
    }

    .ghost-button:hover:not(:disabled) {
      background: rgba(255, 162, 74, 0.2);
      transform: translateY(-1px);
    }

    .preview-panel {
      position: sticky;
      top: calc(1.5rem + var(--sticky-header-offset));
    }

    .preview-toggle summary {
      list-style: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .preview-toggle summary::-webkit-details-marker {
      display: none;
    }

    .preview-toggle summary::after {
      content: '‚ñæ';
      font-size: 0.9rem;
      color: var(--accent);
      transition: transform 0.2s ease;
    }

    .preview-toggle[open] summary::after {
      transform: rotate(180deg);
    }

    .preview-toggle .preview-card {
      margin-top: 1rem;
    }

    .preview-card {
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: #101525;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
    }

    .preview-media {
      position: relative;
      height: 160px;
      background: linear-gradient(120deg, rgba(255, 162, 74, 0.2), rgba(16, 21, 37, 0.9));
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .preview-media img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: none;
    }

    .preview-media.has-image img {
      display: block;
    }

    .preview-media.has-image .preview-fallback {
      display: none;
    }

    .preview-fallback {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .preview-body {
      padding: 0.85rem 1rem 1rem;
    }

    .preview-city {
      font-size: 0.72rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--accent);
    }

    .preview-title {
      margin: 0.35rem 0 0.45rem;
      font-size: 1.1rem;
      color: var(--text-primary);
    }

    .preview-time,
    .preview-venue,
    .preview-address {
      margin: 0.18rem 0;
      color: var(--text-secondary);
      font-size: 0.85rem;
    }

    .preview-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      margin-top: 0.7rem;
    }

    .chip {
      background: var(--chip);
      border: 1px solid rgba(255, 162, 74, 0.4);
      color: var(--text-secondary);
      padding: 0.18rem 0.5rem;
      border-radius: 999px;
      font-size: 0.72rem;
      font-weight: 600;
    }

    .chip.is-muted {
      background: rgba(196, 200, 228, 0.08);
      border-color: rgba(196, 200, 228, 0.18);
      color: var(--text-muted);
    }

    .chip.is-hidden {
      display: none;
    }

    .preview-links {
      margin-top: 0.6rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .preview-links.is-hidden {
      display: none;
    }

    .preview-links a {
      font-size: 0.76rem;
      font-weight: 600;
      color: var(--text-secondary);
      text-decoration: none;
      background: rgba(255, 162, 74, 0.12);
      padding: 0.28rem 0.55rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 162, 74, 0.3);
    }

    .preview-links a:hover {
      background: rgba(255, 162, 74, 0.22);
    }

    .preview-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.85rem 1rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 162, 74, 0.12);
    }

    .preview-header h2 {
      margin: 0;
      font-size: 0.95rem;
      color: var(--text-primary);
    }

    .calendar-preview-card {
      border-radius: 14px;
      overflow: hidden;
      background: transparent;
      border: none;
      box-shadow: none;
    }

    #calendar-preview {
      width: 100%;
      height: 440px;
      border: none;
      background: #ffffff;
    }

    .status-badge {
      font-size: 0.75rem;
      font-weight: 600;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      border: 1px solid transparent;
    }

    .status-loading {
      background: rgba(255, 162, 74, 0.18);
      border-color: rgba(255, 162, 74, 0.35);
      color: #ffb45f;
    }

    .status-sending {
      background: rgba(255, 213, 137, 0.25);
      border-color: rgba(255, 213, 137, 0.4);
      color: #946300;
    }

    .status-ready {
      background: rgba(82, 196, 132, 0.18);
      border-color: rgba(82, 196, 132, 0.35);
      color: #146b3a;
    }

    .status-warn {
      background: rgba(255, 193, 7, 0.18);
      border-color: rgba(255, 193, 7, 0.35);
      color: #8a6200;
    }

    .status-error {
      background: rgba(244, 67, 54, 0.18);
      border-color: rgba(244, 67, 54, 0.35);
      color: #a12317;
    }

    .live-preview {
      margin-top: 0;
      overflow-anchor: none;
    }

    .live-preview details {
      border: none;
      padding: 0;
      background: transparent;
      box-shadow: none;
    }

    .live-preview details[open] {
      background: transparent;
      border: none;
      box-shadow: none;
    }

    .live-preview summary {
      font-size: 0.9rem;
    }

    .live-preview .calendar-preview-card {
      margin: 0.75rem -1.2rem 0;
      border-left: none;
      border-right: none;
      border-radius: 0 0 14px 14px;
    }

    .is-hidden {
      display: none !important;
    }

    .toast-container {
      position: fixed;
      left: 50%;
      bottom: 1.5rem;
      transform: translateX(-50%);
      width: min(420px, calc(100% - 2rem));
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      z-index: 999;
      pointer-events: none;
    }

    .toast {
      background: var(--panel-raised);
      border: 1px solid var(--border);
      color: var(--text-primary);
      padding: 0.55rem 0.75rem;
      border-radius: 10px;
      font-size: 0.8rem;
      box-shadow: 0 12px 22px rgba(0, 0, 0, 0.35);
      width: 100%;
      opacity: 0;
      transform: translateY(8px);
      animation: toast-in 0.2s ease forwards;
    }

    .toast.is-success {
      border-color: rgba(82, 196, 132, 0.4);
      color: #b9f1d2;
    }

    .toast.is-warn {
      border-color: rgba(255, 193, 7, 0.35);
      color: #ffe3a3;
    }

    .toast.is-error {
      border-color: rgba(244, 67, 54, 0.4);
      color: #ffb3aa;
    }

    .toast.is-hiding {
      animation: toast-out 0.2s ease forwards;
    }

    @keyframes toast-in {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes toast-out {
      to {
        opacity: 0;
        transform: translateY(8px);
      }
    }

    .recurrence-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.6rem;
      margin-bottom: 0;
      flex-wrap: wrap;
    }

    .recurrence-builder {
      display: grid;
      gap: 0.65rem;
    }

    .toggle-buttons {
      display: inline-flex;
      background: rgba(255, 162, 74, 0.12);
      border-radius: 999px;
      padding: 0.15rem;
      gap: 0.15rem;
    }

    .toggle-button {
      border: none;
      background: transparent;
      padding: 0.28rem 0.7rem;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .toggle-button.is-active {
      background: #1f2538;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      color: var(--text-primary);
    }

    .day-toggle {
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem;
    }

    .day-button {
      border: 1px solid rgba(255, 162, 74, 0.35);
      background: rgba(255, 162, 74, 0.12);
      color: var(--text-secondary);
      padding: 0.16rem 0.5rem;
      border-radius: 999px;
      font-size: 0.72rem;
      font-weight: 600;
      cursor: pointer;
    }

    .day-button.is-active {
      background: rgba(255, 162, 74, 0.3);
      border-color: rgba(255, 162, 74, 0.6);
      color: var(--text-primary);
    }

    .recurrence-summary {
      font-size: 0.72rem;
      color: var(--text-muted);
      margin-top: -0.3rem;
    }

    .recurrence-builder .field-row:last-of-type {
      margin-bottom: 0;
    }

    #recurrence-monthly .field-row {
      margin-bottom: 0.4rem;
    }

    #recurrence-monthly .field-row:last-child {
      margin-bottom: 0;
    }

    @media (max-width: 1080px) {
      .layout {
        grid-template-columns: 1fr;
      }

      .preview-panel {
        position: static;
      }

      .page-wrapper {
        padding-left: 1rem;
        padding-right: 1rem;
      }

      .panel {
        margin-left: -1rem;
        margin-right: -1rem;
        border-left: none;
        border-right: none;
        border-radius: 0;
      }

      .panel.form-panel {
        padding: 0;
      }

      .form-panel details.form-section {
        padding: 0.6rem 1rem;
        border-radius: 0;
        border-left: none;
        border-right: none;
      }
    }

    @media (max-width: 768px) {
      :root {
        --sticky-header-offset: 6.2rem;
      }

      input[type="text"],
      input[type="url"],
      input[type="datetime-local"],
      input[type="number"],
      input[type="date"],
      select,
      textarea {
        font-size: 16px;
      }

      .tool-nav {
        flex-direction: column;
        align-items: stretch;
        gap: 0.55rem;
        padding: 0.6rem 1rem 0.7rem;
      }

      .tool-nav .logo h1 {
        font-size: 1.2rem;
      }

      .tool-brand-text {
        flex-wrap: wrap;
      }

      .tool-actions {
        width: 100%;
        display: grid;
        grid-template-columns: 1fr;
        gap: 0.4rem;
      }

      .tool-page-label {
        font-size: 0.68rem;
      }

      .tool-buttons {
        width: 100%;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .tool-buttons .action-button {
        justify-content: center;
        flex: 1 1 calc(33.333% - 0.5rem);
        min-width: 0;
        width: auto;
        min-height: 36px;
        padding: 0.45rem 0.5rem;
        font-size: 0.75rem;
      }

      .existing-modal {
        width: min(560px, calc(100vw - 2rem));
        max-width: calc(100vw - 2rem);
      }

      .existing-modal__content {
        padding: 1rem;
        max-height: 90vh;
      }

      .page-wrapper {
        padding: calc(1.6rem + var(--sticky-header-offset)) 0 2.6rem;
      }

      .panel {
        margin-left: 0;
        margin-right: 0;
      }

      .form-panel .panel-header {
        padding: 1rem 1rem 0.4rem;
      }

      #event-form {
        padding: 0 0 1rem;
      }

      .form-actions {
        flex-direction: column;
        align-items: stretch;
      }

      .primary-actions {
        width: 100%;
      }

      .primary-actions button {
        flex: 1 1 auto;
      }

      .field-grid,
      .field-row {
        grid-template-columns: 1fr;
        gap: 0.65rem;
      }

      .existing-event-panel .field-grid {
        grid-template-columns: 1fr;
      }

      .field-row.time-row {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .live-preview .calendar-preview-card {
        margin: 0.65rem -1.1rem 0;
      }

      .preview-toggle summary::after {
        margin-left: auto;
      }
    }

    @media (max-width: 620px) {
      .field-row.time-row {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <header class="tool-header">
    <nav>
      <div class="nav-container tool-nav">
        <div class="logo">
          <h1>
            <a href="../index.html" aria-label="chunky.dad home">
              <img src="../favicons/favicon-96x96.png"
                   srcset="../favicons/favicon-96x96.png 1x, ../favicons/favicon-192x192.png 2x, ../favicons/favicon-256x256.png 3x"
                   alt="chunky.dad logo" class="logo-img">
              <span class="tool-brand-text">
                <span class="tool-brand-name">chunky.dad</span>
                <span class="tool-page-label">Event Builder</span>
              </span>
            </a>
          </h1>
        </div>
        <div class="tool-actions">
          <div class="tool-buttons">
            <button type="button" class="secondary-button action-button" id="reset-form" aria-label="Reset form">
              <i class="bi bi-arrow-counterclockwise" aria-hidden="true"></i>
              <span>Reset</span>
            </button>
            <button type="button" class="secondary-button action-button" id="edit-existing" aria-label="Edit or copy existing event" aria-expanded="false" aria-controls="existing-event-panel" aria-haspopup="dialog">
              <i class="bi bi-pencil-square" aria-hidden="true"></i>
              <span>Edit Existing</span>
            </button>
            <button type="button" class="primary-button action-button" id="copy-link" aria-label="Tell dad">
              <i class="bi bi-send" aria-hidden="true"></i>
              <span>Tell Dad</span>
            </button>
            <button type="button" class="primary-button action-button is-hidden" id="add-to-calendar" aria-label="Add to calendar">
              <i class="bi bi-calendar-plus" aria-hidden="true"></i>
              <span>Add</span>
            </button>
            <button type="button" class="primary-button action-button is-hidden" id="open-scriptable" aria-label="Open Scriptable">
              <i class="bi bi-box-arrow-up-right" aria-hidden="true"></i>
              <span>Scriptable</span>
            </button>
          </div>
        </div>
      </div>
    </nav>
  </header>

  <div class="page-wrapper">
    <main class="layout">
      <section class="panel form-panel">
        <div class="panel-header">
          <div>
            <h2>Event Details</h2>
            <div class="existing-selection-summary is-hidden" id="existing-selection-summary">
              <div id="existing-selection-text"></div>
              <div class="existing-selection-actions">
                <button type="button" class="ghost-button action-button is-compact" id="existing-change" aria-controls="existing-event-panel" aria-haspopup="dialog">
                  <i class="bi bi-search" aria-hidden="true"></i>
                  <span>Change</span>
                </button>
                <button type="button" class="ghost-button action-button is-compact" id="existing-copy-summary">
                  <i class="bi bi-files" aria-hidden="true"></i>
                  <span>Copy to New</span>
                </button>
                <button type="button" class="ghost-button action-button is-compact" id="existing-clear-summary">
                  <i class="bi bi-x-circle" aria-hidden="true"></i>
                  <span>Clear</span>
                </button>
              </div>
            </div>
          </div>
        </div>

        <form id="event-form">
          <details class="form-section" open>
            <summary>Basics</summary>
            <div class="section-body">
              <div class="field-grid">
                <div class="field-group">
                  <label for="event-name">Event Name</label>
                  <input type="text" id="event-name" autocomplete="off" placeholder="Bearracuda Chicago">
                </div>
                <div class="field-group">
                  <label for="event-short-name">Shorter event name (for the calendar, etc.)</label>
                  <input type="text" id="event-short-name" autocomplete="off" placeholder="Bearracuda">
                  <small>For long words, add <code>-</code> to help break them up (MEGA-WOOF). It will not show unless we need two lines. If you want a hyphen all the time, add <code>\-</code> instead. The <code>\</code> will not show.</small>
                </div>
                <div class="field-group">
                  <label for="event-cover">Cover / Price</label>
                  <input type="text" id="event-cover" autocomplete="off" placeholder="Free / $15 / Cover TBD">
                </div>
                <div class="field-group">
                  <label for="event-image">Promo Image URL</label>
                  <div class="input-with-action">
                    <input type="url" id="event-image" placeholder="https://chunky.dad/img/events/sample.jpg">
                    <button type="button" class="field-action field-action-inline" data-paste-target="event-image" aria-label="Paste promo image link">
                      <i class="bi bi-clipboard-plus" aria-hidden="true"></i>
                      <span>Paste</span>
                    </button>
                  </div>
                  <small>Image uploads aren‚Äôt allowed at this time, but you can add a public image link here.</small>
                </div>
              </div>

              <div class="field-group">
                <label for="event-description">Tea / Description</label>
                <textarea id="event-description" placeholder="Chunky bears takeover with DJs, go-go cubs, and midnight surprises."></textarea>
              </div>
            </div>
          </details>

          <details class="form-section">
            <summary>Venue</summary>
            <div class="section-body">
              <div class="field-grid">
                <div class="field-group">
                  <label for="event-city">City</label>
                  <select id="event-city"></select>
                </div>
                <div class="field-group">
                  <label for="event-venue-select">Saved Bars</label>
                  <select id="event-venue-select"></select>
                  <small class="field-hint" id="event-venue-select-hint" data-default="Choose a saved bar to auto-fill venue + map details.">Choose a saved bar to auto-fill venue + map details.</small>
                </div>
                <div class="field-group">
                  <label for="event-venue">Venue</label>
                  <input type="text" id="event-venue" autocomplete="off" placeholder="The Eagle NYC">
                </div>
                <div class="field-group">
                  <label for="event-address">Address</label>
                  <input type="text" id="event-address" autocomplete="off" placeholder="554 W 28th St, New York, NY">
                </div>
                <div class="field-group">
                  <label for="event-coordinates">Coordinates (lat, lng)</label>
                  <input type="text" id="event-coordinates" autocomplete="off" placeholder="40.7497, -73.9943">
                  <small class="field-hint" data-default="Use latitude, longitude from Google Maps.">Use latitude, longitude from Google Maps.</small>
                </div>
                <div class="field-group">
                  <label for="event-gmaps">Google Maps</label>
                  <div class="input-with-action">
                    <input type="text" id="event-gmaps" placeholder="https://maps.app.goo.gl/...">
                    <button type="button" class="field-action field-action-inline" data-paste-target="event-gmaps" aria-label="Paste Google Maps link">
                      <i class="bi bi-clipboard-plus" aria-hidden="true"></i>
                      <span>Paste</span>
                    </button>
                  </div>
                  <small class="field-hint" data-default=""></small>
                </div>
              </div>
            </div>
          </details>

          <details class="form-section">
            <summary>Time &amp; Recurrence</summary>
            <div class="section-body">
              <div class="field-row time-row">
                <div class="field-group">
                  <label for="event-start">Start</label>
                  <input type="datetime-local" id="event-start">
                </div>
                <div class="field-group">
                  <label for="event-end">End</label>
                  <input type="datetime-local" id="event-end">
                </div>
              </div>

              <div class="time-notes">
                <span class="time-note" id="duration-note"><strong>Duration:</strong> Add start &amp; end</span>
              </div>

              <div class="recurrence-toggle">
                <div class="field-group">
                  <label>Recurrence</label>
                </div>
                <div class="toggle-buttons" role="group" aria-label="Recurrence input mode">
                  <button type="button" class="toggle-button is-active" data-recurrence-mode="builder">Builder</button>
                  <button type="button" class="toggle-button" data-recurrence-mode="raw">Raw RRULE</button>
                </div>
              </div>

              <div class="recurrence-builder" id="recurrence-builder">
                <div class="field-row">
                  <div class="field-group">
                    <label for="recurrence-frequency">Repeats</label>
                    <select id="recurrence-frequency">
                      <option value="none">Does not repeat</option>
                      <option value="daily">Daily</option>
                      <option value="weekly">Weekly</option>
                      <option value="monthly">Monthly</option>
                    </select>
                  </div>
                  <div class="field-group" id="recurrence-interval-group">
                    <label for="recurrence-interval">Every</label>
                    <div class="input-with-action">
                      <input type="number" id="recurrence-interval" min="1" value="1">
                      <span class="input-suffix" id="recurrence-interval-label">week(s)</span>
                    </div>
                  </div>
                </div>

                <div class="field-row" id="recurrence-weekly">
                  <div class="field-group">
                    <label>Repeat on</label>
                    <div class="day-toggle" id="recurrence-weekdays">
                      <button type="button" class="day-button" data-day="MO">Mon</button>
                      <button type="button" class="day-button" data-day="TU">Tue</button>
                      <button type="button" class="day-button" data-day="WE">Wed</button>
                      <button type="button" class="day-button" data-day="TH">Thu</button>
                      <button type="button" class="day-button" data-day="FR">Fri</button>
                      <button type="button" class="day-button" data-day="SA">Sat</button>
                      <button type="button" class="day-button" data-day="SU">Sun</button>
                    </div>
                  </div>
                </div>

                <div class="field-row" id="recurrence-monthly">
                  <div class="field-group">
                    <label>Monthly pattern</label>
                    <div class="field-row">
                      <label class="checkbox-label">
                        <input type="radio" name="recurrence-monthly-mode" value="monthday" checked>
                        <span>On day</span>
                      </label>
                      <input type="number" id="recurrence-monthday" min="1" max="31" placeholder="15">
                    </div>
                    <div class="field-row">
                      <label class="checkbox-label">
                        <input type="radio" name="recurrence-monthly-mode" value="weekday">
                        <span>On the</span>
                      </label>
                      <div class="input-with-action">
                        <select id="recurrence-week-pos">
                          <option value="1">First</option>
                          <option value="2">Second</option>
                          <option value="3">Third</option>
                          <option value="4">Fourth</option>
                          <option value="-1">Last</option>
                        </select>
                        <select id="recurrence-weekday">
                          <option value="MO">Monday</option>
                          <option value="TU">Tuesday</option>
                          <option value="WE">Wednesday</option>
                          <option value="TH">Thursday</option>
                          <option value="FR">Friday</option>
                          <option value="SA">Saturday</option>
                          <option value="SU">Sunday</option>
                        </select>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="field-row" id="recurrence-ends-row">
                  <div class="field-group">
                    <label for="recurrence-ends">Ends</label>
                    <select id="recurrence-ends">
                      <option value="never">Never</option>
                      <option value="count">After # times</option>
                      <option value="until">On date</option>
                    </select>
                  </div>
                  <div class="field-group is-hidden" id="recurrence-count-group">
                    <label for="recurrence-count">After</label>
                    <input type="number" id="recurrence-count" min="1" placeholder="10">
                  </div>
                  <div class="field-group is-hidden" id="recurrence-until-group">
                    <label for="recurrence-until">On date</label>
                    <input type="date" id="recurrence-until">
                  </div>
                </div>
              </div>

              <div id="recurrence-raw" class="is-hidden">
                <div class="field-group">
                  <label for="event-recurrence">RRULE (raw)</label>
                  <input type="text" id="event-recurrence" placeholder="FREQ=WEEKLY;BYDAY=FR">
                  <small class="field-hint" data-default="Paste a full RRULE string.">Paste a full RRULE string.</small>
                </div>
              </div>

              <p class="recurrence-summary" id="recurrence-summary">Does not repeat.</p>
            </div>
          </details>

          <details class="form-section">
            <summary>Links</summary>
            <div class="section-body">
              <div class="field-grid">
                <div class="field-group">
                  <label for="event-website">Website</label>
                  <div class="input-with-action">
                    <input type="text" id="event-website" placeholder="https://bearracuda.com">
                    <button type="button" class="field-action field-action-inline" data-paste-target="event-website" aria-label="Paste website link">
                      <i class="bi bi-clipboard-plus" aria-hidden="true"></i>
                      <span>Paste</span>
                    </button>
                  </div>
                  <div class="field-actions">
                    <label class="field-toggle" for="venue-toggle-website">
                      <input type="checkbox" id="venue-toggle-website" data-venue-toggle="website">
                      <span>Use venue's website</span>
                    </label>
                  </div>
                  <small class="field-hint" data-default=""></small>
                </div>
                <div class="field-group">
                  <label for="event-ticket-url">Tickets</label>
                  <div class="input-with-action">
                    <input type="text" id="event-ticket-url" placeholder="https://tickets.example.com">
                    <button type="button" class="field-action field-action-inline" data-paste-target="event-ticket-url" aria-label="Paste ticket link">
                      <i class="bi bi-clipboard-plus" aria-hidden="true"></i>
                      <span>Paste</span>
                    </button>
                  </div>
                  <small class="field-hint" data-default=""></small>
                </div>
                <div class="field-group">
                  <label for="event-instagram">Instagram</label>
                  <div class="input-with-action">
                    <input type="text" id="event-instagram" placeholder="@bearracuda or instagram.com/bearracuda">
                    <button type="button" class="field-action field-action-inline" data-paste-target="event-instagram" aria-label="Paste Instagram link">
                      <i class="bi bi-clipboard-plus" aria-hidden="true"></i>
                      <span>Paste</span>
                    </button>
                  </div>
                  <div class="field-actions">
                    <label class="field-toggle" for="venue-toggle-instagram">
                      <input type="checkbox" id="venue-toggle-instagram" data-venue-toggle="instagram">
                      <span>Use venue's Instagram</span>
                    </label>
                  </div>
                  <small class="field-hint" data-default=""></small>
                </div>
                <div class="field-group">
                  <label for="event-facebook">Facebook</label>
                  <div class="input-with-action">
                    <input type="text" id="event-facebook" placeholder="facebook.com/bearracuda">
                    <button type="button" class="field-action field-action-inline" data-paste-target="event-facebook" aria-label="Paste Facebook link">
                      <i class="bi bi-clipboard-plus" aria-hidden="true"></i>
                      <span>Paste</span>
                    </button>
                  </div>
                  <div class="field-actions">
                    <label class="field-toggle" for="venue-toggle-facebook">
                      <input type="checkbox" id="venue-toggle-facebook" data-venue-toggle="facebook">
                      <span>Use venue's Facebook</span>
                    </label>
                  </div>
                  <small class="field-hint" data-default=""></small>
                </div>
              </div>
            </div>
          </details>

        </form>

      </section>

      <aside class="panel preview-panel">
        <details class="preview-toggle" open>
          <summary class="panel-header">
            <div>
              <h2>Live Preview</h2>
            </div>
          </summary>

          <div class="preview-card">
            <div class="preview-media" id="preview-media">
              <img id="preview-image" alt="" loading="lazy">
              <div class="preview-fallback">Add a promo image to preview artwork.</div>
            </div>
            <div class="preview-body">
              <div class="preview-city" id="preview-city">City</div>
              <h3 class="preview-title" id="preview-title">Untitled event</h3>
              <p class="preview-time" id="preview-time">Add start and end times to preview timing.</p>
              <p class="preview-venue" id="preview-venue">Venue TBA</p>
              <p class="preview-address" id="preview-address">Address TBD</p>
              <div class="preview-chips">
                <span class="chip is-hidden" id="preview-recurring">Recurring</span>
                <span class="chip is-hidden" id="preview-cover">Cover</span>
              </div>
              <div class="preview-links is-hidden" id="preview-links"></div>
            </div>
          </div>
        </details>
      </aside>
    </main>

    <section class="panel live-preview">
      <details id="live-preview" class="form-section">
        <summary>Live Website Preview</summary>
        <div class="calendar-preview-card">
          <div class="preview-header">
            <h2>Website Preview</h2>
            <span id="calendar-status" class="status-badge status-loading">Loading calendar‚Ä¶</span>
          </div>
          <iframe id="calendar-preview" title="chunky.dad calendar preview" src="../city.html?city=nyc"></iframe>
        </div>
      </details>
    </section>
  </div>

  <dialog class="existing-modal" id="existing-event-panel" aria-labelledby="existing-modal-title">
    <div class="existing-modal__content">
      <div class="existing-modal__header">
        <div>
          <h2 id="existing-modal-title">Edit or Copy Existing Event</h2>
          <p class="panel-subtitle">Choose a calendar, then optionally filter by text or date.</p>
        </div>
        <button type="button" class="ghost-button action-button existing-modal__close" id="existing-modal-close" aria-label="Close existing event dialog">
          <i class="bi bi-x-lg" aria-hidden="true"></i>
        </button>
      </div>

      <div class="section-body existing-event-panel">
        <div class="field-grid">
          <div class="field-group">
            <label for="existing-city">Calendar / City</label>
            <select id="existing-city"></select>
          </div>
          <div class="field-group">
            <label for="existing-search">Search text</label>
            <input type="text" id="existing-search" class="existing-filter-input" autocomplete="off" placeholder="Goldiloxx, Rockbar, Leather Nite">
            <small>Optional. Match event name, venue, or notes.</small>
          </div>
          <div class="field-group">
            <label for="existing-date">Search date</label>
            <input type="date" id="existing-date" class="existing-filter-input">
            <small>Optional. Filters events and occurrences on that day.</small>
          </div>
        </div>

        <div class="field-group">
          <label for="existing-results">Matching events</label>
          <select id="existing-results"></select>
          <small class="field-hint" id="existing-results-hint" data-default="Pick a series or single event to load into the form.">Pick a series or single event to load into the form.</small>
        </div>

        <div class="field-group is-hidden" id="existing-mode-group">
          <label>Use as</label>
          <div class="toggle-buttons" role="group" aria-label="Use occurrence or series">
            <button type="button" class="toggle-button is-active" data-edit-mode="occurrence">Occurrence</button>
            <button type="button" class="toggle-button" data-edit-mode="series">Series</button>
          </div>
          <small class="field-hint" id="existing-mode-hint" data-default=""></small>
        </div>

        <div class="field-group is-hidden" id="existing-occurrence-group">
          <label for="existing-occurrence">Occurrence</label>
          <select id="existing-occurrence"></select>
          <small class="field-hint" id="existing-occurrence-hint" data-default="Pick the occurrence to edit or copy. Use Search date to jump to a specific day.">Pick the occurrence to edit or copy. Use Search date to jump to a specific day.</small>
        </div>

        <div class="field-actions">
          <button type="button" class="primary-button action-button" id="existing-load">
            <i class="bi bi-pencil-square" aria-hidden="true"></i>
            <span>Edit event</span>
          </button>
          <button type="button" class="secondary-button action-button" id="existing-copy">
            <i class="bi bi-files" aria-hidden="true"></i>
            <span>Copy to New</span>
          </button>
          <button type="button" class="ghost-button action-button" id="existing-clear">
            <i class="bi bi-x-circle" aria-hidden="true"></i>
            <span>Clear</span>
          </button>
        </div>
      </div>
    </div>
  </dialog>

  <div class="toast-container" id="toast-container" aria-live="polite" aria-atomic="true"></div>

  <script src="../js/logger.js"></script>
  <script src="../js/calendar-core.js"></script>
  <script src="../js/city-config.js"></script>
  <script>
    (() => {
      const DEFAULT_DURATION_MINUTES = 240;
      const OCCURRENCE_LOOKAHEAD_DAYS = 365;
      const OCCURRENCE_MAX_COUNT = 18;
      const URL_UPDATE_DELAY = 120;
      const EVENT_PUSH_DELAY = 200;
      const browserTimezone = (Intl.DateTimeFormat().resolvedOptions().timeZone) || 'UTC';
      const DAY_CODE_LABELS = {
        MO: 'Mon',
        TU: 'Tue',
        WE: 'Wed',
        TH: 'Thu',
        FR: 'Fri',
        SA: 'Sat',
        SU: 'Sun'
      };
      const WEEK_POSITION_LABELS = {
        '1': 'First',
        '2': 'Second',
        '3': 'Third',
        '4': 'Fourth',
        '-1': 'Last'
      };
      const BAR_DATA_PATH = '../data/bars';
      const CALENDAR_DATA_PATH = '../data/calendars';
      const DAD_EMAIL = 'info@chunky.dad';
      const SCRIPTABLE_SCRIPT_NAME = 'bear-event-scraper-unified';

      const dom = {};
      let state;
      let recurrenceMode = 'builder';
      let isRecurrenceSyncing = false;
      let calendarReady = false;
      let iframeLoaded = false;
      let sendTimeoutId = null;
      let urlTimeoutId = null;
      let lastPasteActionAt = 0;
      let currentCalendarCity = null;
      let barRequestId = 0;
      let currentBars = [];
      let selectedBar = null;
      const barCache = {};
      const calendarCache = {};
      const calendarCore = typeof CalendarCore === 'function' ? new CalendarCore() : null;
      let existingCalendarIndex = null;
      let existingResults = [];
      let existingOccurrenceResults = [];
      let selectedExistingResult = null;
      let selectedExistingOccurrence = null;
      let selectedExistingMode = 'occurrence';
      let pendingExistingSelectionId = '';
      let pendingExistingOccurrenceId = '';
      let existingSearchTimeoutId = null;
      const existingPanelState = {
        city: '',
        searchText: '',
        dateValue: '',
        resultId: '',
        occurrenceId: '',
        mode: 'occurrence',
        hasState: false
      };

      document.addEventListener('DOMContentLoaded', init);

      function init() {
        cacheDom();
        setupStickyHeaderOffset();
        populateCityOptions();
        const baseState = createDefaultState();
        const urlState = loadStateFromUrl(baseState);
        state = { ...baseState, ...urlState.overrides };
        state.timezone = state.timezone || browserTimezone;
        normalizeStateLinks();
        ensureDateOrder();
        applyStateToForm();
        applyDebugVisibility();
        syncExistingSelectionSummaryFromState();
        syncExistingCitySelection();
        resetExistingResults('Choose a calendar to load events.');
        queueExistingSelectionFromState();
        bindEvents();
        populateVenueOptions(state.city);
        updateRecurrenceUi();
        updateTimeNotes();
        updatePreviewCard();
        updateUrl();
        updateCalendarSource(true);
        setupMessaging();
        scheduleEventPush();
        logger.componentInit('EVENT', 'Event builder initialized', {
          isEditingExisting: Boolean(state.isEditingExisting),
          editingMode: state.editingExistingMode || null
        });
      }

      function cacheDom() {
        dom.form = document.getElementById('event-form');
        dom.toolHeader = document.querySelector('.tool-header');
        dom.nameInput = document.getElementById('event-name');
        dom.shortNameInput = document.getElementById('event-short-name');
        dom.citySelect = document.getElementById('event-city');
        dom.venueSelect = document.getElementById('event-venue-select');
        dom.venueSelectHint = document.getElementById('event-venue-select-hint');
        dom.venueLinkToggles = document.querySelectorAll('[data-venue-toggle]');
        dom.pasteButtons = document.querySelectorAll('[data-paste-target]');
        dom.venueInput = document.getElementById('event-venue');
        dom.addressInput = document.getElementById('event-address');
        dom.coordinatesInput = document.getElementById('event-coordinates');
        dom.descriptionInput = document.getElementById('event-description');
        dom.coverInput = document.getElementById('event-cover');
        dom.startInput = document.getElementById('event-start');
        dom.endInput = document.getElementById('event-end');
        dom.durationNote = document.getElementById('duration-note');
        dom.recurrenceModeButtons = document.querySelectorAll('[data-recurrence-mode]');
        dom.recurrenceBuilder = document.getElementById('recurrence-builder');
        dom.recurrenceRaw = document.getElementById('recurrence-raw');
        dom.recurrenceFrequency = document.getElementById('recurrence-frequency');
        dom.recurrenceInterval = document.getElementById('recurrence-interval');
        dom.recurrenceIntervalGroup = document.getElementById('recurrence-interval-group');
        dom.recurrenceIntervalLabel = document.getElementById('recurrence-interval-label');
        dom.recurrenceWeekdays = document.getElementById('recurrence-weekdays');
        dom.recurrenceWeekdayButtons = document.querySelectorAll('#recurrence-weekdays .day-button');
        dom.recurrenceMonthlyMode = document.querySelectorAll('input[name="recurrence-monthly-mode"]');
        dom.recurrenceMonthday = document.getElementById('recurrence-monthday');
        dom.recurrenceWeekPos = document.getElementById('recurrence-week-pos');
        dom.recurrenceWeekday = document.getElementById('recurrence-weekday');
        dom.recurrenceWeeklyRow = document.getElementById('recurrence-weekly');
        dom.recurrenceMonthlyRow = document.getElementById('recurrence-monthly');
        dom.recurrenceEndsRow = document.getElementById('recurrence-ends-row');
        dom.recurrenceEnds = document.getElementById('recurrence-ends');
        dom.recurrenceCountGroup = document.getElementById('recurrence-count-group');
        dom.recurrenceUntilGroup = document.getElementById('recurrence-until-group');
        dom.recurrenceCount = document.getElementById('recurrence-count');
        dom.recurrenceUntil = document.getElementById('recurrence-until');
        dom.recurrenceSummary = document.getElementById('recurrence-summary');
        dom.recurrenceInput = document.getElementById('event-recurrence');
        dom.websiteInput = document.getElementById('event-website');
        dom.ticketUrlInput = document.getElementById('event-ticket-url');
        dom.instagramInput = document.getElementById('event-instagram');
        dom.facebookInput = document.getElementById('event-facebook');
        dom.gmapsInput = document.getElementById('event-gmaps');
        dom.imageInput = document.getElementById('event-image');
        dom.resetButton = document.getElementById('reset-form');
        dom.addToCalendarButton = document.getElementById('add-to-calendar');
        dom.openScriptableButton = document.getElementById('open-scriptable');
        dom.copyShareButton = document.getElementById('copy-link');
        dom.editExistingButton = document.getElementById('edit-existing');
        dom.existingPanel = document.getElementById('existing-event-panel');
        dom.existingModalClose = document.getElementById('existing-modal-close');
        dom.existingCitySelect = document.getElementById('existing-city');
        dom.existingSearchInput = document.getElementById('existing-search');
        dom.existingDateInput = document.getElementById('existing-date');
        dom.existingResultsSelect = document.getElementById('existing-results');
        dom.existingResultsHint = document.getElementById('existing-results-hint');
        dom.existingModeGroup = document.getElementById('existing-mode-group');
        dom.existingModeButtons = document.querySelectorAll('[data-edit-mode]');
        dom.existingModeHint = document.getElementById('existing-mode-hint');
        dom.existingOccurrenceGroup = document.getElementById('existing-occurrence-group');
        dom.existingOccurrenceSelect = document.getElementById('existing-occurrence');
        dom.existingOccurrenceHint = document.getElementById('existing-occurrence-hint');
        dom.existingLoadButton = document.getElementById('existing-load');
        dom.existingCopyButton = document.getElementById('existing-copy');
        dom.existingClearButton = document.getElementById('existing-clear');
        dom.existingSelectionSummary = document.getElementById('existing-selection-summary');
        dom.existingSelectionText = document.getElementById('existing-selection-text');
        dom.existingChangeButton = document.getElementById('existing-change');
        dom.existingCopySummaryButton = document.getElementById('existing-copy-summary');
        dom.existingClearSummaryButton = document.getElementById('existing-clear-summary');
        dom.calendarIframe = document.getElementById('calendar-preview');
        dom.calendarStatus = document.getElementById('calendar-status');
        dom.previewMedia = document.getElementById('preview-media');
        dom.previewImage = document.getElementById('preview-image');
        dom.previewCity = document.getElementById('preview-city');
        dom.previewTitle = document.getElementById('preview-title');
        dom.previewTime = document.getElementById('preview-time');
        dom.previewVenue = document.getElementById('preview-venue');
        dom.previewAddress = document.getElementById('preview-address');
        dom.previewRecurring = document.getElementById('preview-recurring');
        dom.previewCover = document.getElementById('preview-cover');
        dom.previewLinks = document.getElementById('preview-links');
        dom.toastContainer = document.getElementById('toast-container');
      }

      function applyDebugVisibility() {
        const showDebug = Boolean(state && state.debug);
        if (dom.addToCalendarButton) {
          dom.addToCalendarButton.classList.toggle('is-hidden', !showDebug);
        }
        if (dom.openScriptableButton) {
          dom.openScriptableButton.classList.toggle('is-hidden', !showDebug);
        }
      }

      function setupStickyHeaderOffset() {
        updateStickyHeaderOffset();
        if (!dom.toolHeader) return;
        if ('ResizeObserver' in window) {
          dom.headerObserver = new ResizeObserver(() => {
            updateStickyHeaderOffset();
          });
          dom.headerObserver.observe(dom.toolHeader);
        } else {
          window.addEventListener('resize', updateStickyHeaderOffset);
        }
      }

      function updateStickyHeaderOffset() {
        if (!dom.toolHeader) return;
        const height = Math.ceil(dom.toolHeader.getBoundingClientRect().height);
        document.documentElement.style.setProperty('--sticky-header-offset', `${height}px`);
      }

      function populateCityOptions() {
        let cities = [];
        if (typeof getAvailableCities === 'function') {
          cities = getAvailableCities();
        } else if (typeof CITY_CONFIG === 'object' && CITY_CONFIG) {
          cities = Object.keys(CITY_CONFIG).map(key => ({
            key,
            ...CITY_CONFIG[key]
          }));
        } else {
          const fallbackCities = ['nyc'];
          cities = fallbackCities.map(key => ({
            key,
            name: key.replace(/-/g, ' ').replace(/\b\w/g, char => char.toUpperCase())
          }));
        }
        cities.sort((a, b) => {
          const nameA = (a.name || a.key || '').toLowerCase();
          const nameB = (b.name || b.key || '').toLowerCase();
          return nameA.localeCompare(nameB);
        });
        fillCitySelect(dom.citySelect, cities);
        fillCitySelect(dom.existingCitySelect, cities);
      }

      function fillCitySelect(select, cities) {
        if (!select) return;
        select.innerHTML = '';
        cities.forEach(city => {
          const option = document.createElement('option');
          option.value = city.key;
          option.textContent = city.emoji ? `${city.emoji} ${city.name}` : city.name || city.key;
          select.appendChild(option);
        });
      }

      function syncExistingCitySelection(options = {}) {
        if (!dom.existingCitySelect || !state || !state.city) return;
        if (dom.existingCitySelect.value !== state.city) {
          dom.existingCitySelect.value = state.city;
          if (options.refresh) {
            scheduleExistingResultsUpdate();
          }
        }
      }

      async function populateVenueOptions(cityKey) {
        if (!dom.venueSelect) return;
        const requestId = ++barRequestId;
        dom.venueSelect.disabled = true;
        dom.venueSelect.innerHTML = '';
        dom.venueSelect.appendChild(new Option('Loading saved bars...', ''));
        setVenueSelectHint('Loading saved bars for this city...');
        const bars = await fetchBarsForCity(cityKey);
        if (requestId !== barRequestId) return;
        currentBars = bars;
        selectedBar = null;
        dom.venueSelect.innerHTML = '';
        const previousSavedBar = state ? state.savedBar : '';
        if (!bars.length) {
          dom.venueSelect.appendChild(new Option('No saved bars for this city', ''));
          dom.venueSelect.disabled = true;
          setVenueSelectHint('No saved bars yet. Enter venue details manually.');
          if (state) {
            state.savedBar = '';
          }
          updateVenueLinkToggles({ applyValues: false });
          if (previousSavedBar) {
            refreshUi();
          }
          return;
        }
        dom.venueSelect.appendChild(new Option('Choose a saved bar (optional)', ''));
        bars.forEach((bar, index) => {
          const option = new Option(bar.name, String(index));
          dom.venueSelect.appendChild(option);
        });
        dom.venueSelect.value = '';
        dom.venueSelect.disabled = false;
        setVenueSelectHint('Selecting a bar will fill venue, address, coordinates, and Google Maps.');
        const selectionApplied = applySavedBarSelection(bars);
        const savedBarChanged = previousSavedBar !== (state ? state.savedBar : '');
        if (selectionApplied || savedBarChanged) {
          refreshUi();
        } else {
          updateVenueLinkToggles({ applyValues: false, preserveState: true });
        }
      }

      function findSavedBarIndex(bars, savedBarValue) {
        if (!savedBarValue || !Array.isArray(bars)) return -1;
        const rawValue = String(savedBarValue || '').trim();
        const numeric = parseInt(rawValue, 10);
        if (Number.isFinite(numeric) && String(numeric) === rawValue && bars[numeric]) {
          return numeric;
        }
        const normalizedTarget = normalizeText(rawValue).toLowerCase();
        if (!normalizedTarget) return -1;
        return bars.findIndex(bar => normalizeText(bar.name).toLowerCase() === normalizedTarget);
      }

      function applySavedBarSelection(bars) {
        if (!dom.venueSelect) return false;
        const savedBarValue = state ? state.savedBar : '';
        if (!savedBarValue) {
          selectedBar = null;
          dom.venueSelect.value = '';
          updateVenueLinkToggles({ applyValues: false, preserveState: true });
          return false;
        }
        const index = findSavedBarIndex(bars, savedBarValue);
        if (index < 0 || !bars[index]) {
          if (state) {
            state.savedBar = '';
          }
          selectedBar = null;
          dom.venueSelect.value = '';
          updateVenueLinkToggles({ applyValues: false });
          return false;
        }
        selectedBar = bars[index];
        dom.venueSelect.value = String(index);
        if (state) {
          state.savedBar = normalizeText(selectedBar.name);
        }
        applyBarDetails(selectedBar, { preserveExisting: true });
        assumeVenueLinkTogglesFromState(selectedBar);
        updateVenueLinkToggles({ applyValues: true });
        return true;
      }

      async function fetchBarsForCity(cityKey) {
        if (!cityKey) return [];
        if (Object.prototype.hasOwnProperty.call(barCache, cityKey)) {
          return barCache[cityKey];
        }
        try {
          const response = await fetch(`${BAR_DATA_PATH}/${cityKey}.json`, { cache: 'no-store' });
          if (!response.ok) {
            throw new Error(`Missing bars for ${cityKey}`);
          }
          const data = await response.json();
          const bars = Array.isArray(data)
            ? data
              .filter(item => item && typeof item === 'object')
              .map(item => ({
                ...item,
                name: String(item.name || '').trim()
              }))
              .filter(item => item.name)
              .sort((a, b) => a.name.localeCompare(b.name))
            : [];
          barCache[cityKey] = bars;
        } catch (error) {
          barCache[cityKey] = [];
        }
        return barCache[cityKey];
      }

      function resetExistingResults(message) {
        if (!dom.existingResultsSelect) return;
        const fallback = message || 'Choose a calendar to load events.';
        dom.existingResultsSelect.innerHTML = '';
        dom.existingResultsSelect.appendChild(new Option(fallback, ''));
        dom.existingResultsSelect.disabled = true;
        setExistingResultsHint(fallback, false);
        existingResults = [];
        selectedExistingResult = null;
        selectedExistingOccurrence = null;
        pendingExistingSelectionId = '';
        pendingExistingOccurrenceId = '';
        existingOccurrenceResults = [];
        updateExistingModeUi(null);
      }

      function setExistingResultsHint(message, isError) {
        if (!dom.existingResultsHint) return;
        setFieldHint(dom.existingResultsHint, message || '', Boolean(isError));
      }

      function resetExistingOccurrences(message) {
        if (!dom.existingOccurrenceSelect) return;
        const fallback = message || 'Select an event to see occurrences.';
        dom.existingOccurrenceSelect.innerHTML = '';
        dom.existingOccurrenceSelect.appendChild(new Option(fallback, ''));
        dom.existingOccurrenceSelect.disabled = true;
        setExistingOccurrenceHint(message || fallback, false);
        existingOccurrenceResults = [];
        selectedExistingOccurrence = null;
        updateExistingActionButtons();
      }

      function setExistingOccurrenceHint(message, isError) {
        if (!dom.existingOccurrenceHint) return;
        setFieldHint(dom.existingOccurrenceHint, message || '', Boolean(isError));
      }

      function storeExistingPanelState() {
        if (!dom.existingCitySelect) return;
        const panelIsOpen = Boolean(dom.existingPanel && dom.existingPanel.open);
        if (!panelIsOpen) return;
        existingPanelState.city = dom.existingCitySelect.value || '';
        existingPanelState.searchText = dom.existingSearchInput ? dom.existingSearchInput.value : '';
        existingPanelState.dateValue = dom.existingDateInput ? dom.existingDateInput.value : '';
        existingPanelState.resultId = selectedExistingResult ? selectedExistingResult.id : '';
        existingPanelState.occurrenceId = selectedExistingOccurrence ? selectedExistingOccurrence.id : '';
        existingPanelState.mode = selectedExistingMode === 'series' ? 'series' : 'occurrence';
        existingPanelState.hasState = true;
      }

      function restoreExistingPanelState() {
        if (!dom.existingCitySelect || !existingPanelState.hasState) return false;
        if (existingPanelState.city
          && [...dom.existingCitySelect.options].some(option => option.value === existingPanelState.city)) {
          dom.existingCitySelect.value = existingPanelState.city;
        }
        if (dom.existingSearchInput) {
          dom.existingSearchInput.value = existingPanelState.searchText || '';
        }
        if (dom.existingDateInput) {
          dom.existingDateInput.value = existingPanelState.dateValue || '';
        }
        selectedExistingMode = existingPanelState.mode === 'series' ? 'series' : 'occurrence';
        pendingExistingSelectionId = existingPanelState.resultId || '';
        pendingExistingOccurrenceId = existingPanelState.occurrenceId || '';
        scheduleExistingResultsUpdate();
        return true;
      }

      function queueExistingSelectionFromState(options = {}) {
        if (!state || !state.isEditingExisting) return;
        const { force = false } = options;
        const storedId = state.editingExistingId || '';
        const storedOccurrenceId = state.editingExistingOccurrenceId || '';
        const fallbackOccurrence = (!storedOccurrenceId && isOccurrenceResultId(storedId)) ? storedId : '';
        const nextOccurrenceId = storedOccurrenceId || fallbackOccurrence;
        const nextSelectionId = nextOccurrenceId && nextOccurrenceId === storedId ? '' : storedId;
        if (!force && nextSelectionId && selectedExistingResult && selectedExistingResult.id === nextSelectionId) {
          pendingExistingOccurrenceId = nextOccurrenceId;
          return;
        }
        pendingExistingSelectionId = nextSelectionId;
        pendingExistingOccurrenceId = nextOccurrenceId;
        selectedExistingMode = state.editingExistingMode === 'series' ? 'series' : 'occurrence';
        if (dom.existingCitySelect && state.city && dom.existingCitySelect.value !== state.city) {
          dom.existingCitySelect.value = state.city;
        }
        scheduleExistingResultsUpdate();
      }

      function scheduleExistingResultsUpdate() {
        if (existingSearchTimeoutId) {
          clearTimeout(existingSearchTimeoutId);
        }
        existingSearchTimeoutId = setTimeout(() => {
          existingSearchTimeoutId = null;
          updateExistingResults();
        }, 150);
      }

      async function updateExistingResults() {
        if (!dom.existingResultsSelect || !dom.existingCitySelect) return;
        const cityKey = dom.existingCitySelect.value || '';
        if (!cityKey) {
          existingCalendarIndex = null;
          resetExistingResults('Choose a calendar to load events.');
          return;
        }
        if (!calendarCore) {
          existingCalendarIndex = null;
          resetExistingResults('Calendar tools are unavailable here.');
          return;
        }
        setExistingResultsHint('Loading calendar events...', false);
        dom.existingResultsSelect.disabled = true;
        try {
          const index = await fetchCalendarIndex(cityKey);
          const textFilter = normalizeText(dom.existingSearchInput ? dom.existingSearchInput.value : '').toLowerCase();
          const dateValue = dom.existingDateInput ? dom.existingDateInput.value : '';
          const results = buildExistingResults(index, { textFilter, dateValue, now: new Date() });
          existingCalendarIndex = index;
          existingResults = results;
          renderExistingResults(results);
        } catch (error) {
          existingCalendarIndex = null;
          resetExistingResults('Unable to load that calendar.');
          showToast('Calendar data could not be loaded.', 'warn');
        }
      }

      function renderExistingResults(results) {
        if (!dom.existingResultsSelect) return;
        const previousId = pendingExistingSelectionId || (selectedExistingResult ? selectedExistingResult.id : '');
        dom.existingResultsSelect.innerHTML = '';
        if (!results.length) {
          dom.existingResultsSelect.appendChild(new Option('No matches found', ''));
          dom.existingResultsSelect.disabled = true;
          setExistingResultsHint('No matches found.', false);
          selectedExistingResult = null;
          updateExistingModeUi(null);
          return;
        }
        dom.existingResultsSelect.appendChild(new Option('Select an event...', ''));
        results.forEach((result, index) => {
          const option = new Option(result.label, String(index));
          dom.existingResultsSelect.appendChild(option);
        });
        dom.existingResultsSelect.disabled = false;
        setExistingResultsHint(`${results.length} match${results.length === 1 ? '' : 'es'} found.`, false);
        const previousResultId = selectedExistingResult ? selectedExistingResult.id : '';
        let matchIndex = -1;
        if (previousId) {
          matchIndex = results.findIndex(result => result.id === previousId);
        }
        if (matchIndex < 0 && pendingExistingOccurrenceId) {
          const parsed = parseResultId(pendingExistingOccurrenceId);
          if (parsed.uid) {
            matchIndex = results.findIndex(result => result.event
              && (result.event.uid === parsed.uid || result.event.name === parsed.uid));
          }
        }
        if (matchIndex >= 0) {
          dom.existingResultsSelect.value = String(matchIndex);
          selectedExistingResult = results[matchIndex];
          if (previousResultId && previousResultId !== selectedExistingResult.id && !pendingExistingOccurrenceId) {
            selectedExistingOccurrence = null;
          }
          if ((pendingExistingSelectionId || pendingExistingOccurrenceId) && state && state.isEditingExisting) {
            const requestedMode = state.editingExistingMode === 'series' ? 'series' : 'occurrence';
            if (requestedMode === 'series' && !selectedExistingResult.canEditSeries) {
              selectedExistingMode = getDefaultExistingMode(selectedExistingResult);
            } else {
              selectedExistingMode = requestedMode;
            }
            if (state.editingExistingMode !== selectedExistingMode) {
              state.editingExistingMode = selectedExistingMode;
              scheduleUrlUpdate();
            }
          } else if (pendingExistingSelectionId || pendingExistingOccurrenceId) {
            const requestedMode = selectedExistingMode === 'series' ? 'series' : 'occurrence';
            if (requestedMode === 'series' && !selectedExistingResult.canEditSeries) {
              selectedExistingMode = getDefaultExistingMode(selectedExistingResult);
            } else {
              selectedExistingMode = requestedMode;
            }
          } else {
            selectedExistingMode = getDefaultExistingMode(selectedExistingResult);
          }
          updateExistingModeUi(selectedExistingResult);
          pendingExistingSelectionId = '';
          return;
        }
        pendingExistingSelectionId = '';
        selectedExistingResult = null;
        updateExistingModeUi(null);
      }

      async function fetchCalendarIndex(cityKey) {
        if (!cityKey) {
          return buildCalendarIndex([], cityKey);
        }
        if (Object.prototype.hasOwnProperty.call(calendarCache, cityKey)) {
          return calendarCache[cityKey];
        }
        const response = await fetch(`${CALENDAR_DATA_PATH}/${cityKey}.ics`, { cache: 'no-store' });
        if (!response.ok) {
          throw new Error(`Missing calendar for ${cityKey}`);
        }
        const text = await response.text();
        const events = calendarCore.parseICalData(text) || [];
        const index = buildCalendarIndex(events, cityKey);
        calendarCache[cityKey] = index;
        return index;
      }

      function buildCalendarIndex(events, cityKey) {
        const normalized = Array.isArray(events)
          ? events.map(event => normalizeExistingEvent(event, cityKey)).filter(Boolean)
          : [];
        const baseEvents = [];
        const singleEvents = [];
        const overrides = [];
        const baseByUid = new Map();
        normalized.forEach(event => {
          if (event.recurrenceId) {
            overrides.push(event);
            return;
          }
          if (event.recurring && event.recurrence) {
            baseEvents.push(event);
            if (event.uid && !baseByUid.has(event.uid)) {
              baseByUid.set(event.uid, event);
            }
            return;
          }
          singleEvents.push(event);
        });
        const overridesByUidDateKey = new Map();
        overrides.forEach(override => {
          if (!override.uid) return;
          const dateKey = override.recurrenceDateKey || override.dateKey;
          if (!dateKey) return;
          overridesByUidDateKey.set(`${override.uid}::${dateKey}`, override);
        });
        return {
          cityKey,
          events: normalized,
          baseEvents,
          singleEvents,
          overrides,
          baseByUid,
          overridesByUidDateKey
        };
      }

      function normalizeExistingEvent(event, cityKey) {
        if (!event || typeof event !== 'object') return null;
        const description = event.unprocessedDescription || '';
        const address = extractDescriptionValue(description, ['address', 'addr']);
        const timezoneFromDescription = extractDescriptionValue(description, ['timezone', 'tz']);
        const timeZone = event.startTimezone || timezoneFromDescription || event.calendarTimezone || browserTimezone;
        const startDate = event.startDate instanceof Date ? new Date(event.startDate) : (event.startDate ? new Date(event.startDate) : null);
        const endDate = event.endDate instanceof Date ? new Date(event.endDate) : (event.endDate ? new Date(event.endDate) : null);
        const recurrenceId = event.recurrenceId instanceof Date ? new Date(event.recurrenceId) : (event.recurrenceId ? new Date(event.recurrenceId) : null);
        const coordinates = event.coordinates && typeof event.coordinates === 'object'
          ? event.coordinates
          : parseCoordinates(event.location || '');
        const location = normalizeCoordinatesValue(coordinates || event.location);
        const normalized = {
          uid: event.uid || '',
          name: normalizeText(event.name || ''),
          shortName: normalizeText(event.shortName || ''),
          shorterName: normalizeText(event.shorterName || ''),
          bar: normalizeText(event.bar || event.venue || ''),
          address: normalizeText(address || ''),
          location,
          coordinates,
          tea: normalizeText(event.tea || event.description || ''),
          description: normalizeText(event.description || ''),
          cover: normalizeText(event.cover || ''),
          website: normalizeText(event.website || ''),
          instagram: normalizeText(event.instagram || ''),
          facebook: normalizeText(event.facebook || ''),
          gmaps: normalizeText(event.gmaps || ''),
          ticketUrl: normalizeText(event.ticketUrl || event.tickets || ''),
          image: normalizeText(event.image || ''),
          recurrence: normalizeText(event.recurrence || ''),
          recurring: Boolean(event.recurrence),
          recurrenceId,
          sequence: Number.isFinite(event.sequence) ? event.sequence : null,
          startDate,
          endDate,
          timeZone,
          city: cityKey || '',
          dateKey: startDate ? formatDateKey(startDate) : '',
          recurrenceDateKey: recurrenceId ? formatDateKey(recurrenceId) : ''
        };
        normalized.searchBlob = buildSearchBlob(normalized, null);
        return normalized;
      }

      function extractDescriptionValue(description, keys) {
        if (!description) return '';
        const normalizedKeys = keys.map(key => key.toLowerCase().replace(/\s+/g, ''));
        const lines = String(description).replace(/\r/g, '').split('\n');
        for (const line of lines) {
          const separatorIndex = line.indexOf(':');
          if (separatorIndex === -1) continue;
          const rawKey = line.slice(0, separatorIndex).trim();
          const normalizedKey = rawKey.toLowerCase().replace(/\s+/g, '');
          if (!normalizedKeys.includes(normalizedKey)) continue;
          const value = line.slice(separatorIndex + 1).trim();
          return normalizeText(decodeHtmlEntities(value));
        }
        return '';
      }

      function decodeHtmlEntities(value) {
        if (!value || typeof value !== 'string' || !value.includes('&')) return value;
        const textarea = document.createElement('textarea');
        textarea.innerHTML = value;
        return textarea.value;
      }

      function buildSearchBlob(event, baseEvent) {
        const parts = [
          event.name,
          event.shortName,
          event.shorterName,
          event.bar,
          event.address,
          event.tea,
          event.description,
          event.website,
          event.instagram,
          event.ticketUrl
        ];
        if (baseEvent) {
          parts.push(baseEvent.name, baseEvent.shortName, baseEvent.shorterName, baseEvent.bar);
        }
        return parts.filter(Boolean).join(' ').toLowerCase();
      }

      function isValidDateObject(date) {
        return date instanceof Date && !Number.isNaN(date.getTime());
      }

      function isEndDateEditable(endDate, now = new Date()) {
        if (!isValidDateObject(endDate)) return false;
        return endDate.getTime() >= now.getTime();
      }

      function startOfDay(date) {
        if (!isValidDateObject(date)) return null;
        return new Date(date.getFullYear(), date.getMonth(), date.getDate());
      }

      function parseResultId(id) {
        const parts = String(id || '').split('::');
        return {
          uid: parts[0] || '',
          type: parts[1] || '',
          dateKey: parts[2] || ''
        };
      }

      function isOccurrenceResultId(id) {
        const parsed = parseResultId(id);
        return parsed.type === 'override' || parsed.type === 'occurrence';
      }

      function buildExistingResults(index, filters = {}) {
        if (!index) return [];
        const results = [];
        const added = new Set();
        const dateValue = filters.dateValue || '';
        const textFilter = filters.textFilter || '';
        const targetDate = dateValue ? parseDateValue(dateValue) : null;
        const now = filters.now instanceof Date ? filters.now : new Date();
        const includePast = Boolean(textFilter || dateValue);

        const addIfMatches = result => {
          if (!result) return;
          if (textFilter && !result.searchBlob.includes(textFilter)) return;
          addExistingResult(results, result, added);
        };

        if (targetDate && dateValue) {
          index.baseEvents.forEach(baseEvent => {
            if (!baseEvent.recurrence) return;
            const occurrences = buildOccurrenceResultsForEvent(index, baseEvent, {
              dateValue,
              now,
              maxCount: 1,
              windowDays: 1,
              includePast: true
            });
            if (!occurrences.length) return;
            addIfMatches(buildResultEntry({
              event: baseEvent,
              baseEvent,
              type: 'series'
            }));
          });

          index.singleEvents.forEach(singleEvent => {
            if (singleEvent.dateKey !== dateValue) return;
            if (!includePast && !isEndDateEditable(singleEvent.endDate, now)) return;
            addIfMatches(buildResultEntry({
              event: singleEvent,
              baseEvent: null,
              type: 'single',
              occurrenceDate: targetDate,
              startDate: singleEvent.startDate,
              endDate: singleEvent.endDate
            }));
          });
        } else {
          index.baseEvents.forEach(baseEvent => {
            if (!baseEvent.recurrence) return;
            if (!includePast) {
              const occurrences = buildOccurrenceResultsForEvent(index, baseEvent, {
                now,
                maxCount: 1,
                windowDays: OCCURRENCE_LOOKAHEAD_DAYS
              });
              if (!occurrences.length) return;
            }
            addIfMatches(buildResultEntry({
              event: baseEvent,
              baseEvent,
              type: 'series'
            }));
          });

          index.singleEvents.forEach(singleEvent => {
            if (!includePast && !isEndDateEditable(singleEvent.endDate, now)) return;
            addIfMatches(buildResultEntry({
              event: singleEvent,
              baseEvent: null,
              type: 'single',
              startDate: singleEvent.startDate,
              endDate: singleEvent.endDate
            }));
          });
        }

        results.sort((a, b) => {
          const dateSort = (a.startDate && b.startDate) ? a.startDate - b.startDate : 0;
          if (dateSort !== 0) return dateSort;
          const nameA = (a.event.name || '').toLowerCase();
          const nameB = (b.event.name || '').toLowerCase();
          return nameA.localeCompare(nameB);
        });

        return results;
      }

      function buildOccurrenceResultsForEvent(index, baseEvent, options = {}) {
        if (!index || !baseEvent || !baseEvent.recurrence) return [];
        const results = [];
        const added = new Set();
        const now = options.now instanceof Date ? options.now : new Date();
        const dateValue = options.dateValue || '';
        const maxCount = Number.isFinite(options.maxCount) ? options.maxCount : OCCURRENCE_MAX_COUNT;
        const windowDays = Number.isFinite(options.windowDays) ? options.windowDays : OCCURRENCE_LOOKAHEAD_DAYS;
        const includePast = Boolean(options.includePast);
        const overrides = (index.overrides || []).filter(override => override.uid && override.uid === baseEvent.uid);

        const addOverrideResult = override => {
          if (!override) return;
          if (!includePast && !isEndDateEditable(override.endDate, now)) return;
          addExistingResult(results, buildResultEntry({
            event: override,
            baseEvent,
            type: 'override',
            occurrenceDate: override.recurrenceId || override.startDate,
            startDate: override.startDate,
            endDate: override.endDate
          }), added);
        };

        const addOccurrenceResult = targetDate => {
          const occurrenceDates = buildOccurrenceDates(baseEvent, targetDate);
          if (!includePast && !isEndDateEditable(occurrenceDates.end, now)) return;
          addExistingResult(results, buildResultEntry({
            event: baseEvent,
            baseEvent,
            type: 'occurrence',
            occurrenceDate: targetDate,
            startDate: occurrenceDates.start,
            endDate: occurrenceDates.end
          }), added);
        };

        if (dateValue) {
          const targetDate = parseDateValue(dateValue);
          if (!targetDate) return results;
          const dateKey = formatDateKey(targetDate);
          let override = null;
          if (baseEvent.uid) {
            override = index.overridesByUidDateKey.get(`${baseEvent.uid}::${dateKey}`) || null;
          }
          if (!override && overrides.length) {
            override = overrides.find(item => formatDateKey(item.startDate) === dateKey) || null;
          }
          if (override) {
            addOverrideResult(override);
          } else if (doesRecurringEventMatchDate(baseEvent, targetDate)) {
            addOccurrenceResult(targetDate);
          }
        } else {
          const today = startOfDay(now);
          const eventStartDay = startOfDay(baseEvent.startDate);
          if (today) {
            const cursor = (eventStartDay && eventStartDay > today) ? eventStartDay : today;
            for (let dayOffset = 0; dayOffset < windowDays; dayOffset += 1) {
              const targetDate = new Date(cursor);
              targetDate.setDate(cursor.getDate() + dayOffset);
              if (!doesRecurringEventMatchDate(baseEvent, targetDate)) continue;
              const dateKey = formatDateKey(targetDate);
              const override = baseEvent.uid
                ? index.overridesByUidDateKey.get(`${baseEvent.uid}::${dateKey}`)
                : null;
              if (override) {
                addOverrideResult(override);
              } else {
                addOccurrenceResult(targetDate);
              }
              if (results.length >= maxCount) {
                break;
              }
            }
          }
          overrides.forEach(addOverrideResult);
        }

        results.sort((a, b) => {
          const dateSort = (a.startDate && b.startDate) ? a.startDate - b.startDate : 0;
          if (dateSort !== 0) return dateSort;
          const nameA = (a.event.name || '').toLowerCase();
          const nameB = (b.event.name || '').toLowerCase();
          return nameA.localeCompare(nameB);
        });

        return results;
      }

      function addExistingResult(results, result, added) {
        if (!result || !result.id) return;
        if (added.has(result.id)) return;
        added.add(result.id);
        results.push(result);
      }

      function buildResultEntry(options) {
        if (!options || !options.event) return null;
        const event = options.event;
        const baseEvent = options.baseEvent || null;
        const occurrenceDate = options.occurrenceDate || null;
        const type = options.type || 'single';
        const id = buildResultId(event, type, occurrenceDate);
        const result = {
          id,
          event,
          baseEvent,
          type,
          occurrenceDate,
          startDate: options.startDate || event.startDate || null,
          endDate: options.endDate || event.endDate || null,
          canEditSeries: Boolean(baseEvent && baseEvent.recurrence),
          canEditOccurrence: Boolean(baseEvent && occurrenceDate),
          searchBlob: buildSearchBlob(event, baseEvent)
        };
        result.label = buildExistingResultLabel(result);
        return result;
      }

      function buildResultId(event, type, occurrenceDate) {
        const uid = event.uid || event.name || 'event';
        const dateKey = occurrenceDate ? formatDateKey(occurrenceDate) : (event.recurrenceDateKey || event.dateKey || '');
        return `${uid}::${type}::${dateKey}`;
      }

      function buildExistingResultLabel(result) {
        const name = result.event.name || 'Untitled event';
        if (result.type === 'series') {
          const recurrenceLabel = formatRecurrenceLabel(result.event);
          return recurrenceLabel ? `${name} ‚Äî Series ¬∑ ${recurrenceLabel}` : `${name} ‚Äî Series`;
        }
        const dateLabel = result.startDate ? formatDateLabel(result.startDate, result.event.timeZone) : '';
        const timeLabel = (result.startDate && result.endDate)
          ? formatTimeRange(result.startDate, result.endDate, result.event.timeZone)
          : '';
        const detailParts = [dateLabel, timeLabel];
        if (result.type === 'override') {
          detailParts.push('Override');
        }
        const detail = detailParts.filter(Boolean).join(' ¬∑ ');
        return detail ? `${name} ‚Äî ${detail}` : name;
      }

      function handleExistingResultChange() {
        if (!dom.existingResultsSelect) return;
        const selectedIndex = parseInt(dom.existingResultsSelect.value, 10);
        if (!Number.isFinite(selectedIndex) || !existingResults[selectedIndex]) {
          selectedExistingResult = null;
          selectedExistingOccurrence = null;
          pendingExistingOccurrenceId = '';
          updateExistingModeUi(null);
          return;
        }
        const previousResultId = selectedExistingResult ? selectedExistingResult.id : '';
        selectedExistingResult = existingResults[selectedIndex];
        pendingExistingSelectionId = '';
        if (previousResultId && previousResultId !== selectedExistingResult.id) {
          selectedExistingOccurrence = null;
          pendingExistingOccurrenceId = '';
        }
        selectedExistingMode = getDefaultExistingMode(selectedExistingResult);
        updateExistingModeUi(selectedExistingResult);
        storeExistingPanelState();
      }

      function getDefaultExistingMode(result) {
        if (!result || !result.canEditSeries) return 'occurrence';
        if (result.type === 'series') return 'series';
        if (result.occurrenceDate) return 'occurrence';
        return 'series';
      }

      function setExistingMode(mode) {
        selectedExistingMode = mode === 'series' ? 'series' : 'occurrence';
        updateExistingModeUi(selectedExistingResult);
        storeExistingPanelState();
      }

      function updateExistingModeUi(result) {
        if (!dom.existingModeGroup || !dom.existingModeButtons) return;
        const shouldShow = Boolean(result && result.canEditSeries);
        dom.existingModeGroup.classList.toggle('is-hidden', !shouldShow);
        if (!shouldShow) {
          if (dom.existingOccurrenceGroup) {
            dom.existingOccurrenceGroup.classList.add('is-hidden');
          }
          resetExistingOccurrences('');
          updateExistingActionButtons();
          return;
        }
        dom.existingModeButtons.forEach(button => {
          button.classList.toggle('is-active', button.dataset.editMode === selectedExistingMode);
        });
        if (dom.existingModeHint) {
          let hint = '';
          if (selectedExistingMode === 'series') {
            hint = 'Series keeps the RRULE and original start/end.';
          } else {
            hint = 'Occurrence edits one instance (creates an override) and clears the RRULE.';
          }
          setFieldHint(dom.existingModeHint, hint, false);
        }
        refreshExistingOccurrenceOptions();
        updateExistingActionButtons();
      }

      function handleExistingOccurrenceChange() {
        if (!dom.existingOccurrenceSelect) return;
        const selectedIndex = parseInt(dom.existingOccurrenceSelect.value, 10);
        if (!Number.isFinite(selectedIndex) || !existingOccurrenceResults[selectedIndex]) {
          selectedExistingOccurrence = null;
          updateExistingActionButtons();
          return;
        }
        selectedExistingOccurrence = existingOccurrenceResults[selectedIndex];
        updateExistingActionButtons();
        storeExistingPanelState();
      }

      function refreshExistingOccurrenceOptions() {
        if (!dom.existingOccurrenceGroup || !dom.existingOccurrenceSelect) return;
        const shouldShow = Boolean(
          selectedExistingResult
          && selectedExistingResult.canEditSeries
          && selectedExistingMode === 'occurrence'
        );
        dom.existingOccurrenceGroup.classList.toggle('is-hidden', !shouldShow);
        if (!shouldShow) {
          resetExistingOccurrences('');
          return;
        }
        if (!existingCalendarIndex) {
          resetExistingOccurrences('Load a calendar to see occurrences.');
          return;
        }
        const baseEvent = selectedExistingResult.baseEvent || selectedExistingResult.event;
        if (!baseEvent || !baseEvent.recurrence) {
          resetExistingOccurrences('No recurrence rule found for this series.');
          return;
        }
        const dateValue = dom.existingDateInput ? dom.existingDateInput.value : '';
        const results = buildOccurrenceResultsForEvent(existingCalendarIndex, baseEvent, {
          dateValue,
          now: new Date(),
          maxCount: OCCURRENCE_MAX_COUNT,
          windowDays: OCCURRENCE_LOOKAHEAD_DAYS,
          includePast: Boolean(dateValue)
        });
        existingOccurrenceResults = results;
        renderExistingOccurrenceResults(results, { dateValue, baseEvent });
      }

      function renderExistingOccurrenceResults(results, options = {}) {
        if (!dom.existingOccurrenceSelect) return;
        const previousId = pendingExistingOccurrenceId
          || (selectedExistingOccurrence ? selectedExistingOccurrence.id : '');
        dom.existingOccurrenceSelect.innerHTML = '';
        if (!results.length) {
          dom.existingOccurrenceSelect.appendChild(new Option('No occurrences found', ''));
          dom.existingOccurrenceSelect.disabled = true;
          const dateValue = options.dateValue || '';
          const hint = dateValue ? 'No occurrences found on that date.' : 'No upcoming occurrences found.';
          setExistingOccurrenceHint(hint, false);
          selectedExistingOccurrence = null;
          updateExistingActionButtons();
          return;
        }
        dom.existingOccurrenceSelect.appendChild(new Option('Select an occurrence...', ''));
        results.forEach((result, index) => {
          const option = new Option(result.label, String(index));
          dom.existingOccurrenceSelect.appendChild(option);
        });
        dom.existingOccurrenceSelect.disabled = false;
        const dateValue = options.dateValue || '';
        if (dateValue) {
          const targetDate = parseDateValue(dateValue);
          const dateLabel = targetDate
            ? formatDateLabel(targetDate, options.baseEvent ? options.baseEvent.timeZone : null)
            : dateValue;
          setExistingOccurrenceHint(
            `${results.length} occurrence${results.length === 1 ? '' : 's'} found on ${dateLabel}.`,
            false
          );
        } else {
          setExistingOccurrenceHint(
            `${results.length} upcoming occurrence${results.length === 1 ? '' : 's'} found.`,
            false
          );
        }
        let matchIndex = -1;
        if (previousId) {
          matchIndex = results.findIndex(result => result.id === previousId);
        }
        if (matchIndex >= 0) {
          dom.existingOccurrenceSelect.value = String(matchIndex);
          selectedExistingOccurrence = results[matchIndex];
          pendingExistingOccurrenceId = '';
          updateExistingActionButtons();
          return;
        }
        if (results.length === 1) {
          dom.existingOccurrenceSelect.value = '0';
          selectedExistingOccurrence = results[0];
        } else {
          selectedExistingOccurrence = null;
        }
        pendingExistingOccurrenceId = '';
        updateExistingActionButtons();
      }

      function resolveExistingSelection(action = 'edit') {
        if (!selectedExistingResult) {
          return { error: 'Pick a matching event first.' };
        }
        const mode = selectedExistingMode === 'series' && selectedExistingResult.canEditSeries
          ? 'series'
          : 'occurrence';
        const baseEvent = selectedExistingResult.baseEvent || selectedExistingResult.event;
        let eventData = selectedExistingResult.event;
        let startDate = selectedExistingResult.startDate || selectedExistingResult.event.startDate;
        let endDate = selectedExistingResult.endDate || selectedExistingResult.event.endDate;
        let recurrence = '';
        let summaryResult = selectedExistingResult;
        let occurrenceId = '';

        if (mode === 'series' && baseEvent && baseEvent.recurrence) {
          eventData = baseEvent;
          startDate = baseEvent.startDate;
          endDate = baseEvent.endDate;
          recurrence = baseEvent.recurrence;
        } else if (baseEvent && baseEvent.recurrence) {
          if (!selectedExistingOccurrence) {
            const verb = action === 'copy' ? 'copy' : 'edit';
            return { error: `Pick an occurrence to ${verb}.` };
          }
          summaryResult = selectedExistingOccurrence;
          occurrenceId = selectedExistingOccurrence.id;
          eventData = selectedExistingOccurrence.type === 'override'
            ? selectedExistingOccurrence.event
            : baseEvent;
          startDate = selectedExistingOccurrence.startDate || selectedExistingOccurrence.event.startDate;
          endDate = selectedExistingOccurrence.endDate || selectedExistingOccurrence.event.endDate;
        } else {
          recurrence = eventData.recurrence || '';
        }

        if (!startDate || !endDate || !(startDate instanceof Date) || !(endDate instanceof Date)
          || Number.isNaN(startDate.getTime()) || Number.isNaN(endDate.getTime())) {
          return { error: 'Selected event is missing timing info.' };
        }

        return {
          mode,
          baseEvent,
          eventData,
          startDate,
          endDate,
          recurrence,
          summaryResult,
          occurrenceId
        };
      }

      function getExistingSelectionStatus() {
        const status = {
          canEdit: false,
          canCopy: false,
          editHint: 'Pick a matching event first.',
          copyHint: 'Pick a matching event first.'
        };
        const copySelection = resolveExistingSelection('copy');
        if (copySelection.error) {
          status.copyHint = copySelection.error;
        } else {
          status.canCopy = true;
          status.copyHint = '';
        }

        const editSelection = resolveExistingSelection('edit');
        if (editSelection.error) {
          status.editHint = editSelection.error;
          return status;
        }

        const now = new Date();
        if (editSelection.mode === 'series' && editSelection.baseEvent && editSelection.baseEvent.recurrence
          && existingCalendarIndex) {
          const futureOccurrences = buildOccurrenceResultsForEvent(existingCalendarIndex, editSelection.baseEvent, {
            now,
            maxCount: 1,
            windowDays: OCCURRENCE_LOOKAHEAD_DAYS
          });
          if (!futureOccurrences.length) {
            status.editHint = 'This series has already ended.';
            return status;
          }
        } else if (editSelection.mode !== 'series' && !isEndDateEditable(editSelection.endDate, now)) {
          status.editHint = 'Past events cannot be edited.';
          return status;
        }

        status.canEdit = true;
        status.editHint = '';
        return status;
      }

      function updateExistingActionButtons() {
        if (!dom.existingLoadButton && !dom.existingCopyButton) return;
        const status = getExistingSelectionStatus();
        if (dom.existingLoadButton) {
          dom.existingLoadButton.disabled = !status.canEdit;
          if (status.editHint) {
            dom.existingLoadButton.setAttribute('title', status.editHint);
          } else {
            dom.existingLoadButton.removeAttribute('title');
          }
        }
        if (dom.existingCopyButton) {
          dom.existingCopyButton.disabled = !status.canCopy;
          if (status.copyHint) {
            dom.existingCopyButton.setAttribute('title', status.copyHint);
          } else {
            dom.existingCopyButton.removeAttribute('title');
          }
        }
      }

      function toCopySummaryText(summaryText, fallbackName) {
        const text = String(summaryText || '').trim();
        if (text) {
          if (text.startsWith('Copied from')) return text;
          if (text.startsWith('Editing:')) {
            return text.replace(/^Editing:/, 'Copied from:');
          }
          if (text.startsWith('Editing existing event')) {
            return text.replace(/^Editing/, 'Copied from');
          }
          return `Copied from: ${text}`;
        }
        const name = normalizeText(fallbackName || '');
        return name ? `Copied from: ${name}` : 'Copied from existing event';
      }

      function copyExistingSelectionFromSummary() {
        if (!state) return;
        clearEditingState();
        setExistingSelectionSummary('', '');
        showToast('Event copied into a new draft.', 'info');
      }

      function applyExistingSelection() {
        const selection = resolveExistingSelection('edit');
        if (selection.error) {
          showToast(selection.error, 'warn');
          return;
        }
        storeExistingPanelState();

        const {
          mode,
          baseEvent,
          eventData,
          startDate,
          endDate,
          recurrence,
          summaryResult,
          occurrenceId
        } = selection;
        const now = new Date();

        if (mode === 'series' && baseEvent && baseEvent.recurrence && existingCalendarIndex) {
          const futureOccurrences = buildOccurrenceResultsForEvent(existingCalendarIndex, baseEvent, {
            now,
            maxCount: 1,
            windowDays: OCCURRENCE_LOOKAHEAD_DAYS
          });
          if (!futureOccurrences.length) {
            showToast('This series has already ended.', 'warn');
            return;
          }
        } else if (mode !== 'series' && !isEndDateEditable(endDate, now)) {
          showToast('Past events cannot be edited.', 'warn');
          return;
        }

        selectedBar = null;
        state = buildExistingState(eventData, {
          cityKey: eventData.city || state.city,
          startDate,
          endDate,
          recurrence
        });
        state.isEditingExisting = true;
        state.editingExistingId = selectedExistingResult.id;
        state.editingExistingMode = mode;
        state.editingExistingOccurrenceId = occurrenceId;
        const editingUid = (baseEvent && baseEvent.uid) || eventData.uid || '';
        let editingRecurrenceDate = null;
        let editingRecurrenceTimezone = '';
        if (mode === 'occurrence') {
          const recurrenceSource = (summaryResult && summaryResult.event && summaryResult.event.recurrenceId)
            || (summaryResult && summaryResult.startDate);
          if (recurrenceSource instanceof Date) {
            editingRecurrenceDate = new Date(recurrenceSource.getTime());
          } else if (recurrenceSource) {
            const parsed = new Date(recurrenceSource);
            if (!Number.isNaN(parsed.getTime())) {
              editingRecurrenceDate = parsed;
            }
          }
          editingRecurrenceTimezone = (summaryResult && summaryResult.event && summaryResult.event.timeZone)
            || (baseEvent && baseEvent.timeZone)
            || (eventData && eventData.timeZone)
            || state.timezone
            || browserTimezone;
        }
        state.editingExistingUid = editingUid;
        state.editingExistingRecurrenceId = editingRecurrenceDate ? formatInputValue(editingRecurrenceDate) : '';
        state.editingExistingRecurrenceTimezone = editingRecurrenceTimezone || '';
        const candidateSequence = (() => {
          const summarySeq = summaryResult && summaryResult.event ? summaryResult.event.sequence : null;
          if (Number.isFinite(summarySeq)) return summarySeq;
          if (Number.isFinite(eventData && eventData.sequence)) return eventData.sequence;
          if (Number.isFinite(baseEvent && baseEvent.sequence)) return baseEvent.sequence;
          return null;
        })();
        state.editingExistingSequence = candidateSequence !== null ? String(candidateSequence) : '';

        applyStateToForm();
        populateVenueOptions(state.city);
        updateCalendarSource();
        refreshUi();
        scheduleEventPush();
        syncExistingCitySelection();

        const summaryText = buildExistingSelectionText(summaryResult, mode, startDate, endDate, 'edit');
        setExistingSelectionSummary(summaryText, 'edit');
        showToast('Event loaded. Edit the form as usual.', 'info');
        closeExistingPanel();
      }

      function copyExistingSelection() {
        const selection = resolveExistingSelection('copy');
        if (selection.error) {
          showToast(selection.error, 'warn');
          return;
        }
        storeExistingPanelState();

        const {
          eventData,
          startDate,
          endDate,
          recurrence
        } = selection;

        selectedBar = null;
        state = buildExistingState(eventData, {
          cityKey: eventData.city || state.city,
          startDate,
          endDate,
          recurrence
        });
        clearEditingState();
        setExistingSelectionSummary('', '');

        applyStateToForm();
        populateVenueOptions(state.city);
        updateCalendarSource();
        refreshUi();
        scheduleEventPush();
        syncExistingCitySelection();

        showToast('Event copied into a new draft.', 'info');
        closeExistingPanel();
      }

      function buildExistingState(eventData, options = {}) {
        const timezone = eventData.timeZone || browserTimezone;
        const startDate = options.startDate || eventData.startDate || new Date();
        const endDate = options.endDate || eventData.endDate || new Date(startDate.getTime() + DEFAULT_DURATION_MINUTES * 60000);
        return {
          ...state,
          name: normalizeText(eventData.name || ''),
          shortName: normalizeText(eventData.shortName || eventData.shorterName || ''),
          city: options.cityKey || eventData.city || state.city,
          savedBar: normalizeText(eventData.bar || ''),
          venue: normalizeText(eventData.bar || eventData.venue || ''),
          address: normalizeText(eventData.address || ''),
          location: normalizeCoordinatesValue(eventData.coordinates || eventData.location),
          description: normalizeText(eventData.tea || eventData.description || ''),
          cover: normalizeText(eventData.cover || ''),
          start: formatInputValue(startDate),
          end: formatInputValue(endDate),
          timezone,
          recurrence: normalizeText(options.recurrence || ''),
          recurrenceMode: 'builder',
          website: normalizeText(eventData.website || ''),
          ticketUrl: normalizeText(eventData.ticketUrl || ''),
          instagram: normalizeText(eventData.instagram || ''),
          facebook: normalizeText(eventData.facebook || ''),
          gmaps: normalizeText(eventData.gmaps || ''),
          useVenueWebsite: false,
          useVenueInstagram: false,
          useVenueFacebook: false,
          image: normalizeText(eventData.image || ''),
          isEditingExisting: true
        };
      }

      function buildExistingSelectionText(result, mode, startDate, endDate, action = 'edit') {
        const rawName = (result.event.name || result.baseEvent?.name || '').trim();
        const label = action === 'copy' ? 'Copied from' : 'Editing';
        const header = rawName ? `${label}: ${rawName}` : `${label} existing event`;
        const pieces = [header];
        if (mode === 'series') {
          const recurrenceLabel = formatRecurrenceLabel(result.baseEvent || result.event);
          const detail = recurrenceLabel ? `Series ¬∑ ${recurrenceLabel}` : 'Series';
          pieces.push(`(${detail})`);
          return pieces.join(' ');
        }
        const dateLabel = startDate ? formatDateLabel(startDate, result.event.timeZone) : '';
        const timeLabel = (startDate && endDate)
          ? formatTimeRange(startDate, endDate, result.event.timeZone)
          : '';
        const detailParts = ['Occurrence', dateLabel, timeLabel];
        if (result.type === 'override') {
          detailParts.push('Override');
        }
        const detail = detailParts.filter(Boolean).join(' ¬∑ ');
        pieces.push(`(${detail})`);
        return pieces.join(' ');
      }

      function buildOccurrenceDates(baseEvent, targetDate) {
        const startBase = baseEvent.startDate instanceof Date ? baseEvent.startDate : new Date(baseEvent.startDate);
        const endBase = baseEvent.endDate instanceof Date ? baseEvent.endDate : new Date(baseEvent.endDate);
        const durationMs = startBase && endBase
          ? Math.max(1, endBase.getTime() - startBase.getTime())
          : DEFAULT_DURATION_MINUTES * 60000;
        const start = new Date(startBase);
        start.setFullYear(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate());
        const end = new Date(start.getTime() + durationMs);
        return { start, end };
      }

      function doesRecurringEventMatchDate(baseEvent, targetDate) {
        if (!baseEvent || !baseEvent.recurrence || !targetDate) return false;
        const pattern = parseRecurrencePattern(baseEvent.recurrence);
        if (!pattern || !baseEvent.startDate) return false;
        if (!(baseEvent.startDate instanceof Date) || Number.isNaN(baseEvent.startDate.getTime())) return false;
        const eventStart = parseDateValue(formatDateKey(baseEvent.startDate));
        if (!eventStart || targetDate < eventStart) return false;
        const interval = pattern.interval || 1;
        switch (pattern.frequency) {
          case 'DAILY': {
            const diffDays = Math.floor((targetDate - eventStart) / 86400000);
            return diffDays % interval === 0;
          }
          case 'WEEKLY': {
            const diffDays = Math.floor((targetDate - eventStart) / 86400000);
            const diffWeeks = Math.floor(diffDays / 7);
            if (diffWeeks % interval !== 0) return false;
            const dayCodes = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
            const byDay = (pattern.byDay && pattern.byDay.length)
              ? pattern.byDay
              : [dayCodes[baseEvent.startDate.getDay()]];
            return byDay.some(code => getDayIndexFromCode(code) === targetDate.getDay());
          }
          case 'MONTHLY': {
            const monthDiff = (targetDate.getFullYear() - eventStart.getFullYear()) * 12
              + (targetDate.getMonth() - eventStart.getMonth());
            if (monthDiff % interval !== 0) return false;
            if (pattern.byMonthDay && pattern.byMonthDay.length) {
              return pattern.byMonthDay.includes(targetDate.getDate());
            }
            if (pattern.byDay && pattern.byDay.length) {
              return pattern.byDay.some(code => matchesMonthlyByDay(code, targetDate));
            }
            return targetDate.getDate() === eventStart.getDate();
          }
          default:
            return false;
        }
      }

      function parseDateValue(value) {
        if (!value) return null;
        const parts = value.split('-').map(Number);
        if (parts.length < 3 || !parts[0] || !parts[1] || !parts[2]) return null;
        return new Date(parts[0], parts[1] - 1, parts[2]);
      }

      function parseRecurrencePattern(recurrence) {
        if (!recurrence) return null;
        if (calendarCore && typeof calendarCore.parseRecurrencePattern === 'function') {
          return calendarCore.parseRecurrencePattern(recurrence);
        }
        const rules = {};
        recurrence.split(';').forEach(rule => {
          const [key, value] = rule.split('=');
          rules[key] = value;
        });
        return {
          frequency: rules.FREQ || null,
          interval: parseInt(rules.INTERVAL, 10) || 1,
          byDay: rules.BYDAY ? rules.BYDAY.split(',') : null,
          byMonthDay: rules.BYMONTHDAY ? rules.BYMONTHDAY.split(',').map(day => parseInt(day, 10)) : null
        };
      }

      function getDayIndexFromCode(code) {
        if (calendarCore && typeof calendarCore.getDayIndexFromCode === 'function') {
          return calendarCore.getDayIndexFromCode(code);
        }
        const dayMap = { SU: 0, MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6 };
        const dayPart = String(code || '').replace(/^-?\d+/, '');
        return dayMap[dayPart] ?? -1;
      }

      function getOccurrenceFromDayCode(code) {
        if (calendarCore && typeof calendarCore.getOccurrenceFromDayCode === 'function') {
          return calendarCore.getOccurrenceFromDayCode(code);
        }
        const match = String(code || '').match(/^(-?\d+)([A-Z]{2})$/);
        return match ? parseInt(match[1], 10) : 0;
      }

      function matchesMonthlyByDay(code, date) {
        const dayIndex = getDayIndexFromCode(code);
        if (dayIndex !== date.getDay()) return false;
        const occurrence = getOccurrenceFromDayCode(code);
        if (!occurrence) return true;
        const year = date.getFullYear();
        const month = date.getMonth();
        if (occurrence > 0) {
          const firstOfMonth = new Date(year, month, 1);
          const firstDayIndex = firstOfMonth.getDay();
          const offset = (dayIndex - firstDayIndex + 7) % 7;
          const targetDate = 1 + offset + (occurrence - 1) * 7;
          return date.getDate() === targetDate;
        }
        const lastOfMonth = new Date(year, month + 1, 0);
        const lastDayIndex = lastOfMonth.getDay();
        const offset = (lastDayIndex - dayIndex + 7) % 7;
        const lastOccurrence = lastOfMonth.getDate() - offset;
        const targetDate = lastOccurrence + (occurrence + 1) * 7;
        return date.getDate() === targetDate;
      }

      function formatDateKey(date) {
        if (!date || !(date instanceof Date) || Number.isNaN(date.getTime())) return '';
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }

      function formatDateLabel(date, timeZone) {
        if (!date || !(date instanceof Date)) return '';
        try {
          return new Intl.DateTimeFormat('en-US', {
            month: 'short',
            day: 'numeric',
            year: 'numeric',
            timeZone: timeZone || browserTimezone
          }).format(date);
        } catch (error) {
          return date.toLocaleDateString('en-US');
        }
      }

      function formatRecurrenceLabel(eventData) {
        if (!eventData || !eventData.recurrence) return '';
        if (calendarCore && typeof calendarCore.getRecurrenceDescription === 'function') {
          return calendarCore.getRecurrenceDescription(eventData.recurrence, eventData.startDate);
        }
        return eventData.recurrence;
      }

      function updateExistingSelectionSummary(text) {
        if (!dom.existingSelectionSummary || !dom.existingSelectionText) return;
        if (!text) {
          dom.existingSelectionSummary.classList.add('is-hidden');
          dom.existingSelectionText.textContent = '';
          return;
        }
        dom.existingSelectionSummary.classList.remove('is-hidden');
        dom.existingSelectionText.textContent = text;
      }

      function setExistingSelectionSummary(text, action = '') {
        if (state) {
          state.existingSelectionSummary = text || '';
          state.existingSelectionAction = action || '';
        }
        updateExistingSelectionSummary(text);
        if (state) {
          scheduleUrlUpdate();
        }
      }

      function syncExistingSelectionSummaryFromState() {
        if (!state) {
          updateExistingSelectionSummary('');
          return;
        }
        if (state.existingSelectionSummary) {
          updateExistingSelectionSummary(state.existingSelectionSummary);
          return;
        }
        if (!state.isEditingExisting) {
          updateExistingSelectionSummary('');
          return;
        }
        const name = normalizeText(state.name || '');
        const modeLabel = state.editingExistingMode === 'series'
          ? 'Series'
          : (state.editingExistingMode === 'occurrence' ? 'Occurrence' : '');
        const suffix = modeLabel ? ` (${modeLabel})` : '';
        const summary = name ? `Editing: ${name}${suffix}` : `Editing existing event${suffix}`;
        state.existingSelectionSummary = summary;
        state.existingSelectionAction = 'edit';
        updateExistingSelectionSummary(summary);
      }

      function setExistingPanelExpanded(isOpen) {
        if (!dom.editExistingButton) return;
        dom.editExistingButton.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
      }

      function openExistingPanel(options = {}) {
        if (!dom.existingPanel) return;
        if (!dom.existingPanel.open) {
          if (typeof dom.existingPanel.showModal === 'function') {
            dom.existingPanel.showModal();
          } else {
            dom.existingPanel.setAttribute('open', '');
          }
        }
        setExistingPanelExpanded(true);
        if (options.focusSearch && dom.existingSearchInput) {
          requestAnimationFrame(() => {
            dom.existingSearchInput.focus();
          });
        }
        if (state && state.isEditingExisting) {
          queueExistingSelectionFromState({ force: true });
        } else if (!restoreExistingPanelState()) {
          scheduleExistingResultsUpdate();
        }
      }

      function closeExistingPanel() {
        if (!dom.existingPanel || !dom.existingPanel.open) return;
        if (typeof dom.existingPanel.close === 'function') {
          dom.existingPanel.close();
        } else {
          dom.existingPanel.removeAttribute('open');
        }
        setExistingPanelExpanded(false);
      }

      function clearEditingState() {
        if (!state) return;
        state.isEditingExisting = false;
        state.editingExistingId = '';
        state.editingExistingMode = 'occurrence';
        state.editingExistingOccurrenceId = '';
        state.editingExistingUid = '';
        state.editingExistingRecurrenceId = '';
        state.editingExistingRecurrenceTimezone = '';
        state.editingExistingSequence = '';
      }

      function clearExistingSelection(options = {}) {
        const { resetInputs = false } = options;
        selectedExistingResult = null;
        selectedExistingOccurrence = null;
        pendingExistingOccurrenceId = '';
        updateExistingModeUi(null);
        setExistingSelectionSummary('', '');
        if (state) {
          clearEditingState();
          scheduleUrlUpdate();
        }
        if (resetInputs) {
          if (dom.existingSearchInput) dom.existingSearchInput.value = '';
          if (dom.existingDateInput) dom.existingDateInput.value = '';
          if (dom.existingResultsSelect) dom.existingResultsSelect.value = '';
          scheduleExistingResultsUpdate();
        }
        storeExistingPanelState();
      }

      function setVenueSelectHint(message) {
        if (!dom.venueSelectHint) return;
        setFieldHint(dom.venueSelectHint, message, false);
      }

      function createDefaultState() {
        const defaultCity = 'nyc';
        const start = computeDefaultStart();
        const end = new Date(start.getTime() + DEFAULT_DURATION_MINUTES * 60000);
        return {
          name: 'Bearracuda Preview Night',
          shortName: 'Bearracuda',
          city: defaultCity,
          savedBar: '',
          venue: 'The Eagle NYC',
          address: '554 W 28th St, New York, NY',
          location: '',
          description: 'Preview your chunky.dad event before it goes live.',
          cover: '',
          start: formatInputValue(start),
          end: formatInputValue(end),
          timezone: browserTimezone,
          debug: false,
          recurrence: '',
          recurrenceMode: 'builder',
          website: '',
          ticketUrl: '',
          instagram: '',
          facebook: '',
          gmaps: '',
          useVenueWebsite: false,
          useVenueInstagram: false,
          useVenueFacebook: false,
          image: '',
          isEditingExisting: false,
          editingExistingId: '',
          editingExistingMode: 'occurrence',
          editingExistingOccurrenceId: '',
          editingExistingUid: '',
          editingExistingRecurrenceId: '',
          editingExistingRecurrenceTimezone: '',
          editingExistingSequence: '',
          existingSelectionSummary: '',
          existingSelectionAction: ''
        };
      }

      function computeDefaultStart() {
        const now = new Date();
        const start = new Date(now);
        const day = start.getDay();
        const daysUntilFriday = ((5 - day + 7) % 7) || 7;
        start.setDate(start.getDate() + daysUntilFriday);
        start.setHours(21, 0, 0, 0);
        return start;
      }

      function parseBooleanParam(value) {
        if (value == null) return false;
        const normalized = String(value).trim().toLowerCase();
        return normalized === '1' || normalized === 'true' || normalized === 'yes' || normalized === 'on';
      }

      function loadStateFromUrl(baseState) {
        const params = new URLSearchParams(window.location.search);
        const overrides = {};
        let sawEditFlag = false;
        params.forEach((value, key) => {
          if (value == null || value === '') return;
          switch (key) {
            case 'name':
              overrides.name = value;
              break;
            case 'short':
              overrides.shortName = value;
              break;
            case 'city':
              overrides.city = value;
              break;
            case 'bar':
            case 'savedbar':
              overrides.savedBar = value;
              break;
            case 'venue':
              overrides.venue = value;
              break;
            case 'addr':
              overrides.address = value;
              break;
            case 'coords':
            case 'loc':
            case 'location':
              overrides.location = value;
              break;
            case 'desc':
              overrides.description = value;
              break;
            case 'cover':
              overrides.cover = value;
              break;
            case 'start': {
              const sanitized = sanitizeDateTimeInput(value);
              if (sanitized) overrides.start = sanitized;
              break;
            }
            case 'end': {
              const sanitizedEnd = sanitizeDateTimeInput(value);
              if (sanitizedEnd) overrides.end = sanitizedEnd;
              break;
            }
            case 'rrule':
              overrides.recurrence = value;
              break;
            case 'web':
              overrides.website = value;
              break;
            case 'tickets':
            case 'ticket':
              overrides.ticketUrl = value;
              break;
            case 'insta':
            case 'instagram':
              overrides.instagram = value;
              break;
            case 'fb':
            case 'facebook':
              overrides.facebook = value;
              break;
            case 'gmaps':
            case 'map':
              overrides.gmaps = value;
              break;
            case 'vweb':
            case 'usevenuewebsite':
              overrides.useVenueWebsite = parseBooleanParam(value);
              break;
            case 'vinsta':
            case 'usevenueinstagram':
              overrides.useVenueInstagram = parseBooleanParam(value);
              break;
            case 'vfb':
            case 'usevenuefacebook':
              overrides.useVenueFacebook = parseBooleanParam(value);
              break;
            case 'img':
              overrides.image = value;
              break;
            case 'esummary':
            case 'esum':
              overrides.existingSelectionSummary = value;
              break;
            case 'eaction': {
              const normalized = String(value).trim().toLowerCase();
              overrides.existingSelectionAction = normalized === 'copy'
                ? 'copy'
                : (normalized === 'edit' ? 'edit' : '');
              break;
            }
            case 'edit':
            case 'editing':
              overrides.isEditingExisting = parseBooleanParam(value);
              sawEditFlag = true;
              break;
            case 'editid':
            case 'eid':
              overrides.editingExistingId = value;
              break;
            case 'euid':
              overrides.editingExistingUid = value;
              break;
            case 'occid':
            case 'eocc':
            case 'editocc':
              overrides.editingExistingOccurrenceId = value;
              break;
            case 'erid':
              overrides.editingExistingRecurrenceId = value;
              break;
            case 'ertz':
              overrides.editingExistingRecurrenceTimezone = value;
              break;
            case 'editmode':
            case 'emode':
              overrides.editingExistingMode = value === 'series' ? 'series' : 'occurrence';
              break;
            case 'rmode':
            case 'recurrencemode':
              overrides.recurrenceMode = value === 'raw' ? 'raw' : 'builder';
              break;
            case 'debug':
            case 'dbg':
              overrides.debug = parseBooleanParam(value);
              break;
            default:
              break;
          }
        });
        if (!sawEditFlag && (overrides.editingExistingId
          || overrides.editingExistingMode
          || overrides.editingExistingOccurrenceId
          || overrides.editingExistingUid
          || overrides.editingExistingRecurrenceId
          || overrides.editingExistingRecurrenceTimezone)) {
          overrides.isEditingExisting = true;
        }
        if (overrides.existingSelectionAction === 'copy') {
          overrides.isEditingExisting = false;
          overrides.editingExistingId = '';
          overrides.editingExistingMode = baseState.editingExistingMode || 'occurrence';
          overrides.editingExistingOccurrenceId = '';
          overrides.editingExistingUid = '';
          overrides.editingExistingRecurrenceId = '';
          overrides.editingExistingRecurrenceTimezone = '';
        }
        if (overrides.isEditingExisting) {
          if (!overrides.editingExistingMode) {
            overrides.editingExistingMode = baseState.editingExistingMode || 'occurrence';
          }
          if (!overrides.editingExistingOccurrenceId) {
            overrides.editingExistingOccurrenceId = '';
          }
        } else if (overrides.isEditingExisting === false) {
          overrides.editingExistingId = '';
          overrides.editingExistingMode = baseState.editingExistingMode || 'occurrence';
          overrides.editingExistingOccurrenceId = '';
          overrides.editingExistingUid = '';
          overrides.editingExistingRecurrenceId = '';
          overrides.editingExistingRecurrenceTimezone = '';
        }
        if (!overrides.start) overrides.start = baseState.start;
        if (!overrides.end) overrides.end = baseState.end;
        if (!overrides.city) overrides.city = baseState.city;
        if (!overrides.recurrenceMode) overrides.recurrenceMode = baseState.recurrenceMode;
        return { overrides };
      }

      function applyStateToForm() {
        if (dom.nameInput) dom.nameInput.value = state.name || '';
        if (dom.shortNameInput) dom.shortNameInput.value = state.shortName || '';
        if (dom.citySelect) {
          if (![...dom.citySelect.options].some(option => option.value === state.city)) {
            state.city = dom.citySelect.options.length ? dom.citySelect.options[0].value : 'nyc';
          }
          dom.citySelect.value = state.city;
        }
        if (dom.venueInput) dom.venueInput.value = state.venue || '';
        if (dom.addressInput) dom.addressInput.value = state.address || '';
        if (dom.coordinatesInput) dom.coordinatesInput.value = state.location || '';
        if (dom.descriptionInput) dom.descriptionInput.value = state.description || '';
        if (dom.coverInput) dom.coverInput.value = state.cover || '';
        if (dom.startInput) dom.startInput.value = state.start || '';
        if (dom.endInput) dom.endInput.value = state.end || '';
        if (dom.recurrenceInput) dom.recurrenceInput.value = state.recurrence || '';
        if (dom.websiteInput) dom.websiteInput.value = state.website || '';
        if (dom.ticketUrlInput) dom.ticketUrlInput.value = state.ticketUrl || '';
        if (dom.instagramInput) dom.instagramInput.value = state.instagram || '';
        if (dom.facebookInput) dom.facebookInput.value = state.facebook || '';
        if (dom.gmapsInput) dom.gmapsInput.value = state.gmaps || '';
        if (dom.imageInput) dom.imageInput.value = state.image || '';
        updateTimeNotes();
        applyRecurrenceStateToForm();
        syncLinkFieldStates();
        updateCoordinatesFieldState();
        updateVenueLinkToggles({ applyValues: false, preserveState: true });
      }

      function bindEvents() {
        if (dom.form) {
          dom.form.addEventListener('submit', event => event.preventDefault());
        }
        if (dom.nameInput) {
          dom.nameInput.addEventListener('input', event => {
            state.name = event.target.value;
            refreshUi();
          });
        }
        if (dom.shortNameInput) {
          dom.shortNameInput.addEventListener('input', event => {
            state.shortName = event.target.value;
            refreshUi();
          });
        }
        if (dom.citySelect) {
          dom.citySelect.addEventListener('change', event => {
            const newCity = event.target.value;
            state.city = newCity;
            state.savedBar = '';
            selectedBar = null;
            populateVenueOptions(newCity);
            updateCalendarSource();
            syncExistingCitySelection({ refresh: dom.existingPanel && dom.existingPanel.open });
            refreshUi();
          });
        }
        if (dom.venueSelect) {
          dom.venueSelect.addEventListener('change', event => {
            const selectedIndex = parseInt(event.target.value, 10);
            if (!Number.isFinite(selectedIndex) || !currentBars[selectedIndex]) {
              selectedBar = null;
              state.savedBar = '';
              updateVenueLinkToggles({ applyValues: false });
              refreshUi();
              return;
            }
            selectedBar = currentBars[selectedIndex];
            state.savedBar = normalizeText(selectedBar.name);
            applyBarDetails(selectedBar);
            updateVenueLinkToggles({ applyValues: true });
            refreshUi();
          });
        }
        if (dom.venueLinkToggles && dom.venueLinkToggles.length) {
          dom.venueLinkToggles.forEach(toggle => {
            toggle.addEventListener('change', () => {
              handleVenueToggleChange(toggle);
            });
          });
        }
        if (dom.pasteButtons && dom.pasteButtons.length) {
          dom.pasteButtons.forEach(button => {
            const triggerPaste = event => {
              if (event) {
                event.preventDefault();
                event.stopPropagation();
              }
              triggerPasteAction(button);
            };
            button.addEventListener('click', triggerPaste);
            button.addEventListener('keydown', event => {
              if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                triggerPaste(event);
              }
            });
            button.addEventListener('contextmenu', event => {
              event.preventDefault();
            });
          });
        }
        if (dom.venueInput) {
          dom.venueInput.addEventListener('input', event => {
            state.venue = event.target.value;
            refreshUi();
          });
        }
        if (dom.addressInput) {
          dom.addressInput.addEventListener('input', event => {
            state.address = event.target.value;
            refreshUi();
          });
        }
        if (dom.coordinatesInput) {
          dom.coordinatesInput.addEventListener('input', event => {
            state.location = event.target.value;
            updateCoordinatesFieldState();
            refreshUi();
          });
        }
        if (dom.descriptionInput) {
          dom.descriptionInput.addEventListener('input', event => {
            state.description = event.target.value;
            refreshUi();
          });
        }
        if (dom.coverInput) {
          dom.coverInput.addEventListener('input', event => {
            state.cover = event.target.value;
            refreshUi();
          });
        }
        if (dom.startInput) {
          const handler = event => {
            const sanitized = sanitizeDateTimeInput(event.target.value);
            if (!sanitized) {
              event.target.value = state.start;
              return;
            }
            state.start = sanitized;
            refreshUi();
          };
          dom.startInput.addEventListener('change', handler);
          dom.startInput.addEventListener('input', handler);
        }
        if (dom.endInput) {
          const handler = event => {
            const sanitized = sanitizeDateTimeInput(event.target.value);
            if (!sanitized) {
              event.target.value = state.end;
              return;
            }
            state.end = sanitized;
            refreshUi();
          };
          dom.endInput.addEventListener('change', handler);
          dom.endInput.addEventListener('input', handler);
        }
        if (dom.recurrenceInput) {
          dom.recurrenceInput.addEventListener('input', event => {
            state.recurrence = event.target.value.trim();
            updateRecurrenceSummary();
            refreshUi();
          });
        }
        if (dom.recurrenceModeButtons && dom.recurrenceModeButtons.length) {
          dom.recurrenceModeButtons.forEach(button => {
            button.addEventListener('click', () => {
              const mode = button.dataset.recurrenceMode;
              if (mode) {
                setRecurrenceMode(mode);
              }
            });
          });
        }
        if (dom.recurrenceFrequency) {
          dom.recurrenceFrequency.addEventListener('change', () => {
            handleRecurrenceBuilderChange();
          });
        }
        if (dom.recurrenceInterval) {
          dom.recurrenceInterval.addEventListener('input', () => {
            handleRecurrenceBuilderChange();
          });
        }
        if (dom.recurrenceWeekdayButtons && dom.recurrenceWeekdayButtons.length) {
          dom.recurrenceWeekdayButtons.forEach(button => {
            button.addEventListener('click', () => {
              toggleRecurrenceDay(button);
              handleRecurrenceBuilderChange();
            });
          });
        }
        if (dom.recurrenceMonthlyMode && dom.recurrenceMonthlyMode.length) {
          dom.recurrenceMonthlyMode.forEach(input => {
            input.addEventListener('change', () => {
              handleRecurrenceBuilderChange();
            });
          });
        }
        if (dom.recurrenceMonthday) {
          dom.recurrenceMonthday.addEventListener('input', () => {
            handleRecurrenceBuilderChange();
          });
        }
        if (dom.recurrenceWeekPos) {
          dom.recurrenceWeekPos.addEventListener('change', () => {
            handleRecurrenceBuilderChange();
          });
        }
        if (dom.recurrenceWeekday) {
          dom.recurrenceWeekday.addEventListener('change', () => {
            handleRecurrenceBuilderChange();
          });
        }
        if (dom.recurrenceEnds) {
          dom.recurrenceEnds.addEventListener('change', () => {
            updateRecurrenceUi();
            handleRecurrenceBuilderChange();
          });
        }
        if (dom.recurrenceCount) {
          dom.recurrenceCount.addEventListener('input', () => {
            handleRecurrenceBuilderChange();
          });
        }
        if (dom.recurrenceUntil) {
          dom.recurrenceUntil.addEventListener('input', () => {
            handleRecurrenceBuilderChange();
          });
        }
        bindLinkField(dom.websiteInput, 'website', 'website');
        bindLinkField(dom.ticketUrlInput, 'ticketUrl', 'tickets');
        bindLinkField(dom.instagramInput, 'instagram', 'instagram');
        bindLinkField(dom.facebookInput, 'facebook', 'facebook');
        bindLinkField(dom.gmapsInput, 'gmaps', 'gmaps');
        if (dom.imageInput) {
          dom.imageInput.addEventListener('input', event => {
            state.image = event.target.value;
            refreshUi();
          });
        }
        if (dom.resetButton) {
          dom.resetButton.addEventListener('click', resetForm);
        }
        if (dom.copyShareButton) {
          dom.copyShareButton.addEventListener('click', () => {
            openTellDadEmail(dom.copyShareButton);
          });
        }
        if (dom.addToCalendarButton) {
          dom.addToCalendarButton.addEventListener('click', handleAddToCalendar);
        }
        if (dom.openScriptableButton) {
          dom.openScriptableButton.addEventListener('click', () => {
            handleOpenScriptable(dom.openScriptableButton);
          });
        }
        if (dom.editExistingButton) {
          dom.editExistingButton.addEventListener('click', () => {
            if (dom.existingPanel && dom.existingPanel.open) {
              closeExistingPanel();
              return;
            }
            openExistingPanel({ focusSearch: true });
          });
        }
        if (dom.existingPanel) {
          dom.existingPanel.addEventListener('close', () => {
            setExistingPanelExpanded(false);
          });
          dom.existingPanel.addEventListener('click', event => {
            if (event.target === dom.existingPanel) {
              closeExistingPanel();
            }
          });
        }
        if (dom.existingModalClose) {
          dom.existingModalClose.addEventListener('click', closeExistingPanel);
        }
        if (dom.existingCitySelect) {
          dom.existingCitySelect.addEventListener('change', () => {
            storeExistingPanelState();
            scheduleExistingResultsUpdate();
          });
        }
        if (dom.existingSearchInput) {
          dom.existingSearchInput.addEventListener('input', () => {
            storeExistingPanelState();
            scheduleExistingResultsUpdate();
          });
        }
        if (dom.existingDateInput) {
          dom.existingDateInput.addEventListener('input', () => {
            storeExistingPanelState();
            scheduleExistingResultsUpdate();
          });
          dom.existingDateInput.addEventListener('change', () => {
            storeExistingPanelState();
            scheduleExistingResultsUpdate();
          });
        }
        if (dom.existingResultsSelect) {
          dom.existingResultsSelect.addEventListener('change', handleExistingResultChange);
        }
        if (dom.existingOccurrenceSelect) {
          dom.existingOccurrenceSelect.addEventListener('change', handleExistingOccurrenceChange);
        }
        if (dom.existingModeButtons && dom.existingModeButtons.length) {
          dom.existingModeButtons.forEach(button => {
            button.addEventListener('click', () => {
              const mode = button.dataset.editMode || 'occurrence';
              setExistingMode(mode);
            });
          });
        }
        if (dom.existingLoadButton) {
          dom.existingLoadButton.addEventListener('click', applyExistingSelection);
        }
        if (dom.existingCopyButton) {
          dom.existingCopyButton.addEventListener('click', copyExistingSelection);
        }
        if (dom.existingClearButton) {
          dom.existingClearButton.addEventListener('click', () => {
            clearExistingSelection({ resetInputs: true });
          });
        }
        if (dom.existingChangeButton) {
          dom.existingChangeButton.addEventListener('click', () => {
            openExistingPanel({ focusSearch: true });
          });
        }
        if (dom.existingCopySummaryButton) {
          dom.existingCopySummaryButton.addEventListener('click', copyExistingSelectionFromSummary);
        }
        if (dom.existingClearSummaryButton) {
          dom.existingClearSummaryButton.addEventListener('click', () => {
            clearExistingSelection({ resetInputs: false });
          });
        }
      }

      function bindLinkField(input, stateKey, linkType) {
        if (!input) return;
        const handleInput = () => {
          const result = normalizeLinkValue(linkType, input.value);
          state[stateKey] = result.value;
          updateLinkFieldState(input, result);
          refreshUi();
        };
        input.addEventListener('input', handleInput);
        input.addEventListener('blur', () => {
          const result = normalizeLinkValue(linkType, input.value);
          state[stateKey] = result.value;
          updateLinkFieldState(input, result);
          if (result.value && input.value.trim() !== result.value) {
            input.value = result.value;
          }
          refreshUi();
        });
      }

      function normalizeStateLinks() {
        state.website = normalizeLinkValue('website', state.website).value;
        state.ticketUrl = normalizeLinkValue('tickets', state.ticketUrl).value;
        state.instagram = normalizeLinkValue('instagram', state.instagram).value;
        state.facebook = normalizeLinkValue('facebook', state.facebook).value;
        state.gmaps = normalizeLinkValue('gmaps', state.gmaps).value;
      }

      function normalizeLinkValue(type, rawValue) {
        const trimmed = String(rawValue || '').trim();
        if (!trimmed) {
          return { value: '', error: '' };
        }
        switch (type) {
          case 'instagram':
            return normalizeInstagramLink(trimmed);
          case 'facebook':
            return normalizeFacebookLink(trimmed);
          default:
            return normalizeUrlLink(trimmed);
        }
      }

      function normalizeUrlLink(value) {
        const normalized = addProtocolIfMissing(value);
        try {
          const url = new URL(normalized);
          if (!['http:', 'https:'].includes(url.protocol)) {
            return { value: '', error: 'Use an http(s) link.' };
          }
          return { value: url.toString(), error: '' };
        } catch (error) {
          return { value: '', error: 'Enter a valid URL.' };
        }
      }

      function normalizeInstagramLink(value) {
        const hasDomain = /instagram\.com|instagr\.am/i.test(value);
        const hasProtocol = /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(value);
        if (hasDomain || hasProtocol) {
          if (!hasDomain) {
            return { value: '', error: 'Use an Instagram link or handle.' };
          }
          return normalizeUrlLink(addProtocolIfMissing(value));
        }
        let handle = value.replace(/^@/, '').trim();
        handle = handle.split(/[/?#]/)[0];
        if (!handle) {
          return { value: '', error: 'Instagram handle is missing.' };
        }
        if (!/^[A-Za-z0-9._]+$/.test(handle)) {
          return { value: '', error: 'Use letters, numbers, periods, or underscores.' };
        }
        return { value: `https://www.instagram.com/${handle}`, error: '' };
      }

      function normalizeFacebookLink(value) {
        const hasDomain = /facebook\.com|fb\.com|fb\.me/i.test(value);
        const hasProtocol = /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(value);
        if (hasDomain || hasProtocol) {
          if (!hasDomain) {
            return { value: '', error: 'Use a Facebook link or handle.' };
          }
          return normalizeUrlLink(addProtocolIfMissing(value));
        }
        let handle = value.replace(/^@/, '').trim();
        handle = handle.split(/[/?#]/)[0];
        if (!handle) {
          return { value: '', error: 'Facebook handle is missing.' };
        }
        if (!/^[A-Za-z0-9.-]+$/.test(handle)) {
          return { value: '', error: 'Use letters, numbers, periods, or dashes.' };
        }
        return { value: `https://www.facebook.com/${handle}`, error: '' };
      }

      function addProtocolIfMissing(value) {
        const trimmed = value.trim();
        if (/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(trimmed)) {
          return trimmed;
        }
        if (trimmed.startsWith('//')) {
          return `https:${trimmed}`;
        }
        return `https://${trimmed}`;
      }

      function updateLinkFieldState(input, result) {
        if (!input) return;
        const hasError = Boolean(result.error);
        input.classList.toggle('is-invalid', hasError);
        if (hasError) {
          input.setAttribute('aria-invalid', 'true');
        } else {
          input.removeAttribute('aria-invalid');
        }
        const hint = getFieldHint(input);
        setFieldHint(hint, hasError ? result.error : '', hasError);
      }

      function getFieldHint(input) {
        const group = input ? input.closest('.field-group') : null;
        if (!group) return null;
        return group.querySelector('.field-hint');
      }

      function setFieldHint(hint, message, isError) {
        if (!hint) return;
        if (!Object.prototype.hasOwnProperty.call(hint.dataset, 'default')) {
          hint.dataset.default = hint.textContent || '';
        }
        if (message) {
          hint.textContent = message;
          hint.classList.toggle('is-error', Boolean(isError));
        } else {
          hint.textContent = hint.dataset.default || '';
          hint.classList.remove('is-error');
        }
      }

      function syncLinkFieldStates() {
        updateLinkFieldState(dom.websiteInput, normalizeLinkValue('website', dom.websiteInput ? dom.websiteInput.value : ''));
        updateLinkFieldState(dom.ticketUrlInput, normalizeLinkValue('tickets', dom.ticketUrlInput ? dom.ticketUrlInput.value : ''));
        updateLinkFieldState(dom.instagramInput, normalizeLinkValue('instagram', dom.instagramInput ? dom.instagramInput.value : ''));
        updateLinkFieldState(dom.facebookInput, normalizeLinkValue('facebook', dom.facebookInput ? dom.facebookInput.value : ''));
        updateLinkFieldState(dom.gmapsInput, normalizeLinkValue('gmaps', dom.gmapsInput ? dom.gmapsInput.value : ''));
      }

      function applyBarDetails(bar, options = {}) {
        if (!bar || typeof bar !== 'object') return;
        const { preserveExisting = false } = options;
        const venueName = normalizeText(bar.name);
        if (venueName && (!preserveExisting || !state.venue)) {
          state.venue = venueName;
          if (dom.venueInput) dom.venueInput.value = venueName;
        }
        const address = normalizeText(bar.address);
        if (address && (!preserveExisting || !state.address)) {
          state.address = address;
          if (dom.addressInput) dom.addressInput.value = address;
        }
        const coordinates = normalizeCoordinatesValue(bar.coordinates || bar.location);
        if (coordinates && (!preserveExisting || !state.location)) {
          state.location = coordinates;
          if (dom.coordinatesInput) dom.coordinatesInput.value = coordinates;
        }
        if (!preserveExisting || !state.gmaps) {
          applyBarLink(dom.gmapsInput, 'gmaps', 'gmaps', bar.googleMaps || bar.gmaps);
        }
        updateCoordinatesFieldState();
      }

      function updateVenueLinkToggles(options = {}) {
        const { applyValues = false, preserveState = false } = options;
        if (!dom.venueLinkToggles || !dom.venueLinkToggles.length) return;
        dom.venueLinkToggles.forEach(toggle => {
          const linkType = toggle.dataset.venueToggle;
          const stateKey = getVenueToggleStateKey(linkType);
          if (!stateKey) return;
          const barValue = selectedBar ? normalizeText(getBarLinkValue(linkType, selectedBar)) : '';
          const hasValue = Boolean(barValue);
          if (!hasValue && !preserveState) {
            state[stateKey] = false;
          }
          const toggleLabel = toggle.closest('.field-toggle');
          if (toggleLabel) {
            toggleLabel.classList.toggle('is-hidden', !hasValue);
          }
          const isActive = Boolean(state[stateKey]) && hasValue;
          toggle.checked = isActive;
          toggle.disabled = !hasValue;
          toggle.setAttribute('aria-disabled', hasValue ? 'false' : 'true');
          if (applyValues && isActive) {
            const target = getVenueLinkTarget(linkType);
            if (target) {
              applyBarLink(target.input, target.stateKey, target.linkType, barValue);
            }
          }
        });
      }

      function assumeVenueLinkTogglesFromState(bar) {
        if (!state || !bar) return;
        ['website', 'instagram', 'facebook'].forEach(linkType => {
          const toggleStateKey = getVenueToggleStateKey(linkType);
          const target = getVenueLinkTarget(linkType);
          if (!toggleStateKey || !target) return;
          if (state[toggleStateKey]) return;
          const stateValue = normalizeLinkValue(linkType, state[target.stateKey]).value;
          const barValue = normalizeLinkValue(linkType, getBarLinkValue(linkType, bar)).value;
          if (!stateValue || !barValue) return;
          if (normalizeComparableUrl(stateValue) === normalizeComparableUrl(barValue)) {
            state[toggleStateKey] = true;
          }
        });
      }

      function normalizeComparableUrl(value) {
        if (!value) return '';
        try {
          const url = new URL(value);
          const host = url.hostname.replace(/^www\./i, '').toLowerCase();
          const path = url.pathname.replace(/\/+$/, '').toLowerCase();
          const query = url.search ? `?${url.searchParams.toString()}` : '';
          return `${host}${path}${query}`;
        } catch (error) {
          return value.trim().toLowerCase();
        }
      }

      function handleVenueToggleChange(toggle) {
        if (!toggle) return;
        const linkType = toggle.dataset.venueToggle;
        const stateKey = getVenueToggleStateKey(linkType);
        if (!stateKey) return;
        state[stateKey] = toggle.checked;
        updateVenueLinkToggles({ applyValues: toggle.checked });
        refreshUi();
      }

      function getVenueToggleStateKey(linkType) {
        switch (linkType) {
          case 'website':
            return 'useVenueWebsite';
          case 'instagram':
            return 'useVenueInstagram';
          case 'facebook':
            return 'useVenueFacebook';
          default:
            return '';
        }
      }

      function triggerPasteAction(button) {
        const now = Date.now();
        if (now - lastPasteActionAt < 350) return;
        lastPasteActionAt = now;
        handlePasteAction(button);
      }

      async function handlePasteAction(button) {
        if (!button) return;
        const targetId = button.dataset.pasteTarget;
        if (!targetId) return;
        const input = document.getElementById(targetId);
        if (!input) return;

        // Don't blur active element as it causes UI jumps on mobile
        // and can interfere with clipboard operations

        const isSecure = typeof window.isSecureContext === 'boolean' ? window.isSecureContext : true;
        if (!isSecure) {
          showToast('Clipboard needs HTTPS/localhost. Paste manually.', 'warn');
          return;
        }
        if (!navigator.clipboard || !navigator.clipboard.readText) {
          showToast('Clipboard blocked. Paste manually.', 'warn');
          return;
        }
        try {
          const text = await navigator.clipboard.readText();
          const trimmed = String(text || '').trim();
          if (!trimmed) {
            showToast('Clipboard empty.', 'warn');
            return;
          }
          applyPasteValue(input, trimmed);
          showTemporaryState(button, 'Pasted');
        } catch (error) {
          console.warn('Clipboard read failed:', error);
          showToast('Clipboard blocked. Paste manually.', 'warn');
          input.focus();
        }
      }

      function applyPasteValue(input, value) {
        if (!input) return;
        input.value = value;
        input.dispatchEvent(new Event('input', { bubbles: true }));
        input.dispatchEvent(new Event('blur', { bubbles: true }));
      }

      function getVenueLinkTarget(linkType) {
        switch (linkType) {
          case 'website':
            return { input: dom.websiteInput, stateKey: 'website', linkType: 'website' };
          case 'instagram':
            return { input: dom.instagramInput, stateKey: 'instagram', linkType: 'instagram' };
          case 'facebook':
            return { input: dom.facebookInput, stateKey: 'facebook', linkType: 'facebook' };
          default:
            return null;
        }
      }

      function getBarLinkValue(linkType, bar) {
        if (!bar || !linkType) return '';
        switch (linkType) {
          case 'website':
            return bar.website || bar.url || bar.site;
          case 'instagram':
            return bar.instagram;
          case 'facebook':
            return bar.facebook;
          default:
            return '';
        }
      }

      function applyBarLink(input, stateKey, linkType, value) {
        if (!input) return;
        const normalizedValue = normalizeText(value);
        if (!normalizedValue) return;
        const result = normalizeLinkValue(linkType, normalizedValue);
        state[stateKey] = result.value;
        input.value = result.value || normalizedValue;
        updateLinkFieldState(input, result);
      }

      function normalizeCoordinatesValue(value) {
        if (!value) return '';
        if (typeof value === 'string') return value.trim();
        if (typeof value === 'object' && Number.isFinite(value.lat) && Number.isFinite(value.lng)) {
          return `${value.lat}, ${value.lng}`;
        }
        return '';
      }

      function normalizeText(value) {
        if (typeof value === 'string') return value.trim();
        if (value === null || value === undefined) return '';
        return String(value).trim();
      }

      function resetForm() {
        const preservedCity = state.city;
        state = createDefaultState();
        state.city = preservedCity;
        recurrenceMode = 'builder';
        applyStateToForm();
        clearExistingSelection({ resetInputs: false });
        syncExistingCitySelection();
        populateVenueOptions(state.city);
        refreshUi();
        scheduleEventPush();
      }

      function updateCoordinatesFieldState() {
        if (!dom.coordinatesInput) return;
        const rawValue = dom.coordinatesInput.value.trim();
        const hint = getFieldHint(dom.coordinatesInput);
        if (!rawValue) {
          dom.coordinatesInput.classList.remove('is-invalid');
          dom.coordinatesInput.removeAttribute('aria-invalid');
          setFieldHint(hint, '', false);
          return;
        }
        const parsed = parseCoordinates(rawValue);
        const hasError = !parsed;
        dom.coordinatesInput.classList.toggle('is-invalid', hasError);
        if (hasError) {
          dom.coordinatesInput.setAttribute('aria-invalid', 'true');
          setFieldHint(hint, 'Use "lat, lng" like 40.7497, -73.9943.', true);
        } else {
          dom.coordinatesInput.removeAttribute('aria-invalid');
          setFieldHint(hint, '', false);
        }
      }

      function applyRecurrenceStateToForm() {
        const startDate = parseLocalDateTime(state.start, state.timezone);
        const fallback = getDefaultRecurrenceBuilder(startDate);
        const preferredMode = state.recurrenceMode === 'raw' ? 'raw' : 'builder';
        if (state.recurrence) {
          const parsed = parseRruleToBuilder(state.recurrence, fallback);
          if (parsed) {
            applyRecurrenceBuilderState(parsed);
            recurrenceMode = preferredMode;
          } else {
            applyRecurrenceBuilderState(fallback);
            recurrenceMode = 'raw';
          }
        } else {
          applyRecurrenceBuilderState(fallback);
          recurrenceMode = preferredMode;
        }
        state.recurrenceMode = recurrenceMode;
        if (dom.recurrenceInput) {
          dom.recurrenceInput.value = state.recurrence || '';
        }
        setRecurrenceMode(recurrenceMode, { silent: true, force: true });
        updateRecurrenceUi();
        updateRecurrenceSummary();
      }

      function setRecurrenceMode(mode, options = {}) {
        const nextMode = mode === 'raw' ? 'raw' : 'builder';
        if (recurrenceMode === nextMode && !options.force) {
          return;
        }
        recurrenceMode = nextMode;
        state.recurrenceMode = recurrenceMode;
        if (!options.silent) {
          if (recurrenceMode === 'builder') {
            const rawValue = dom.recurrenceInput ? dom.recurrenceInput.value.trim() : '';
            if (rawValue) {
              const parsed = parseRruleToBuilder(rawValue);
              if (parsed) {
                applyRecurrenceBuilderState(parsed);
                state.recurrence = rawValue;
              }
            }
          } else {
            state.recurrence = buildRruleFromBuilder();
            if (dom.recurrenceInput) {
              dom.recurrenceInput.value = state.recurrence;
            }
          }
          refreshUi();
        }
        if (dom.recurrenceModeButtons && dom.recurrenceModeButtons.length) {
          dom.recurrenceModeButtons.forEach(button => {
            button.classList.toggle('is-active', button.dataset.recurrenceMode === recurrenceMode);
          });
        }
        updateRecurrenceUi();
        updateRecurrenceSummary();
      }

      function updateRecurrenceUi() {
        const frequency = dom.recurrenceFrequency ? dom.recurrenceFrequency.value : 'none';
        const showWeekly = frequency === 'weekly';
        const showMonthly = frequency === 'monthly';
        const showEnds = frequency !== 'none';
        if (dom.recurrenceWeeklyRow) {
          dom.recurrenceWeeklyRow.classList.toggle('is-hidden', !showWeekly);
        }
        if (dom.recurrenceMonthlyRow) {
          dom.recurrenceMonthlyRow.classList.toggle('is-hidden', !showMonthly);
        }
        if (dom.recurrenceBuilder) {
          dom.recurrenceBuilder.classList.toggle('is-hidden', recurrenceMode !== 'builder');
        }
        if (dom.recurrenceRaw) {
          dom.recurrenceRaw.classList.toggle('is-hidden', recurrenceMode !== 'raw');
        }
        if (dom.recurrenceIntervalLabel) {
          const label = frequency === 'daily'
            ? 'day(s)'
            : frequency === 'monthly'
              ? 'month(s)'
              : 'week(s)';
          dom.recurrenceIntervalLabel.textContent = label;
        }
        if (dom.recurrenceInterval) {
          dom.recurrenceInterval.disabled = frequency === 'none';
        }
        if (dom.recurrenceIntervalGroup) {
          dom.recurrenceIntervalGroup.classList.toggle('is-hidden', frequency === 'none');
        }
        if (dom.recurrenceEndsRow) {
          dom.recurrenceEndsRow.classList.toggle('is-hidden', !showEnds);
        }
        if (dom.recurrenceEnds) {
          dom.recurrenceEnds.disabled = !showEnds;
        }
        if (dom.recurrenceEnds) {
          const endsValue = dom.recurrenceEnds.value || 'never';
          if (dom.recurrenceCountGroup) {
            dom.recurrenceCountGroup.classList.toggle('is-hidden', endsValue !== 'count');
          }
          if (dom.recurrenceUntilGroup) {
            dom.recurrenceUntilGroup.classList.toggle('is-hidden', endsValue !== 'until');
          }
        }
        const monthlyMode = getSelectedMonthlyMode();
        if (dom.recurrenceMonthday) {
          dom.recurrenceMonthday.disabled = monthlyMode !== 'monthday';
        }
        if (dom.recurrenceWeekPos) {
          dom.recurrenceWeekPos.disabled = monthlyMode !== 'weekday';
        }
        if (dom.recurrenceWeekday) {
          dom.recurrenceWeekday.disabled = monthlyMode !== 'weekday';
        }
      }

      function handleRecurrenceBuilderChange() {
        if (recurrenceMode !== 'builder' || isRecurrenceSyncing) return;
        isRecurrenceSyncing = true;
        const nextRule = buildRruleFromBuilder();
        state.recurrence = nextRule;
        if (dom.recurrenceInput) {
          dom.recurrenceInput.value = nextRule;
        }
        updateRecurrenceUi();
        updateRecurrenceSummary();
        refreshUi();
        isRecurrenceSyncing = false;
      }

      function toggleRecurrenceDay(button) {
        const isActive = !button.classList.contains('is-active');
        button.classList.toggle('is-active', isActive);
        button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      }

      function getSelectedMonthlyMode() {
        const selected = dom.recurrenceMonthlyMode
          ? [...dom.recurrenceMonthlyMode].find(input => input.checked)
          : null;
        return selected ? selected.value : 'monthday';
      }

      function getDefaultRecurrenceBuilder(startDate) {
        const dayCode = startDate ? getDayCode(startDate) : 'FR';
        const monthDay = startDate ? startDate.getDate() : 15;
        return {
          frequency: 'none',
          interval: 1,
          byDay: [dayCode],
          monthlyMode: 'monthday',
          monthDay,
          weekPos: 1,
          weekDay: dayCode,
          ends: 'never',
          count: '',
          until: ''
        };
      }

      function applyRecurrenceBuilderState(builder) {
        if (!builder) return;
        if (dom.recurrenceFrequency) dom.recurrenceFrequency.value = builder.frequency || 'none';
        if (dom.recurrenceInterval) dom.recurrenceInterval.value = builder.interval || 1;
        if (dom.recurrenceWeekdayButtons && dom.recurrenceWeekdayButtons.length) {
          dom.recurrenceWeekdayButtons.forEach(button => {
            const day = button.dataset.day;
            const isActive = builder.byDay && builder.byDay.includes(day);
            button.classList.toggle('is-active', isActive);
            button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
          });
        }
        if (dom.recurrenceMonthlyMode && dom.recurrenceMonthlyMode.length) {
          dom.recurrenceMonthlyMode.forEach(input => {
            input.checked = input.value === (builder.monthlyMode || 'monthday');
          });
        }
        if (dom.recurrenceMonthday) dom.recurrenceMonthday.value = builder.monthDay || '';
        if (dom.recurrenceWeekPos) dom.recurrenceWeekPos.value = builder.weekPos || 1;
        if (dom.recurrenceWeekday) dom.recurrenceWeekday.value = builder.weekDay || 'MO';
        if (dom.recurrenceEnds) dom.recurrenceEnds.value = builder.ends || 'never';
        if (dom.recurrenceCount) dom.recurrenceCount.value = builder.count || '';
        if (dom.recurrenceUntil) dom.recurrenceUntil.value = builder.until || '';
      }

      function buildRruleFromBuilder() {
        if (!dom.recurrenceFrequency) return '';
        const frequency = dom.recurrenceFrequency.value || 'none';
        if (frequency === 'none') return '';
        const parts = [`FREQ=${frequency.toUpperCase()}`];
        const interval = Math.max(1, parseInt(dom.recurrenceInterval ? dom.recurrenceInterval.value : '1', 10) || 1);
        if (interval > 1) {
          parts.push(`INTERVAL=${interval}`);
        }
        if (frequency === 'weekly') {
          let byDay = dom.recurrenceWeekdayButtons
            ? [...dom.recurrenceWeekdayButtons]
              .filter(button => button.classList.contains('is-active'))
              .map(button => button.dataset.day)
              .filter(Boolean)
            : [];
          if (!byDay.length) {
            const startDate = parseLocalDateTime(state.start, state.timezone);
            byDay = [getDayCode(startDate || new Date())];
            if (dom.recurrenceWeekdayButtons) {
              dom.recurrenceWeekdayButtons.forEach(button => {
                const isActive = byDay.includes(button.dataset.day);
                button.classList.toggle('is-active', isActive);
                button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
              });
            }
          }
          parts.push(`BYDAY=${byDay.join(',')}`);
        }
        if (frequency === 'monthly') {
          const monthlyMode = getSelectedMonthlyMode();
          if (monthlyMode === 'weekday') {
            let weekPos = dom.recurrenceWeekPos ? dom.recurrenceWeekPos.value : '1';
            let weekDay = dom.recurrenceWeekday ? dom.recurrenceWeekday.value : 'MO';
            if (!weekPos || !weekDay) {
              const startDate = parseLocalDateTime(state.start, state.timezone);
              weekDay = getDayCode(startDate || new Date());
              weekPos = '1';
              if (dom.recurrenceWeekPos) dom.recurrenceWeekPos.value = weekPos;
              if (dom.recurrenceWeekday) dom.recurrenceWeekday.value = weekDay;
            }
            parts.push(`BYDAY=${weekDay}`);
            parts.push(`BYSETPOS=${weekPos}`);
          } else {
            let monthDay = parseInt(dom.recurrenceMonthday ? dom.recurrenceMonthday.value : '', 10);
            if (!monthDay) {
              const startDate = parseLocalDateTime(state.start, state.timezone);
              monthDay = startDate ? startDate.getDate() : 1;
              if (dom.recurrenceMonthday) dom.recurrenceMonthday.value = monthDay;
            }
            parts.push(`BYMONTHDAY=${monthDay}`);
          }
        }
        if (dom.recurrenceEnds) {
          const ends = dom.recurrenceEnds.value;
          if (ends === 'count') {
            const count = parseInt(dom.recurrenceCount ? dom.recurrenceCount.value : '', 10);
            if (count) {
              parts.push(`COUNT=${count}`);
            }
          }
          if (ends === 'until') {
            const untilValue = dom.recurrenceUntil ? dom.recurrenceUntil.value : '';
            const untilDate = formatUntilDate(untilValue);
            if (untilDate) {
              parts.push(`UNTIL=${untilDate}`);
            }
          }
        }
        return parts.join(';');
      }

      function parseRruleToBuilder(rule, fallback = null) {
        if (!rule || typeof rule !== 'string') return null;
        const trimmed = rule.trim();
        if (!trimmed) return null;
        const parts = trimmed.split(';');
        const rules = {};
        parts.forEach(part => {
          const [key, value] = part.split('=');
          if (!key || !value) return;
          rules[key.toUpperCase()] = value;
        });
        const freq = rules.FREQ ? rules.FREQ.toLowerCase() : '';
        if (!['daily', 'weekly', 'monthly'].includes(freq)) {
          return null;
        }
        const builder = fallback ? { ...fallback } : getDefaultRecurrenceBuilder(null);
        builder.frequency = freq;
        builder.interval = Math.max(1, parseInt(rules.INTERVAL || '1', 10) || 1);
        if (freq === 'weekly') {
          builder.byDay = rules.BYDAY ? rules.BYDAY.split(',') : builder.byDay;
        }
        if (freq === 'monthly') {
          if (rules.BYMONTHDAY) {
            builder.monthlyMode = 'monthday';
            builder.monthDay = parseInt(rules.BYMONTHDAY.split(',')[0], 10) || builder.monthDay;
          } else if (rules.BYDAY && rules.BYSETPOS) {
            builder.monthlyMode = 'weekday';
            builder.weekDay = rules.BYDAY.split(',')[0] || builder.weekDay;
            builder.weekPos = parseInt(rules.BYSETPOS.split(',')[0], 10) || builder.weekPos;
          } else if (rules.BYDAY) {
            const token = rules.BYDAY.split(',')[0];
            const match = token.match(/^(-?\d+)?([A-Z]{2})$/);
            if (match) {
              builder.monthlyMode = 'weekday';
              builder.weekDay = match[2] || builder.weekDay;
              if (match[1]) {
                builder.weekPos = parseInt(match[1], 10) || builder.weekPos;
              }
            }
          }
        }
        if (rules.COUNT) {
          builder.ends = 'count';
          builder.count = parseInt(rules.COUNT, 10) || '';
        } else if (rules.UNTIL) {
          builder.ends = 'until';
          builder.until = parseUntilDate(rules.UNTIL);
        } else {
          builder.ends = 'never';
        }
        return builder;
      }

      function updateRecurrenceSummary() {
        if (!dom.recurrenceSummary) return;
        if (!state.recurrence) {
          dom.recurrenceSummary.textContent = 'Does not repeat.';
          return;
        }
        if (recurrenceMode === 'builder') {
          const builder = parseRruleToBuilder(state.recurrence, getDefaultRecurrenceBuilder(null));
          if (builder) {
            dom.recurrenceSummary.textContent = formatRecurrenceSummary(builder);
            return;
          }
        }
        dom.recurrenceSummary.textContent = `RRULE: ${state.recurrence}`;
      }

      function formatRecurrenceSummary(builder) {
        if (!builder || builder.frequency === 'none') return 'Does not repeat.';
        const interval = builder.interval || 1;
        const intervalLabel = interval > 1 ? `Every ${interval}` : 'Every';
        let label = '';
        if (builder.frequency === 'daily') {
          label = interval > 1 ? `${intervalLabel} days` : 'Daily';
        } else if (builder.frequency === 'weekly') {
          const days = builder.byDay && builder.byDay.length
            ? builder.byDay.map(code => DAY_CODE_LABELS[code] || code).join(', ')
            : 'selected days';
          label = interval > 1 ? `${intervalLabel} weeks on ${days}` : `Weekly on ${days}`;
        } else if (builder.frequency === 'monthly') {
          if (builder.monthlyMode === 'weekday') {
            const posLabel = WEEK_POSITION_LABELS[builder.weekPos] || 'First';
            const dayLabel = DAY_CODE_LABELS[builder.weekDay] || builder.weekDay;
            label = interval > 1
              ? `${intervalLabel} months on the ${posLabel} ${dayLabel}`
              : `Monthly on the ${posLabel} ${dayLabel}`;
          } else {
            const day = builder.monthDay || 1;
            label = interval > 1
              ? `${intervalLabel} months on day ${day}`
              : `Monthly on day ${day}`;
          }
        }
        if (builder.ends === 'count' && builder.count) {
          label += ` ¬∑ ${builder.count} times`;
        }
        if (builder.ends === 'until' && builder.until) {
          label += ` ¬∑ until ${builder.until}`;
        }
        return label;
      }

      function getRecurrenceChipLabel(recurrence) {
        if (!recurrence) return '';
        const parsed = parseRruleToBuilder(recurrence);
        if (!parsed) return 'Recurring';
        if (parsed.frequency === 'daily') return parsed.interval > 1 ? `Every ${parsed.interval} days` : 'Daily';
        if (parsed.frequency === 'weekly') return parsed.interval > 1 ? `Every ${parsed.interval} weeks` : 'Weekly';
        if (parsed.frequency === 'monthly') return parsed.interval > 1 ? `Every ${parsed.interval} months` : 'Monthly';
        return 'Recurring';
      }

      function ensureDateOrder() {
        if (!state.start) {
          state.start = formatInputValue(new Date());
        }
        if (!state.end) {
          const startDate = parseLocalDateTime(state.start, state.timezone);
          if (startDate) {
            const fallback = new Date(startDate.getTime() + DEFAULT_DURATION_MINUTES * 60000);
            state.end = formatInputValue(fallback);
          }
        }
        const startDate = parseLocalDateTime(state.start, state.timezone);
        const endDate = parseLocalDateTime(state.end, state.timezone);
        if (startDate && endDate && endDate <= startDate) {
          const newEnd = new Date(startDate.getTime() + DEFAULT_DURATION_MINUTES * 60000);
          state.end = formatInputValue(newEnd);
          if (dom.endInput) {
            dom.endInput.value = state.end;
          }
        }
      }

      function updateTimeNotes() {
        if (dom.durationNote) {
          const startDate = parseLocalDateTime(state.start, state.timezone);
          const endDate = parseLocalDateTime(state.end, state.timezone);
          if (!startDate || !endDate) {
            dom.durationNote.innerHTML = '<strong>Duration:</strong> Add start &amp; end';
          } else {
            const minutes = Math.max(0, Math.round((endDate - startDate) / 60000));
            const label = minutes ? formatDurationLabel(minutes) : 'TBD';
            dom.durationNote.innerHTML = `<strong>Duration:</strong> ${label}`;
          }
        }
      }

      function updatePreviewCard() {
        if (!dom.previewTitle) return;
        const event = buildEventPayload();
        const title = event.name || 'Untitled event';
        if (dom.previewTitle) dom.previewTitle.textContent = title;
        if (dom.previewCity) {
          dom.previewCity.textContent = getCityLabel(state.city) || 'City';
        }
        if (dom.previewTime) {
          dom.previewTime.textContent = formatPreviewDate(event.startDate, event.endDate, event.timezone);
        }
        if (dom.previewVenue) {
          dom.previewVenue.textContent = event.bar || 'Venue TBA';
        }
        if (dom.previewAddress) {
          dom.previewAddress.textContent = event.address || 'Address TBD';
        }
        const imageUrl = (state.image || '').trim();
        if (dom.previewMedia) {
          dom.previewMedia.classList.toggle('has-image', Boolean(imageUrl));
        }
        if (dom.previewImage) {
          if (imageUrl) {
            dom.previewImage.src = imageUrl;
            dom.previewImage.alt = title ? `${title} promo` : 'Event promo image';
          } else {
            dom.previewImage.removeAttribute('src');
            dom.previewImage.alt = '';
          }
        }
        const recurrenceLabel = getRecurrenceChipLabel(event.recurrence);
        setChip(dom.previewRecurring, recurrenceLabel, Boolean(event.recurrence));
        setChip(dom.previewCover, state.cover ? `Cover: ${state.cover}` : '', Boolean(state.cover), true);
        updatePreviewLinks(event.links);
      }

      function updatePreviewLinks(links) {
        if (!dom.previewLinks) return;
        dom.previewLinks.innerHTML = '';
        if (!Array.isArray(links) || !links.length) {
          dom.previewLinks.classList.add('is-hidden');
          return;
        }
        dom.previewLinks.classList.remove('is-hidden');
        links.forEach(link => {
          const anchor = document.createElement('a');
          anchor.href = link.url;
          anchor.target = '_blank';
          anchor.rel = 'noopener';
          anchor.textContent = link.label || link.type || 'Link';
          dom.previewLinks.appendChild(anchor);
        });
      }

      function buildShareUrl(options = {}) {
        const params = new URLSearchParams();
        if (state.name) params.set('name', state.name);
        if (state.shortName) params.set('short', state.shortName);
        if (state.city) params.set('city', state.city);
        const savedBarName = normalizeText(state.savedBar);
        if (savedBarName) params.set('bar', savedBarName);
        if (state.venue) params.set('venue', state.venue);
        if (state.address) params.set('addr', state.address);
        if (state.description) params.set('desc', state.description);
        if (state.cover) params.set('cover', state.cover);
        if (state.start) params.set('start', state.start);
        if (state.end) params.set('end', state.end);
        if (state.recurrence) params.set('rrule', state.recurrence);
        if (state.recurrenceMode === 'raw') params.set('rmode', 'raw');
        if (state.website) params.set('web', state.website);
        if (state.ticketUrl) params.set('tickets', state.ticketUrl);
        if (state.instagram) params.set('insta', state.instagram);
        if (state.facebook) params.set('fb', state.facebook);
        if (state.gmaps) params.set('gmaps', state.gmaps);
        if (state.useVenueWebsite) params.set('vweb', '1');
        if (state.useVenueInstagram) params.set('vinsta', '1');
        if (state.useVenueFacebook) params.set('vfb', '1');
        const summaryText = String(state.existingSelectionSummary || '').trim();
        if (summaryText) params.set('esummary', summaryText);
        if (state.existingSelectionAction) params.set('eaction', state.existingSelectionAction);
        if (state.isEditingExisting) {
          params.set('edit', '1');
          if (state.editingExistingId) params.set('editid', state.editingExistingId);
          if (state.editingExistingMode) params.set('emode', state.editingExistingMode);
          if (state.editingExistingOccurrenceId) params.set('occid', state.editingExistingOccurrenceId);
          if (state.editingExistingUid) params.set('euid', state.editingExistingUid);
          if (state.editingExistingRecurrenceId) params.set('erid', state.editingExistingRecurrenceId);
          if (state.editingExistingRecurrenceTimezone) params.set('ertz', state.editingExistingRecurrenceTimezone);
        }
        if (state.image) params.set('img', state.image);
        const coordsValue = (state.location || '').trim();
        if (coordsValue) params.set('coords', coordsValue);
        const includeDebug = typeof options.includeDebug === 'boolean'
          ? options.includeDebug
          : Boolean(state && state.debug);
        if (includeDebug) params.set('debug', '1');
        const sorted = new URLSearchParams();
        [...params.keys()].sort().forEach(key => sorted.set(key, params.get(key)));
        const query = sorted.toString();
        return query ? `${window.location.pathname}?${query}` : window.location.pathname;
      }

      function applyHistoryUrl(newUrl) {
        const current = `${window.location.pathname}${window.location.search}`;
        if (current !== newUrl) {
          window.history.replaceState({}, '', newUrl);
        }
        return newUrl;
      }

      function updateUrl() {
        return applyHistoryUrl(buildShareUrl());
      }

      function scheduleUrlUpdate() {
        if (urlTimeoutId) {
          clearTimeout(urlTimeoutId);
        }
        urlTimeoutId = setTimeout(() => {
          urlTimeoutId = null;
          updateUrl();
        }, URL_UPDATE_DELAY);
      }

      function getShareUrl(options = {}) {
        const newUrl = options.skipHistory
          ? buildShareUrl({ includeDebug: options.includeDebug })
          : applyHistoryUrl(buildShareUrl({ includeDebug: options.includeDebug }));
        try {
          return new URL(newUrl, window.location.href).href;
        } catch (error) {
          return window.location.href;
        }
      }

      function buildScriptableCallbackUrl() {
        if (!state) return '';
        const scriptName = String(SCRIPTABLE_SCRIPT_NAME || '').trim();
        if (!scriptName) return '';
        const params = new URLSearchParams();
        params.set('scriptName', scriptName);
        if (state.debug) {
          params.set('openEditor', 'true');
        }
        const setParam = (key, value) => {
          const normalized = value ?? '';
          const trimmed = String(normalized).trim();
          params.set(key, trimmed);
        };
        const startValue = sanitizeDateTimeInput(state.start);
        const endValue = sanitizeDateTimeInput(state.end);
        setParam('title', state.name);
        setParam('shortName', state.shortName);
        setParam('description', state.description);
        setParam('cover', state.cover);
        setParam('bar', state.venue);
        setParam('address', state.address);
        setParam('location', state.location);
        setParam('city', state.city);
        setParam('timezone', state.timezone || browserTimezone);
        setParam('startDate', startValue);
        setParam('endDate', endValue);
        setParam('recurrence', state.recurrence);
        setParam('website', state.website);
        setParam('ticketUrl', state.ticketUrl);
        setParam('instagram', state.instagram);
        setParam('facebook', state.facebook);
        setParam('gmaps', state.gmaps);
        setParam('image', state.image);
        const coordinates = parseCoordinates(state.location);
        setParam('lat', coordinates ? coordinates.lat : '');
        setParam('lng', coordinates ? coordinates.lng : '');
        const identifier = state.editingExistingUid
          || (state.editingExistingId ? parseResultId(state.editingExistingId).uid : '');
        if (identifier) {
          setParam('identifier', identifier);
        }
        const recurrenceIdValue = sanitizeDateTimeInput(state.editingExistingRecurrenceId);
        if (recurrenceIdValue) {
          setParam('recurrenceId', recurrenceIdValue);
          setParam('recurrenceIdTimezone', state.editingExistingRecurrenceTimezone);
        }
        const encodedScriptName = encodeURIComponent(scriptName);
        logger.debug('EVENT', 'Built Scriptable callback URL params', {
          identifier,
          recurrenceId: recurrenceIdValue || '',
          recurrenceIdTimezone: state.editingExistingRecurrenceTimezone || '',
          isEditingExisting: Boolean(state.isEditingExisting),
          editingExistingMode: state.editingExistingMode || null
        });
        return `scriptable:///run/${encodedScriptName}?${params.toString()}`;
      }

      function buildTellDadMessage() {
        const shareUrl = getShareUrl({ includeDebug: true, skipHistory: !state || !state.debug });
        const scriptableUrl = buildScriptableCallbackUrl();
        const eventName = (state.name || '').trim();
        const cityLabel = getCityDisplayName(state.city);
        const subjectParts = ['Event Builder'];
        if (eventName) subjectParts.push(eventName);
        if (cityLabel) subjectParts.push(cityLabel);
        const subject = subjectParts.join(' - ');
        const bodyTextLines = [
          'Hey Dad, here is the event link:',
          '',
          '',
          '',
          shareUrl
        ];
        const bodyText = bodyTextLines.join('\n');
        return {
          shareUrl,
          scriptableUrl,
          subject,
          body: bodyText,
          bodyText
        };
      }

      function buildTellDadMailto(message = buildTellDadMessage()) {
        if (!message || !message.shareUrl) return '';
        const body = message.bodyHtml || message.bodyText || message.body || '';
        return `mailto:${DAD_EMAIL}?subject=${encodeURIComponent(message.subject)}&body=${encodeURIComponent(body)}`;
      }

      function openTellDadEmail(button) {
        const message = buildTellDadMessage();
        if (!message.shareUrl) return;
        const fallbackBody = message.bodyText || message.body || '';
        const fallbackText = `To: ${DAD_EMAIL}\nSubject: ${message.subject}\n\n${fallbackBody}`;
        const mailtoUrl = buildTellDadMailto(message);
        if (mailtoUrl) {
          window.location.href = mailtoUrl;
          showTemporaryState(button, 'Email ready!');
          copyToClipboard(fallbackText);
          showToast('If your mail app stays closed, the email details are copied.', 'info');
          return;
        }
        copyToClipboard(fallbackText, button);
        showToast('Email details copied. Paste into your mail app.', 'warn');
      }

      function refreshUi() {
        ensureDateOrder();
        updateTimeNotes();
        updateRecurrenceUi();
        updateRecurrenceSummary();
        updatePreviewCard();
        updateCoordinatesFieldState();
        scheduleUrlUpdate();
        scheduleEventPush();
      }

      function scheduleEventPush() {
        if (!dom.calendarIframe) return;
        if (sendTimeoutId) {
          clearTimeout(sendTimeoutId);
        }
        sendTimeoutId = setTimeout(() => {
          sendTimeoutId = null;
          pushEventToCalendar();
        }, EVENT_PUSH_DELAY);
      }

      function pushEventToCalendar() {
        if (!dom.calendarIframe || !dom.calendarIframe.contentWindow) return;
        const payload = buildMessagePayload();
        if (!payload) {
          updateCalendarStatus('Add start & end times to preview', 'warn');
          return;
        }
        updateCalendarStatus('Updating preview‚Ä¶', 'sending');
        try {
          dom.calendarIframe.contentWindow.postMessage({
            type: 'addTestEvent',
            data: payload
          }, '*');
        } catch (error) {
          logger.componentError('EVENT', 'Failed to send event to calendar iframe', error);
          updateCalendarStatus('Could not reach preview', 'error');
        }
      }

      function buildEventPayload() {
        const startDate = parseLocalDateTime(state.start, state.timezone);
        const endDate = parseLocalDateTime(state.end, state.timezone);
        const computedLabel = formatTimeRange(startDate, endDate, state.timezone);
        const timeLabel = computedLabel;
        const dayLabel = startDate
          ? startDate.toLocaleDateString('en-US', { weekday: 'long', timeZone: state.timezone || browserTimezone })
          : '';
        const durationMinutes = startDate && endDate
          ? Math.max(1, Math.round((endDate - startDate) / 60000))
          : DEFAULT_DURATION_MINUTES;
        const links = buildLinks();
        const locationValue = (state.location || '').trim();
        const coordinates = parseCoordinates(locationValue);
        const timezone = state.timezone || browserTimezone;
        const rawRecurrence = (state.recurrence || '').trim();
        const isOverride = state.isEditingExisting && state.editingExistingMode === 'occurrence';
        const recurrence = isOverride ? '' : rawRecurrence;
        const recurring = Boolean(recurrence);
        let uid = '';
        if (state.isEditingExisting && state.editingExistingUid) {
          uid = state.editingExistingUid;
        } else if (state.isEditingExisting && state.editingExistingId) {
          const parsedUid = parseResultId(state.editingExistingId);
          uid = parsedUid.uid || '';
        }
        const recurrenceIdTimezone = isOverride
          ? (state.editingExistingRecurrenceTimezone || timezone)
          : '';
        let recurrenceId = null;
        if (isOverride && state.editingExistingRecurrenceId) {
          recurrenceId = parseEditingRecurrenceId(state.editingExistingRecurrenceId, recurrenceIdTimezone || timezone);
        }
        return {
          name: (state.name || '').trim(),
          shortName: (state.shortName || '').trim(),
          tea: (state.description || '').trim(),
          cover: (state.cover || '').trim(),
          bar: (state.venue || 'Venue TBA').trim(),
          address: (state.address || '').trim(),
          location: locationValue,
          coordinates,
          city: state.city,
          time: timeLabel,
          day: dayLabel,
          startDate,
          endDate,
          timezone,
          uid,
          recurrenceId,
          recurrenceIdTimezone,
          image: (state.image || '').trim() || null,
          website: (state.website || '').trim() || null,
          instagram: (state.instagram || '').trim() || null,
          facebook: (state.facebook || '').trim() || null,
          gmaps: (state.gmaps || '').trim() || null,
          ticketUrl: (state.ticketUrl || '').trim() || null,
          links,
          recurring,
          recurrence,
          durationMinutes
        };
      }

      function buildMessagePayload() {
        const event = buildEventPayload();
        if (!event.startDate || !event.endDate) {
          return null;
        }
        return {
          name: event.name,
          shortName: event.shortName,
          nickname: event.shortName,
          tea: event.tea,
          description: event.tea,
          cover: event.cover,
          bar: event.bar,
          venue: event.bar,
          address: event.address,
          location: event.location,
          coordinates: event.coordinates,
          city: event.city,
          time: event.time,
          day: event.day,
          startDate: event.startDate.toISOString(),
          endDate: event.endDate.toISOString(),
          timezone: event.timezone,
          uid: event.uid || null,
          recurrenceId: event.recurrenceId ? event.recurrenceId.toISOString() : null,
          recurrenceIdTimezone: event.recurrenceIdTimezone || null,
          durationMinutes: event.durationMinutes,
          image: event.image,
          website: event.website,
          instagram: event.instagram,
          facebook: event.facebook,
          gmaps: event.gmaps,
          ticketUrl: event.ticketUrl,
          tickets: event.ticketUrl,
          links: event.links,
          recurring: event.recurring,
          recurrence: event.recurrence || null,
          isEditingExisting: Boolean(state.isEditingExisting),
          editingExistingMode: state.editingExistingMode || null
        };
      }

      function buildLinks() {
        const links = [];
        const addLink = (label, url, type) => {
          const trimmedUrl = (url || '').trim();
          if (!trimmedUrl) return;
          links.push({
            label: label || type,
            url: trimmedUrl,
            type
          });
        };
        addLink('üåê Website', state.website, 'website');
        addLink('üé´ Tickets', state.ticketUrl, 'tickets');
        addLink('üì∑ Instagram', state.instagram, 'instagram');
        addLink('üìò Facebook', state.facebook, 'facebook');
        addLink('üó∫Ô∏è Google Maps', state.gmaps, 'gmaps');
        return links;
      }

      function setupMessaging() {
        if (dom.calendarIframe) {
          dom.calendarIframe.addEventListener('load', () => {
            iframeLoaded = true;
            calendarReady = false;
            updateCalendarStatus('Loading calendar‚Ä¶', 'loading');
            setTimeout(() => {
              pushEventToCalendar();
            }, 350);
          });
        }
        window.addEventListener('message', event => {
          const data = event.data;
          if (!data || typeof data !== 'object') return;
          if (data.type === 'calendarInitialized') {
            if (!data.city || data.city === state.city) {
              calendarReady = true;
              updateCalendarStatus('Calendar ready', 'ready');
              pushEventToCalendar();
            }
          }
          if (data.type === 'testEventRendered') {
            if (!data.city || data.city === state.city) {
              calendarReady = true;
              updateCalendarStatus('Preview updated', 'ready');
            }
          }
        });
      }

      function updateCalendarSource(force = false) {
        if (!dom.calendarIframe) return;
        const targetCity = state.city || 'nyc';
        if (!force && currentCalendarCity === targetCity) {
          return;
        }
        currentCalendarCity = targetCity;
        calendarReady = false;
        iframeLoaded = false;
        const newSrc = `../city.html?city=${encodeURIComponent(targetCity)}`;
        dom.calendarIframe.src = newSrc;
        updateCalendarStatus('Loading calendar‚Ä¶', 'loading');
      }

      function updateCalendarStatus(message, status) {
        if (!dom.calendarStatus) return;
        dom.calendarStatus.textContent = message;
        dom.calendarStatus.className = status ? `status-badge status-${status}` : 'status-badge';
      }

      function parseLocalDateTime(value, timeZone) {
        if (!value) return null;
        const [datePart, timePart = '00:00'] = value.split('T');
        if (!datePart) return null;
        const [year, month, day] = datePart.split('-').map(Number);
        const [hour, minute] = timePart.split(':').map(Number);
        const utcDate = new Date(Date.UTC(year, (month || 1) - 1, day || 1, hour || 0, minute || 0));
        return new Date(utcDate.getTime() - getTimeZoneOffset(utcDate, timeZone || browserTimezone));
      }

      function parseEditingRecurrenceId(value, timeZone) {
        if (!value) return null;
        if (value instanceof Date) {
          return Number.isNaN(value.getTime()) ? null : new Date(value.getTime());
        }
        const trimmed = String(value).trim();
        if (!trimmed) return null;
        const sanitized = sanitizeDateTimeInput(trimmed);
        if (sanitized) {
          return parseLocalDateTime(sanitized, timeZone || browserTimezone);
        }
        const parsed = new Date(trimmed);
        return Number.isNaN(parsed.getTime()) ? null : parsed;
      }

      function getTimeZoneOffset(date, timeZone) {
        const parts = new Intl.DateTimeFormat('en-US', {
          timeZone,
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          hour12: false
        }).formatToParts(date);
        const values = {};
        parts.forEach(part => {
          if (part.type !== 'literal') {
            values[part.type] = part.value;
          }
        });
        const asUTC = Date.UTC(
          Number(values.year),
          Number(values.month) - 1,
          Number(values.day),
          Number(values.hour),
          Number(values.minute),
          Number(values.second || '0')
        );
        return asUTC - date.getTime();
      }

      function formatTimeRange(startDate, endDate, timeZone) {
        if (!startDate || !endDate) return '';
        const formatter = new Intl.DateTimeFormat('en-US', {
          timeZone: timeZone || browserTimezone,
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        });
        const startParts = formatter.formatToParts(startDate);
        const endParts = formatter.formatToParts(endDate);
        const startLabel = formatTimeParts(startParts);
        const endLabel = formatTimeParts(endParts);
        return startLabel === endLabel ? startLabel : `${startLabel}-${endLabel}`;
      }

      function formatTimeParts(parts) {
        const values = {};
        parts.forEach(part => {
          if (part.type !== 'literal') {
            values[part.type] = part.value;
          }
        });
        const hour = values.hour ? parseInt(values.hour, 10).toString() : '';
        const minute = values.minute && values.minute !== '00' ? `:${values.minute}` : '';
        const period = values.dayPeriod ? values.dayPeriod.toUpperCase() : '';
        return `${hour}${minute}${period}`;
      }

      function formatInputValue(date) {
        const local = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
        return local.toISOString().slice(0, 16);
      }

      function sanitizeDateTimeInput(value) {
        if (typeof value !== 'string') return '';
        const trimmed = value.trim();
        if (!trimmed) return '';
        if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(trimmed)) return trimmed;
        if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(trimmed)) return trimmed.slice(0, 16);
        return '';
      }

      function formatPreviewDate(startDate, endDate, timeZone) {
        if (!startDate || !endDate) {
          return 'Add start and end times to preview timing.';
        }
        const dateLabel = startDate.toLocaleDateString('en-US', {
          weekday: 'long',
          month: 'short',
          day: 'numeric',
          timeZone: timeZone || browserTimezone
        });
        const rangeLabel = formatTimeRange(startDate, endDate, timeZone);
        return rangeLabel ? `${dateLabel} ¬∑ ${rangeLabel}` : dateLabel;
      }

      function formatDurationLabel(minutes) {
        if (!minutes) return 'Duration TBD';
        const hours = Math.floor(minutes / 60);
        const remainder = minutes % 60;
        const parts = [];
        if (hours) parts.push(`${hours} hr${hours === 1 ? '' : 's'}`);
        if (remainder) parts.push(`${remainder} min`);
        return parts.join(' ') || `${minutes} min`;
      }

      function getDayCode(date) {
        if (!(date instanceof Date)) return 'FR';
        const codes = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
        return codes[date.getDay()] || 'FR';
      }

      function formatUntilDate(value) {
        if (!value || !/^\d{4}-\d{2}-\d{2}$/.test(value)) return '';
        const compact = value.replace(/-/g, '');
        return `${compact}T235959Z`;
      }

      function parseUntilDate(value) {
        if (!value) return '';
        const match = String(value).match(/^(\d{4})(\d{2})(\d{2})/);
        if (!match) return '';
        return `${match[1]}-${match[2]}-${match[3]}`;
      }

      function parseCoordinates(value) {
        if (!value) return null;
        const parts = value.split(',');
        if (parts.length < 2) return null;
        const lat = parseFloat(parts[0].trim());
        const lng = parseFloat(parts[1].trim());
        if (!Number.isFinite(lat) || !Number.isFinite(lng)) return null;
        if (lat < -90 || lat > 90 || lng < -180 || lng > 180) return null;
        return { lat, lng };
      }

      function getCityDisplayName(cityKey) {
        if (!cityKey) return '';
        if (typeof getCityConfig === 'function') {
          const config = getCityConfig(cityKey);
          if (config && config.name) return config.name;
        }
        if (typeof CITY_CONFIG === 'object' && CITY_CONFIG && CITY_CONFIG[cityKey]) {
          const city = CITY_CONFIG[cityKey];
          if (city.name) return city.name;
        }
        if (dom.citySelect) {
          const option = [...dom.citySelect.options].find(option => option.value === cityKey);
          if (option && option.textContent) {
            return option.textContent.replace(/^[^A-Za-z0-9]+\s*/, '');
          }
        }
        return cityKey.replace(/-/g, ' ').replace(/\b\w/g, char => char.toUpperCase());
      }

      function getCityLabel(cityKey) {
        if (dom.citySelect) {
          const option = [...dom.citySelect.options].find(option => option.value === cityKey);
          if (option) return option.textContent;
        }
        if (typeof CITY_CONFIG === 'object' && CITY_CONFIG && CITY_CONFIG[cityKey]) {
          const city = CITY_CONFIG[cityKey];
          return city.emoji ? `${city.emoji} ${city.name}` : city.name || cityKey;
        }
        if (!cityKey) return '';
        return cityKey.replace(/-/g, ' ').replace(/\b\w/g, char => char.toUpperCase());
      }

      function setChip(element, text, show, muted = false) {
        if (!element) return;
        element.textContent = text || '';
        element.classList.toggle('is-hidden', !show);
        element.classList.toggle('is-muted', muted && show);
      }

      function copyToClipboard(text, button) {
        if (!text) return;
        const fallbackCopy = () => {
          const textarea = document.createElement('textarea');
          textarea.value = text;
          textarea.style.position = 'fixed';
          textarea.style.opacity = '0';
          document.body.appendChild(textarea);
          textarea.focus();
          textarea.select();
          try {
            document.execCommand('copy');
            showTemporaryState(button, 'Copied!');
          } catch (error) {
            console.warn('Clipboard copy failed', error);
          }
          document.body.removeChild(textarea);
        };
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text)
            .then(() => showTemporaryState(button, 'Copied!'))
            .catch(() => fallbackCopy());
        } else {
          fallbackCopy();
        }
      }

      function showToast(message, variant = 'info', duration = 2400) {
        if (!message) return;
        const container = dom.toastContainer || document.getElementById('toast-container');
        if (!container) return;
        const toast = document.createElement('div');
        toast.className = `toast${variant ? ` is-${variant}` : ''}`;
        toast.textContent = message;
        container.appendChild(toast);
        while (container.children.length > 4) {
          container.removeChild(container.firstChild);
        }
        const hideDelay = Math.max(0, duration - 200);
        setTimeout(() => {
          toast.classList.add('is-hiding');
        }, hideDelay);
        setTimeout(() => {
          toast.remove();
        }, duration);
      }

      function showTemporaryState(button, message, duration = 1800) {
        if (!button) return;
        const originalHtml = button.dataset.originalHtml || button.innerHTML;
        if (!button.dataset.originalHtml) {
          button.dataset.originalHtml = originalHtml;
        }
        button.textContent = message;
        button.disabled = true;
        setTimeout(() => {
          button.innerHTML = button.dataset.originalHtml || originalHtml;
          button.disabled = false;
        }, duration);
      }

      function handleAddToCalendar() {
        const event = buildEventPayload();
        if (!event.startDate || !event.endDate) {
          updateCalendarStatus('Add start & end times before exporting', 'warn');
          return;
        }
        const isEditingExisting = Boolean(state && state.isEditingExisting);
        const existingSequence = isEditingExisting
          ? parseInt(String(state && state.editingExistingSequence ? state.editingExistingSequence : '').trim(), 10)
          : NaN;
        const nextSequence = Number.isFinite(existingSequence)
          ? existingSequence + 1
          : Math.floor(Date.now() / 1000);
        const icsOptions = isEditingExisting
          ? {
              method: 'REQUEST',
              sequence: nextSequence,
              lastModified: new Date()
            }
          : null;
        const icsContent = generateICS(event, icsOptions);
        logger.info('EVENT', 'Generated ICS export', {
          uid: event.uid || '',
          hasRecurrenceRule: Boolean(event.recurrence),
          hasRecurrenceId: Boolean(event.recurrenceId),
          timezone: event.timezone || browserTimezone,
          method: isEditingExisting ? 'REQUEST' : 'PUBLISH',
          previousSequence: Number.isFinite(existingSequence) ? existingSequence : null,
          nextSequence: isEditingExisting ? nextSequence : null
        });
        const filename = `${slugify(event.name || 'chunky-dad-event') || 'chunky-dad-event'}.ics`;
        const blob = new Blob([icsContent], { type: 'text/calendar' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setTimeout(() => URL.revokeObjectURL(url), 1000);
        showTemporaryState(dom.addToCalendarButton, 'ICS ready!');
      }

      function handleOpenScriptable(button) {
        const name = String(state && state.name ? state.name : '').trim();
        const startValue = sanitizeDateTimeInput(state && state.start ? state.start : '');
        if (!name || !startValue) {
          showToast('Add an event name and start time first.', 'warn');
          return;
        }
        const scriptableUrl = buildScriptableCallbackUrl();
        if (!scriptableUrl) {
          showToast('Scriptable link is missing details.', 'warn');
          return;
        }
        window.location.href = scriptableUrl;
        showTemporaryState(button, 'Opening...');
      }

      function generateICS(event, options = {}) {
        const settings = options && typeof options === 'object' ? options : {};
        const now = new Date();
        const rawMethod = typeof settings.method === 'string' ? settings.method.trim().toUpperCase() : '';
        const method = (rawMethod === 'REQUEST' || rawMethod === 'PUBLISH') ? rawMethod : 'PUBLISH';
        const sequence = Number.isFinite(settings.sequence)
          ? Math.max(1, Math.floor(settings.sequence))
          : null;
        const lastModified = settings.lastModified instanceof Date
          ? settings.lastModified
          : (sequence !== null ? now : null);
        const lines = [
          'BEGIN:VCALENDAR',
          'VERSION:2.0',
          'PRODID:-//chunky.dad//Event Builder//EN',
          'CALSCALE:GREGORIAN',
          `METHOD:${method}`,
          'BEGIN:VEVENT'
        ];
        const uidValue = String(event.uid || '').trim()
          || `${slugify(event.name || 'chunky-dad')}-${formatICSDate(new Date())}@chunky.dad`;
        const timezone = event.timezone || browserTimezone;
        const tzid = timezone ? `;TZID=${timezone}` : '';
        lines.push(`UID:${uidValue}`);
        lines.push(`DTSTAMP:${formatICSDate(now)}`);
        if (lastModified) {
          lines.push(`LAST-MODIFIED:${formatICSDate(lastModified)}`);
        }
        if (sequence !== null) {
          lines.push(`SEQUENCE:${sequence}`);
        }
        if (event.recurrenceId) {
          const recurrenceTimezone = event.recurrenceIdTimezone || timezone;
          const recurrenceTzid = recurrenceTimezone ? `;TZID=${recurrenceTimezone}` : '';
          const recurrenceValue = formatICSDateInTimezone(event.recurrenceId, recurrenceTimezone)
            || formatICSDate(event.recurrenceId);
          if (recurrenceValue) {
            lines.push(`RECURRENCE-ID${recurrenceTzid}:${recurrenceValue}`);
          }
        }
        lines.push(`DTSTART${tzid}:${formatICSDateInTimezone(event.startDate, timezone) || formatICSDate(event.startDate)}`);
        lines.push(`DTEND${tzid}:${formatICSDateInTimezone(event.endDate, timezone) || formatICSDate(event.endDate)}`);
        lines.push(`SUMMARY:${escapeICS(event.name)}`);
        const notes = formatEventNotes(event);
        if (notes) {
          lines.push(`DESCRIPTION:${escapeICS(notes)}`);
        }
        lines.push('STATUS:CONFIRMED');
        lines.push('TRANSP:OPAQUE');
        if (event.recurrence && !event.recurrenceId) {
          lines.push(`RRULE:${event.recurrence}`);
        }
        const location = (event.location || '').trim();
        if (location && parseCoordinates(location)) {
          lines.push(`LOCATION:${escapeICS(location)}`);
        }
        lines.push('END:VEVENT', 'END:VCALENDAR');
        return lines.join('\r\n');
      }

      function formatEventNotes(event) {
        if (!event || typeof event !== 'object') return '';
        const excludeFields = new Set([
          'title', 'startDate', 'endDate', 'location', 'coordinates', 'notes',
          'isBearEvent', 'source', 'city', 'setDescription', '_analysis', '_action',
          '_existingEvent', '_existingKey', '_conflicts', '_parserConfig', '_fieldPriorities',
          '_original', '_mergeInfo', '_changes', '_mergeDiff',
          'originalTitle', 'name', 'links', 'durationMinutes',
          'time', 'day', 'recurring', 'recurrence', 'url',
          'uid', 'recurrenceId', 'recurrenceIdTimezone'
        ]);
        const notes = [];
        Object.keys(event).forEach(fieldName => {
          if (excludeFields.has(fieldName)) return;
          const value = event[fieldName];
          if (value === undefined || value === null || value === '') return;
          const valueString = String(value);
          const valueForNotes = isUrlLikeField(fieldName, valueString)
            ? valueString
            : escapeText(valueString);
          notes.push(`${fieldName}: ${valueForNotes}`);
        });
        return notes.join('\n');
      }

      function isUrlLikeField(fieldName, valueString) {
        const urlFields = new Set([
          'url', 'ticketUrl', 'gmaps', 'website', 'facebook', 'instagram', 'twitter', 'image'
        ]);
        if (urlFields.has(fieldName)) return true;
        if (!valueString || typeof valueString !== 'string') return false;
        const lower = valueString.trim().toLowerCase();
        return lower.startsWith('http://') ||
          lower.startsWith('https://') ||
          lower.startsWith('mailto:') ||
          lower.startsWith('tel:') ||
          lower.startsWith('sms:');
      }

      function escapeText(text) {
        if (!text || typeof text !== 'string') {
          return text;
        }
        return text
          .replace(/\\/g, '\\\\')
          .replace(/:/g, '\\:');
      }

      function formatICSDateInTimezone(date, timeZone) {
        if (!date || !(date instanceof Date)) return '';
        if (!timeZone) return formatICSDate(date);
        try {
          const parts = new Intl.DateTimeFormat('en-US', {
            timeZone,
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false
          }).formatToParts(date);
          const values = {};
          parts.forEach(part => {
            if (part.type !== 'literal') {
              values[part.type] = part.value;
            }
          });
          if (!values.year || !values.month || !values.day) {
            return formatICSDate(date);
          }
          const hour = values.hour || '00';
          const minute = values.minute || '00';
          const second = values.second || '00';
          return `${values.year}${values.month}${values.day}T${hour}${minute}${second}`;
        } catch (error) {
          return formatICSDate(date);
        }
      }

      function formatICSDate(date) {
        return date.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
      }

      function escapeICS(value) {
        return String(value || '')
          .replace(/\\/g, '\\\\')
          .replace(/\r?\n/g, '\\n')
          .replace(/,/g, '\\,')
          .replace(/;/g, '\\;');
      }

      function slugify(value) {
        return String(value || '')
          .toLowerCase()
          .trim()
          .replace(/[\s_]+/g, '-')
          .replace(/[^\w-]+/g, '')
          .replace(/-+/g, '-')
          .replace(/^-|-$/g, '')
          .slice(0, 60);
      }
    })();
  </script>
</body>
</html>
