<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="toolbox-icon" content="üõ†Ô∏è">
  <meta name="toolbox-description" content="Build chunky.dad calendar events and preview them instantly.">
  <title>üõ†Ô∏è chunky.dad Event Builder</title>
  <link rel="stylesheet" href="../styles.css">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: light;
      --page-bg: #f4f5ff;
      --panel-bg: #ffffff;
      --text-primary: #1d2245;
      --text-secondary: #4a4f73;
      --text-muted: #7076a9;
      --accent: #6c63ff;
      --accent-strong: #5145cd;
      --border: rgba(100, 114, 170, 0.2);
      --soft: #f3f4ff;
      --chip: rgba(108, 99, 255, 0.12);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Poppins', sans-serif;
      background: var(--page-bg);
      color: var(--text-primary);
    }

    .page-wrapper {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2.5rem 1.5rem 4rem;
    }

    .hero {
      margin-bottom: 2rem;
    }

    .hero .eyebrow {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--accent);
      font-size: 0.75rem;
      font-weight: 600;
      margin-bottom: 0.4rem;
    }

    .hero h1 {
      font-size: 2.3rem;
      margin: 0 0 0.75rem;
      color: #181c35;
    }

    .hero-text {
      max-width: 760px;
      margin: 0;
      color: var(--text-secondary);
      font-size: 1rem;
      line-height: 1.6;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      gap: 2rem;
      align-items: start;
    }

    .panel {
      background: var(--panel-bg);
      border-radius: 18px;
      padding: 1.5rem;
      border: 1px solid rgba(102, 114, 172, 0.12);
      box-shadow: 0 16px 40px rgba(19, 24, 56, 0.06);
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .panel-header h2 {
      margin: 0;
      font-size: 1.3rem;
      color: var(--text-primary);
    }

    .panel-subtitle {
      margin: 0.35rem 0 0;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    details.form-section {
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 0.75rem 0.9rem;
      background: #fbfcff;
      margin-bottom: 0.9rem;
      transition: box-shadow 0.2s ease, background 0.2s ease;
    }

    details.form-section[open] {
      background: #ffffff;
      box-shadow: 0 10px 24px rgba(19, 24, 56, 0.05);
    }

    details.form-section summary {
      list-style: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-weight: 600;
      font-size: 0.95rem;
      color: #2a2f54;
    }

    details.form-section summary::-webkit-details-marker {
      display: none;
    }

    details.form-section summary::after {
      content: '‚ñæ';
      font-size: 0.9rem;
      color: var(--accent);
      transition: transform 0.2s ease;
    }

    details.form-section[open] summary::after {
      transform: rotate(180deg);
    }

    .section-body {
      margin-top: 0.7rem;
    }

    .field-grid,
    .field-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 0.9rem;
      margin-bottom: 0.9rem;
    }

    .field-group {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }

    .field-group label {
      font-weight: 600;
      font-size: 0.9rem;
      color: #2a2f54;
    }

    .field-group small {
      font-size: 0.75rem;
      color: var(--text-muted);
      line-height: 1.4;
    }

    .field-group.disabled {
      opacity: 0.55;
    }

    input[type="text"],
    input[type="url"],
    input[type="datetime-local"],
    input[type="number"],
    input[type="date"],
    select,
    textarea {
      font-family: inherit;
      font-size: 0.9rem;
      border: 1px solid rgba(112, 125, 169, 0.35);
      border-radius: 10px;
      padding: 0.55rem 0.7rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      background: #ffffff;
    }

    textarea {
      min-height: 110px;
      resize: vertical;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(108, 99, 255, 0.12);
    }

    .input-with-action {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .input-with-action input {
      flex: 1 1 auto;
    }

    .input-suffix {
      font-size: 0.82rem;
      color: var(--text-muted);
      padding: 0 0.4rem;
      white-space: nowrap;
    }

    .checkbox-label {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 500;
      color: #2a2f54;
    }

    .time-notes {
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem 0.8rem;
      margin: 0.35rem 0 0.8rem;
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    .time-note strong {
      color: #2a2f54;
      font-weight: 600;
    }

    input.is-invalid,
    textarea.is-invalid,
    select.is-invalid {
      border-color: rgba(244, 67, 54, 0.6);
      box-shadow: 0 0 0 3px rgba(244, 67, 54, 0.12);
    }

    .field-hint.is-error {
      color: #a12317;
    }

    .form-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
      margin-top: 1.2rem;
    }

    .primary-actions {
      display: flex;
      gap: 0.7rem;
      flex-wrap: wrap;
    }

    button {
      font-family: inherit;
      font-size: 0.9rem;
      padding: 0.6rem 1rem;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.65;
      transform: none;
      box-shadow: none;
    }

    .primary-button {
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      color: #ffffff;
      box-shadow: 0 12px 30px rgba(81, 69, 205, 0.28);
    }

    .primary-button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 15px 34px rgba(81, 69, 205, 0.32);
    }

    .secondary-button {
      background: #edf1ff;
      color: #3d3f68;
      border: 1px solid rgba(108, 99, 255, 0.3);
    }

    .secondary-button:hover:not(:disabled) {
      transform: translateY(-1px);
    }

    .ghost-button {
      background: rgba(108, 99, 255, 0.1);
      color: #3f47a6;
      border: 1px solid transparent;
      padding-inline: 0.85rem;
    }

    .ghost-button:hover:not(:disabled) {
      background: rgba(108, 99, 255, 0.18);
      transform: translateY(-1px);
    }

    .share-section {
      margin-top: 1.25rem;
      padding: 0.9rem;
      border-radius: 12px;
      border: 1px solid rgba(108, 99, 255, 0.2);
      background: var(--soft);
    }

    .share-section label {
      display: block;
      font-weight: 600;
      font-size: 0.85rem;
      margin-bottom: 0.4rem;
      color: #2a2f54;
    }

    .share-row {
      display: flex;
      align-items: center;
      gap: 0.7rem;
    }

    .share-row input {
      flex: 1 1 auto;
      background: #f7f8ff;
    }

    .preview-panel {
      position: sticky;
      top: 1.5rem;
    }

    .preview-toggle summary {
      list-style: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    .preview-toggle summary::-webkit-details-marker {
      display: none;
    }

    .preview-toggle summary::after {
      content: '‚ñæ';
      font-size: 0.9rem;
      color: var(--accent);
      transition: transform 0.2s ease;
    }

    .preview-toggle[open] summary::after {
      transform: rotate(180deg);
    }

    .preview-toggle .preview-card {
      margin-top: 1rem;
    }

    .preview-card {
      border-radius: 16px;
      border: 1px solid rgba(111, 118, 172, 0.12);
      background: #ffffff;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.7);
    }

    .preview-media {
      position: relative;
      height: 180px;
      background: linear-gradient(120deg, #dfe3ff, #f7f8ff);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .preview-media img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: none;
    }

    .preview-media.has-image img {
      display: block;
    }

    .preview-fallback {
      font-size: 0.85rem;
      color: #6b6f94;
    }

    .preview-body {
      padding: 1rem 1.2rem 1.2rem;
    }

    .preview-city {
      font-size: 0.72rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--accent);
    }

    .preview-title {
      margin: 0.4rem 0 0.5rem;
      font-size: 1.25rem;
      color: #181c35;
    }

    .preview-time,
    .preview-venue,
    .preview-address {
      margin: 0.2rem 0;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .preview-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-top: 0.85rem;
    }

    .chip {
      background: var(--chip);
      border: 1px solid rgba(108, 99, 255, 0.35);
      color: #3f47a6;
      padding: 0.2rem 0.55rem;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .chip.is-muted {
      background: rgba(112, 125, 169, 0.12);
      border-color: rgba(112, 125, 169, 0.3);
      color: #5a6087;
    }

    .chip.is-hidden {
      display: none;
    }

    .preview-links {
      margin-top: 0.75rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
    }

    .preview-links.is-hidden {
      display: none;
    }

    .preview-links a {
      font-size: 0.82rem;
      font-weight: 600;
      color: #3f47a6;
      text-decoration: none;
      background: rgba(108, 99, 255, 0.12);
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      border: 1px solid rgba(108, 99, 255, 0.3);
    }

    .preview-links a:hover {
      background: rgba(108, 99, 255, 0.2);
    }

    .preview-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 1.2rem;
      border-bottom: 1px solid rgba(111, 118, 172, 0.12);
      background: rgba(108, 99, 255, 0.08);
    }

    .preview-header h2 {
      margin: 0;
      font-size: 1.05rem;
      color: #1f2340;
    }

    .calendar-preview-card {
      border-radius: 16px;
      border: 1px solid rgba(111, 118, 172, 0.12);
      background: #f7f8ff;
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.7);
    }

    #calendar-preview {
      width: 100%;
      height: 480px;
      border: none;
      background: #ffffff;
    }

    .status-badge {
      font-size: 0.8rem;
      font-weight: 600;
      padding: 0.3rem 0.7rem;
      border-radius: 999px;
      border: 1px solid transparent;
    }

    .status-loading {
      background: rgba(108, 99, 255, 0.18);
      border-color: rgba(108, 99, 255, 0.35);
      color: #3f47a6;
    }

    .status-sending {
      background: rgba(255, 213, 137, 0.25);
      border-color: rgba(255, 213, 137, 0.4);
      color: #946300;
    }

    .status-ready {
      background: rgba(82, 196, 132, 0.18);
      border-color: rgba(82, 196, 132, 0.35);
      color: #146b3a;
    }

    .status-warn {
      background: rgba(255, 193, 7, 0.18);
      border-color: rgba(255, 193, 7, 0.35);
      color: #8a6200;
    }

    .status-error {
      background: rgba(244, 67, 54, 0.18);
      border-color: rgba(244, 67, 54, 0.35);
      color: #a12317;
    }

    .live-preview {
      margin-top: 2rem;
    }

    .live-preview details {
      border: none;
      padding: 0;
      background: transparent;
      box-shadow: none;
    }

    .live-preview details[open] {
      box-shadow: none;
    }

    .live-preview summary {
      font-size: 1.05rem;
    }

    .live-preview .section-body {
      margin-top: 1rem;
    }

    .is-hidden {
      display: none !important;
    }

    .recurrence-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      margin-bottom: 0.75rem;
      flex-wrap: wrap;
    }

    .toggle-buttons {
      display: inline-flex;
      background: rgba(108, 99, 255, 0.08);
      border-radius: 999px;
      padding: 0.2rem;
      gap: 0.2rem;
    }

    .toggle-button {
      border: none;
      background: transparent;
      padding: 0.35rem 0.8rem;
      border-radius: 999px;
      font-size: 0.8rem;
      font-weight: 600;
      color: #3f47a6;
      cursor: pointer;
    }

    .toggle-button.is-active {
      background: #ffffff;
      box-shadow: 0 4px 10px rgba(63, 71, 166, 0.18);
      color: #1f2340;
    }

    .day-toggle {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
    }

    .day-button {
      border: 1px solid rgba(108, 99, 255, 0.35);
      background: rgba(108, 99, 255, 0.08);
      color: #3f47a6;
      padding: 0.2rem 0.55rem;
      border-radius: 999px;
      font-size: 0.78rem;
      font-weight: 600;
      cursor: pointer;
    }

    .day-button.is-active {
      background: rgba(108, 99, 255, 0.22);
      border-color: rgba(108, 99, 255, 0.5);
    }

    .recurrence-summary {
      font-size: 0.78rem;
      color: var(--text-muted);
      margin-top: -0.35rem;
    }

    .recurrence-builder .field-row:last-of-type {
      margin-bottom: 0.6rem;
    }

    #recurrence-monthly .field-row {
      margin-bottom: 0.5rem;
    }

    #recurrence-monthly .field-row:last-child {
      margin-bottom: 0;
    }

    @media (max-width: 1080px) {
      .layout {
        grid-template-columns: 1fr;
      }

      .preview-panel {
        position: static;
      }
    }

    @media (max-width: 768px) {
      .page-wrapper {
        padding: 1.75rem 1rem 3rem;
      }

      .hero h1 {
        font-size: 2rem;
      }

      .form-actions {
        flex-direction: column;
        align-items: stretch;
      }

      .primary-actions {
        width: 100%;
      }

      .primary-actions button {
        flex: 1 1 auto;
      }

      .share-row {
        flex-direction: column;
        align-items: stretch;
      }

      details.form-section {
        padding: 0.65rem 0.75rem;
      }

      .field-grid,
      .field-row {
        grid-template-columns: 1fr;
        gap: 0.75rem;
      }

      .panel {
        padding: 1.25rem;
      }

      .preview-toggle summary::after {
        margin-left: auto;
      }
    }
  </style>
</head>
<body>
  <div class="page-wrapper">
    <header class="hero">
      <p class="eyebrow">chunky.dad toolbox</p>
      <h1>üõ†Ô∏è Event Builder</h1>
      <p class="hero-text">
        Build chunky.dad calendar events with compact sections, see updates instantly, and keep every change synced to the URL for easy sharing.
      </p>
    </header>

    <main class="layout">
      <section class="panel form-panel">
        <div class="panel-header">
          <div>
            <h2>Event Details</h2>
            <p class="panel-subtitle">Changes are saved to the URL as you type.</p>
          </div>
        </div>

        <form id="event-form">
          <details class="form-section" open>
            <summary>Basics</summary>
            <div class="section-body">
              <div class="field-grid">
                <div class="field-group">
                  <label for="event-name">Event Name</label>
                  <input type="text" id="event-name" autocomplete="off" placeholder="Bearracuda Chicago">
                </div>
                <div class="field-group">
                  <label for="event-short-name">Card Short Name</label>
                  <input type="text" id="event-short-name" autocomplete="off" placeholder="Bearracuda">
                  <small>Used when the calendar needs a shorter label.</small>
                </div>
                <div class="field-group">
                  <label for="event-city">City</label>
                  <select id="event-city"></select>
                </div>
                <div class="field-group">
                  <label for="event-venue">Venue</label>
                  <input type="text" id="event-venue" autocomplete="off" placeholder="The Eagle NYC">
                </div>
                <div class="field-group">
                  <label for="event-address">Address</label>
                  <input type="text" id="event-address" autocomplete="off" placeholder="554 W 28th St, New York, NY">
                </div>
                <div class="field-group">
                  <label for="event-coordinates">Coordinates (lat, lng)</label>
                  <input type="text" id="event-coordinates" autocomplete="off" placeholder="40.7497, -73.9943">
                  <small class="field-hint" data-default="Use latitude, longitude from Google Maps.">Use latitude, longitude from Google Maps.</small>
                </div>
                <div class="field-group">
                  <label for="event-cover">Cover / Price</label>
                  <input type="text" id="event-cover" autocomplete="off" placeholder="Free / $15 / Cover TBD">
                </div>
                <div class="field-group">
                  <label for="event-image">Promo Image URL</label>
                  <input type="url" id="event-image" placeholder="https://chunky.dad/img/events/sample.jpg">
                </div>
              </div>

              <div class="field-group">
                <label for="event-description">Tea / Description</label>
                <textarea id="event-description" placeholder="Chunky bears takeover with DJs, go-go cubs, and midnight surprises."></textarea>
              </div>
            </div>
          </details>

          <details class="form-section">
            <summary>Time &amp; Recurrence</summary>
            <div class="section-body">
              <div class="field-row">
                <div class="field-group">
                  <label for="event-start">Start</label>
                  <input type="datetime-local" id="event-start">
                </div>
                <div class="field-group">
                  <label for="event-end">End</label>
                  <input type="datetime-local" id="event-end">
                </div>
              </div>

              <div class="time-notes">
                <span class="time-note" id="duration-note"><strong>Duration:</strong> Add start &amp; end</span>
                <span class="time-note" id="timezone-note"><strong>Local timezone:</strong> </span>
              </div>

              <div class="recurrence-toggle">
                <div class="field-group">
                  <label>Recurrence</label>
                  <small>Optional ‚Äî leave as ‚ÄúDoes not repeat‚Äù.</small>
                </div>
                <div class="toggle-buttons" role="group" aria-label="Recurrence input mode">
                  <button type="button" class="toggle-button is-active" data-recurrence-mode="builder">Builder</button>
                  <button type="button" class="toggle-button" data-recurrence-mode="raw">Raw RRULE</button>
                </div>
              </div>

              <div class="recurrence-builder" id="recurrence-builder">
                <div class="field-row">
                  <div class="field-group">
                    <label for="recurrence-frequency">Repeats</label>
                    <select id="recurrence-frequency">
                      <option value="none">Does not repeat</option>
                      <option value="daily">Daily</option>
                      <option value="weekly">Weekly</option>
                      <option value="monthly">Monthly</option>
                    </select>
                  </div>
                  <div class="field-group">
                    <label for="recurrence-interval">Every</label>
                    <div class="input-with-action">
                      <input type="number" id="recurrence-interval" min="1" value="1">
                      <span class="input-suffix" id="recurrence-interval-label">week(s)</span>
                    </div>
                  </div>
                </div>

                <div class="field-row" id="recurrence-weekly">
                  <div class="field-group">
                    <label>Repeat on</label>
                    <div class="day-toggle" id="recurrence-weekdays">
                      <button type="button" class="day-button" data-day="MO">Mon</button>
                      <button type="button" class="day-button" data-day="TU">Tue</button>
                      <button type="button" class="day-button" data-day="WE">Wed</button>
                      <button type="button" class="day-button" data-day="TH">Thu</button>
                      <button type="button" class="day-button" data-day="FR">Fri</button>
                      <button type="button" class="day-button" data-day="SA">Sat</button>
                      <button type="button" class="day-button" data-day="SU">Sun</button>
                    </div>
                  </div>
                </div>

                <div class="field-row" id="recurrence-monthly">
                  <div class="field-group">
                    <label>Monthly pattern</label>
                    <div class="field-row">
                      <label class="checkbox-label">
                        <input type="radio" name="recurrence-monthly-mode" value="monthday" checked>
                        <span>On day</span>
                      </label>
                      <input type="number" id="recurrence-monthday" min="1" max="31" placeholder="15">
                    </div>
                    <div class="field-row">
                      <label class="checkbox-label">
                        <input type="radio" name="recurrence-monthly-mode" value="weekday">
                        <span>On the</span>
                      </label>
                      <div class="input-with-action">
                        <select id="recurrence-week-pos">
                          <option value="1">First</option>
                          <option value="2">Second</option>
                          <option value="3">Third</option>
                          <option value="4">Fourth</option>
                          <option value="-1">Last</option>
                        </select>
                        <select id="recurrence-weekday">
                          <option value="MO">Monday</option>
                          <option value="TU">Tuesday</option>
                          <option value="WE">Wednesday</option>
                          <option value="TH">Thursday</option>
                          <option value="FR">Friday</option>
                          <option value="SA">Saturday</option>
                          <option value="SU">Sunday</option>
                        </select>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="field-row" id="recurrence-ends-row">
                  <div class="field-group">
                    <label for="recurrence-ends">Ends</label>
                    <select id="recurrence-ends">
                      <option value="never">Never</option>
                      <option value="count">After # times</option>
                      <option value="until">On date</option>
                    </select>
                  </div>
                  <div class="field-group is-hidden" id="recurrence-count-group">
                    <label for="recurrence-count">After</label>
                    <input type="number" id="recurrence-count" min="1" placeholder="10">
                  </div>
                  <div class="field-group is-hidden" id="recurrence-until-group">
                    <label for="recurrence-until">On date</label>
                    <input type="date" id="recurrence-until">
                  </div>
                </div>
              </div>

              <div id="recurrence-raw" class="is-hidden">
                <div class="field-group">
                  <label for="event-recurrence">RRULE (raw)</label>
                  <input type="text" id="event-recurrence" placeholder="FREQ=WEEKLY;BYDAY=FR">
                  <small class="field-hint" data-default="Paste a full RRULE string.">Paste a full RRULE string.</small>
                </div>
              </div>

              <p class="recurrence-summary" id="recurrence-summary">Does not repeat.</p>
            </div>
          </details>

          <details class="form-section">
            <summary>Links</summary>
            <div class="section-body">
              <div class="field-grid">
                <div class="field-group">
                  <label for="event-website">Website</label>
                  <input type="text" id="event-website" placeholder="https://bearracuda.com">
                  <small class="field-hint" data-default="Auto-adds https:// when missing.">Auto-adds https:// when missing.</small>
                </div>
                <div class="field-group">
                  <label for="event-ticket-url">Tickets</label>
                  <input type="text" id="event-ticket-url" placeholder="https://tickets.example.com">
                  <small class="field-hint" data-default="Paste the ticket link.">Paste the ticket link.</small>
                </div>
                <div class="field-group">
                  <label for="event-instagram">Instagram</label>
                  <input type="text" id="event-instagram" placeholder="@bearracuda or instagram.com/bearracuda">
                  <small class="field-hint" data-default="Handles auto-expand to full links.">Handles auto-expand to full links.</small>
                </div>
                <div class="field-group">
                  <label for="event-facebook">Facebook</label>
                  <input type="text" id="event-facebook" placeholder="facebook.com/bearracuda">
                  <small class="field-hint" data-default="Paste a page or event URL.">Paste a page or event URL.</small>
                </div>
                <div class="field-group">
                  <label for="event-gmaps">Google Maps</label>
                  <input type="text" id="event-gmaps" placeholder="https://maps.app.goo.gl/...">
                  <small class="field-hint" data-default="Paste a Google Maps link.">Paste a Google Maps link.</small>
                </div>
              </div>
            </div>
          </details>

          <div class="form-actions">
            <button type="button" class="ghost-button" id="reset-form">Reset to defaults</button>
            <div class="primary-actions">
              <button type="button" class="primary-button" id="add-to-calendar">Add to calendar</button>
              <button type="button" class="secondary-button" id="copy-link">Copy share link</button>
            </div>
          </div>
        </form>

        <div class="share-section">
          <label for="share-url">Shareable URL</label>
          <div class="share-row">
            <input type="text" id="share-url" readonly>
          </div>
        </div>
      </section>

      <aside class="panel preview-panel">
        <details class="preview-toggle" open>
          <summary class="panel-header">
            <div>
              <h2>Live Preview</h2>
              <p class="panel-subtitle">Updates instantly as you type.</p>
            </div>
          </summary>

          <div class="preview-card">
            <div class="preview-media" id="preview-media">
              <img id="preview-image" alt="" loading="lazy">
              <div class="preview-fallback">Add a promo image to preview artwork.</div>
            </div>
            <div class="preview-body">
              <div class="preview-city" id="preview-city">City</div>
              <h3 class="preview-title" id="preview-title">Untitled event</h3>
              <p class="preview-time" id="preview-time">Add start and end times to preview timing.</p>
              <p class="preview-venue" id="preview-venue">Venue TBA</p>
              <p class="preview-address" id="preview-address">Address TBD</p>
              <div class="preview-chips">
                <span class="chip" id="preview-duration">Duration TBD</span>
                <span class="chip is-muted" id="preview-timezone">TZ</span>
                <span class="chip is-hidden" id="preview-recurring">Recurring</span>
                <span class="chip is-hidden" id="preview-cover">Cover</span>
              </div>
              <div class="preview-links is-hidden" id="preview-links"></div>
            </div>
          </div>
        </details>
      </aside>
    </main>

    <section class="panel live-preview">
      <details id="live-preview" class="form-section">
        <summary>Live calendar preview (optional)</summary>
        <div class="section-body">
          <div class="calendar-preview-card">
            <div class="preview-header">
              <h2>Calendar Preview</h2>
              <span id="calendar-status" class="status-badge status-loading">Loading calendar‚Ä¶</span>
            </div>
            <iframe id="calendar-preview" title="chunky.dad calendar preview" src="../city.html?city=nyc"></iframe>
          </div>
        </div>
      </details>
    </section>
  </div>

  <script src="../js/city-config.js"></script>
  <script>
    (() => {
      const DEFAULT_DURATION_MINUTES = 240;
      const URL_UPDATE_DELAY = 120;
      const EVENT_PUSH_DELAY = 200;
      const browserTimezone = (Intl.DateTimeFormat().resolvedOptions().timeZone) || 'UTC';
      const DAY_CODE_LABELS = {
        MO: 'Mon',
        TU: 'Tue',
        WE: 'Wed',
        TH: 'Thu',
        FR: 'Fri',
        SA: 'Sat',
        SU: 'Sun'
      };
      const WEEK_POSITION_LABELS = {
        '1': 'First',
        '2': 'Second',
        '3': 'Third',
        '4': 'Fourth',
        '-1': 'Last'
      };

      const dom = {};
      let state;
      let recurrenceMode = 'builder';
      let isRecurrenceSyncing = false;
      let calendarReady = false;
      let iframeLoaded = false;
      let sendTimeoutId = null;
      let urlTimeoutId = null;
      let currentCalendarCity = null;

      document.addEventListener('DOMContentLoaded', init);

      function init() {
        cacheDom();
        populateCityOptions();
        const baseState = createDefaultState();
        const urlState = loadStateFromUrl(baseState);
        state = { ...baseState, ...urlState.overrides };
        state.timezone = browserTimezone;
        normalizeStateLinks();
        ensureDateOrder();
        applyStateToForm();
        bindEvents();
        updateRecurrenceUi();
        updateTimeNotes();
        updatePreviewCard();
        updateUrl();
        updateCalendarSource(true);
        setupMessaging();
        scheduleEventPush();
      }

      function cacheDom() {
        dom.form = document.getElementById('event-form');
        dom.nameInput = document.getElementById('event-name');
        dom.shortNameInput = document.getElementById('event-short-name');
        dom.citySelect = document.getElementById('event-city');
        dom.venueInput = document.getElementById('event-venue');
        dom.addressInput = document.getElementById('event-address');
        dom.coordinatesInput = document.getElementById('event-coordinates');
        dom.descriptionInput = document.getElementById('event-description');
        dom.coverInput = document.getElementById('event-cover');
        dom.startInput = document.getElementById('event-start');
        dom.endInput = document.getElementById('event-end');
        dom.durationNote = document.getElementById('duration-note');
        dom.timezoneNote = document.getElementById('timezone-note');
        dom.recurrenceModeButtons = document.querySelectorAll('[data-recurrence-mode]');
        dom.recurrenceBuilder = document.getElementById('recurrence-builder');
        dom.recurrenceRaw = document.getElementById('recurrence-raw');
        dom.recurrenceFrequency = document.getElementById('recurrence-frequency');
        dom.recurrenceInterval = document.getElementById('recurrence-interval');
        dom.recurrenceIntervalLabel = document.getElementById('recurrence-interval-label');
        dom.recurrenceWeekdays = document.getElementById('recurrence-weekdays');
        dom.recurrenceWeekdayButtons = document.querySelectorAll('#recurrence-weekdays .day-button');
        dom.recurrenceMonthlyMode = document.querySelectorAll('input[name="recurrence-monthly-mode"]');
        dom.recurrenceMonthday = document.getElementById('recurrence-monthday');
        dom.recurrenceWeekPos = document.getElementById('recurrence-week-pos');
        dom.recurrenceWeekday = document.getElementById('recurrence-weekday');
        dom.recurrenceWeeklyRow = document.getElementById('recurrence-weekly');
        dom.recurrenceMonthlyRow = document.getElementById('recurrence-monthly');
        dom.recurrenceEndsRow = document.getElementById('recurrence-ends-row');
        dom.recurrenceEnds = document.getElementById('recurrence-ends');
        dom.recurrenceCountGroup = document.getElementById('recurrence-count-group');
        dom.recurrenceUntilGroup = document.getElementById('recurrence-until-group');
        dom.recurrenceCount = document.getElementById('recurrence-count');
        dom.recurrenceUntil = document.getElementById('recurrence-until');
        dom.recurrenceSummary = document.getElementById('recurrence-summary');
        dom.recurrenceInput = document.getElementById('event-recurrence');
        dom.websiteInput = document.getElementById('event-website');
        dom.ticketUrlInput = document.getElementById('event-ticket-url');
        dom.instagramInput = document.getElementById('event-instagram');
        dom.facebookInput = document.getElementById('event-facebook');
        dom.gmapsInput = document.getElementById('event-gmaps');
        dom.imageInput = document.getElementById('event-image');
        dom.resetButton = document.getElementById('reset-form');
        dom.addToCalendarButton = document.getElementById('add-to-calendar');
        dom.copyShareButton = document.getElementById('copy-link');
        dom.shareUrl = document.getElementById('share-url');
        dom.calendarIframe = document.getElementById('calendar-preview');
        dom.calendarStatus = document.getElementById('calendar-status');
        dom.previewMedia = document.getElementById('preview-media');
        dom.previewImage = document.getElementById('preview-image');
        dom.previewCity = document.getElementById('preview-city');
        dom.previewTitle = document.getElementById('preview-title');
        dom.previewTime = document.getElementById('preview-time');
        dom.previewVenue = document.getElementById('preview-venue');
        dom.previewAddress = document.getElementById('preview-address');
        dom.previewDuration = document.getElementById('preview-duration');
        dom.previewTimezone = document.getElementById('preview-timezone');
        dom.previewRecurring = document.getElementById('preview-recurring');
        dom.previewCover = document.getElementById('preview-cover');
        dom.previewLinks = document.getElementById('preview-links');
      }

      function populateCityOptions() {
        if (!dom.citySelect) return;
        let cities = [];
        if (typeof getAvailableCities === 'function') {
          cities = getAvailableCities();
        } else if (typeof CITY_CONFIG === 'object' && CITY_CONFIG) {
          cities = Object.keys(CITY_CONFIG).map(key => ({
            key,
            ...CITY_CONFIG[key]
          }));
        } else {
          const fallbackCities = ['nyc'];
          cities = fallbackCities.map(key => ({
            key,
            name: key.replace(/-/g, ' ').replace(/\b\w/g, char => char.toUpperCase())
          }));
        }
        cities.sort((a, b) => {
          const nameA = (a.name || a.key || '').toLowerCase();
          const nameB = (b.name || b.key || '').toLowerCase();
          return nameA.localeCompare(nameB);
        });
        dom.citySelect.innerHTML = '';
        cities.forEach(city => {
          const option = document.createElement('option');
          option.value = city.key;
          option.textContent = city.emoji ? `${city.emoji} ${city.name}` : city.name || city.key;
          dom.citySelect.appendChild(option);
        });
      }

      function createDefaultState() {
        const defaultCity = 'nyc';
        const start = computeDefaultStart();
        const end = new Date(start.getTime() + DEFAULT_DURATION_MINUTES * 60000);
        return {
          name: 'Bearracuda Preview Night',
          shortName: 'Bearracuda',
          city: defaultCity,
          venue: 'The Eagle NYC',
          address: '554 W 28th St, New York, NY',
          location: '',
          description: 'Preview your chunky.dad event before it goes live.',
          cover: '',
          start: formatInputValue(start),
          end: formatInputValue(end),
          timezone: browserTimezone,
          recurrence: '',
          website: '',
          ticketUrl: '',
          instagram: '',
          facebook: '',
          gmaps: '',
          image: ''
        };
      }

      function computeDefaultStart() {
        const now = new Date();
        const start = new Date(now);
        const day = start.getDay();
        const daysUntilFriday = ((5 - day + 7) % 7) || 7;
        start.setDate(start.getDate() + daysUntilFriday);
        start.setHours(21, 0, 0, 0);
        return start;
      }

      function loadStateFromUrl(baseState) {
        const params = new URLSearchParams(window.location.search);
        const overrides = {};
        params.forEach((value, key) => {
          if (value == null || value === '') return;
          switch (key) {
            case 'name':
              overrides.name = value;
              break;
            case 'short':
              overrides.shortName = value;
              break;
            case 'city':
              overrides.city = value;
              break;
            case 'venue':
              overrides.venue = value;
              break;
            case 'addr':
              overrides.address = value;
              break;
            case 'coords':
            case 'loc':
            case 'location':
              overrides.location = value;
              break;
            case 'desc':
              overrides.description = value;
              break;
            case 'cover':
              overrides.cover = value;
              break;
            case 'start': {
              const sanitized = sanitizeDateTimeInput(value);
              if (sanitized) overrides.start = sanitized;
              break;
            }
            case 'end': {
              const sanitizedEnd = sanitizeDateTimeInput(value);
              if (sanitizedEnd) overrides.end = sanitizedEnd;
              break;
            }
            case 'rrule':
              overrides.recurrence = value;
              break;
            case 'web':
              overrides.website = value;
              break;
            case 'tickets':
            case 'ticket':
              overrides.ticketUrl = value;
              break;
            case 'insta':
            case 'instagram':
              overrides.instagram = value;
              break;
            case 'fb':
            case 'facebook':
              overrides.facebook = value;
              break;
            case 'gmaps':
            case 'map':
              overrides.gmaps = value;
              break;
            case 'img':
              overrides.image = value;
              break;
            default:
              break;
          }
        });
        if (!overrides.start) overrides.start = baseState.start;
        if (!overrides.end) overrides.end = baseState.end;
        if (!overrides.city) overrides.city = baseState.city;
        return { overrides };
      }

      function applyStateToForm() {
        if (dom.nameInput) dom.nameInput.value = state.name || '';
        if (dom.shortNameInput) dom.shortNameInput.value = state.shortName || '';
        if (dom.citySelect) {
          if (![...dom.citySelect.options].some(option => option.value === state.city)) {
            state.city = dom.citySelect.options.length ? dom.citySelect.options[0].value : 'nyc';
          }
          dom.citySelect.value = state.city;
        }
        if (dom.venueInput) dom.venueInput.value = state.venue || '';
        if (dom.addressInput) dom.addressInput.value = state.address || '';
        if (dom.coordinatesInput) dom.coordinatesInput.value = state.location || '';
        if (dom.descriptionInput) dom.descriptionInput.value = state.description || '';
        if (dom.coverInput) dom.coverInput.value = state.cover || '';
        if (dom.startInput) dom.startInput.value = state.start || '';
        if (dom.endInput) dom.endInput.value = state.end || '';
        if (dom.recurrenceInput) dom.recurrenceInput.value = state.recurrence || '';
        if (dom.websiteInput) dom.websiteInput.value = state.website || '';
        if (dom.ticketUrlInput) dom.ticketUrlInput.value = state.ticketUrl || '';
        if (dom.instagramInput) dom.instagramInput.value = state.instagram || '';
        if (dom.facebookInput) dom.facebookInput.value = state.facebook || '';
        if (dom.gmapsInput) dom.gmapsInput.value = state.gmaps || '';
        if (dom.imageInput) dom.imageInput.value = state.image || '';
        updateTimeNotes();
        applyRecurrenceStateToForm();
        syncLinkFieldStates();
        updateCoordinatesFieldState();
      }

      function bindEvents() {
        if (dom.form) {
          dom.form.addEventListener('submit', event => event.preventDefault());
        }
        if (dom.nameInput) {
          dom.nameInput.addEventListener('input', event => {
            state.name = event.target.value;
            refreshUi();
          });
        }
        if (dom.shortNameInput) {
          dom.shortNameInput.addEventListener('input', event => {
            state.shortName = event.target.value;
            refreshUi();
          });
        }
        if (dom.citySelect) {
          dom.citySelect.addEventListener('change', event => {
            const newCity = event.target.value;
            state.city = newCity;
            updateCalendarSource();
            refreshUi();
          });
        }
        if (dom.venueInput) {
          dom.venueInput.addEventListener('input', event => {
            state.venue = event.target.value;
            refreshUi();
          });
        }
        if (dom.addressInput) {
          dom.addressInput.addEventListener('input', event => {
            state.address = event.target.value;
            refreshUi();
          });
        }
        if (dom.coordinatesInput) {
          dom.coordinatesInput.addEventListener('input', event => {
            state.location = event.target.value;
            updateCoordinatesFieldState();
            refreshUi();
          });
        }
        if (dom.descriptionInput) {
          dom.descriptionInput.addEventListener('input', event => {
            state.description = event.target.value;
            refreshUi();
          });
        }
        if (dom.coverInput) {
          dom.coverInput.addEventListener('input', event => {
            state.cover = event.target.value;
            refreshUi();
          });
        }
        if (dom.startInput) {
          const handler = event => {
            const sanitized = sanitizeDateTimeInput(event.target.value);
            if (!sanitized) {
              event.target.value = state.start;
              return;
            }
            state.start = sanitized;
            refreshUi();
          };
          dom.startInput.addEventListener('change', handler);
          dom.startInput.addEventListener('input', handler);
        }
        if (dom.endInput) {
          const handler = event => {
            const sanitized = sanitizeDateTimeInput(event.target.value);
            if (!sanitized) {
              event.target.value = state.end;
              return;
            }
            state.end = sanitized;
            refreshUi();
          };
          dom.endInput.addEventListener('change', handler);
          dom.endInput.addEventListener('input', handler);
        }
        if (dom.recurrenceInput) {
          dom.recurrenceInput.addEventListener('input', event => {
            state.recurrence = event.target.value.trim();
            updateRecurrenceSummary();
            refreshUi();
          });
        }
        if (dom.recurrenceModeButtons && dom.recurrenceModeButtons.length) {
          dom.recurrenceModeButtons.forEach(button => {
            button.addEventListener('click', () => {
              const mode = button.dataset.recurrenceMode;
              if (mode) {
                setRecurrenceMode(mode);
              }
            });
          });
        }
        if (dom.recurrenceFrequency) {
          dom.recurrenceFrequency.addEventListener('change', () => {
            handleRecurrenceBuilderChange();
          });
        }
        if (dom.recurrenceInterval) {
          dom.recurrenceInterval.addEventListener('input', () => {
            handleRecurrenceBuilderChange();
          });
        }
        if (dom.recurrenceWeekdayButtons && dom.recurrenceWeekdayButtons.length) {
          dom.recurrenceWeekdayButtons.forEach(button => {
            button.addEventListener('click', () => {
              toggleRecurrenceDay(button);
              handleRecurrenceBuilderChange();
            });
          });
        }
        if (dom.recurrenceMonthlyMode && dom.recurrenceMonthlyMode.length) {
          dom.recurrenceMonthlyMode.forEach(input => {
            input.addEventListener('change', () => {
              handleRecurrenceBuilderChange();
            });
          });
        }
        if (dom.recurrenceMonthday) {
          dom.recurrenceMonthday.addEventListener('input', () => {
            handleRecurrenceBuilderChange();
          });
        }
        if (dom.recurrenceWeekPos) {
          dom.recurrenceWeekPos.addEventListener('change', () => {
            handleRecurrenceBuilderChange();
          });
        }
        if (dom.recurrenceWeekday) {
          dom.recurrenceWeekday.addEventListener('change', () => {
            handleRecurrenceBuilderChange();
          });
        }
        if (dom.recurrenceEnds) {
          dom.recurrenceEnds.addEventListener('change', () => {
            updateRecurrenceUi();
            handleRecurrenceBuilderChange();
          });
        }
        if (dom.recurrenceCount) {
          dom.recurrenceCount.addEventListener('input', () => {
            handleRecurrenceBuilderChange();
          });
        }
        if (dom.recurrenceUntil) {
          dom.recurrenceUntil.addEventListener('input', () => {
            handleRecurrenceBuilderChange();
          });
        }
        bindLinkField(dom.websiteInput, 'website', 'website');
        bindLinkField(dom.ticketUrlInput, 'ticketUrl', 'tickets');
        bindLinkField(dom.instagramInput, 'instagram', 'instagram');
        bindLinkField(dom.facebookInput, 'facebook', 'facebook');
        bindLinkField(dom.gmapsInput, 'gmaps', 'gmaps');
        if (dom.imageInput) {
          dom.imageInput.addEventListener('input', event => {
            state.image = event.target.value;
            refreshUi();
          });
        }
        if (dom.resetButton) {
          dom.resetButton.addEventListener('click', resetForm);
        }
        if (dom.copyShareButton) {
          dom.copyShareButton.addEventListener('click', () => {
            copyToClipboard(dom.shareUrl ? dom.shareUrl.value : '', dom.copyShareButton);
          });
        }
        if (dom.addToCalendarButton) {
          dom.addToCalendarButton.addEventListener('click', handleAddToCalendar);
        }
      }

      function bindLinkField(input, stateKey, linkType) {
        if (!input) return;
        const handleInput = () => {
          const result = normalizeLinkValue(linkType, input.value);
          state[stateKey] = result.value;
          updateLinkFieldState(input, result);
          refreshUi();
        };
        input.addEventListener('input', handleInput);
        input.addEventListener('blur', () => {
          const result = normalizeLinkValue(linkType, input.value);
          state[stateKey] = result.value;
          updateLinkFieldState(input, result);
          if (result.value && input.value.trim() !== result.value) {
            input.value = result.value;
          }
          refreshUi();
        });
      }

      function normalizeStateLinks() {
        state.website = normalizeLinkValue('website', state.website).value;
        state.ticketUrl = normalizeLinkValue('tickets', state.ticketUrl).value;
        state.instagram = normalizeLinkValue('instagram', state.instagram).value;
        state.facebook = normalizeLinkValue('facebook', state.facebook).value;
        state.gmaps = normalizeLinkValue('gmaps', state.gmaps).value;
      }

      function normalizeLinkValue(type, rawValue) {
        const trimmed = String(rawValue || '').trim();
        if (!trimmed) {
          return { value: '', error: '' };
        }
        switch (type) {
          case 'instagram':
            return normalizeInstagramLink(trimmed);
          case 'facebook':
            return normalizeFacebookLink(trimmed);
          default:
            return normalizeUrlLink(trimmed);
        }
      }

      function normalizeUrlLink(value) {
        const normalized = addProtocolIfMissing(value);
        try {
          const url = new URL(normalized);
          if (!['http:', 'https:'].includes(url.protocol)) {
            return { value: '', error: 'Use an http(s) link.' };
          }
          return { value: url.toString(), error: '' };
        } catch (error) {
          return { value: '', error: 'Enter a valid URL.' };
        }
      }

      function normalizeInstagramLink(value) {
        const hasDomain = /instagram\.com|instagr\.am/i.test(value);
        const hasProtocol = /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(value);
        if (hasDomain || hasProtocol) {
          if (!hasDomain) {
            return { value: '', error: 'Use an Instagram link or handle.' };
          }
          return normalizeUrlLink(addProtocolIfMissing(value));
        }
        let handle = value.replace(/^@/, '').trim();
        handle = handle.split(/[/?#]/)[0];
        if (!handle) {
          return { value: '', error: 'Instagram handle is missing.' };
        }
        if (!/^[A-Za-z0-9._]+$/.test(handle)) {
          return { value: '', error: 'Use letters, numbers, periods, or underscores.' };
        }
        return { value: `https://www.instagram.com/${handle}`, error: '' };
      }

      function normalizeFacebookLink(value) {
        const hasDomain = /facebook\.com|fb\.com|fb\.me/i.test(value);
        const hasProtocol = /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(value);
        if (hasDomain || hasProtocol) {
          if (!hasDomain) {
            return { value: '', error: 'Use a Facebook link or handle.' };
          }
          return normalizeUrlLink(addProtocolIfMissing(value));
        }
        let handle = value.replace(/^@/, '').trim();
        handle = handle.split(/[/?#]/)[0];
        if (!handle) {
          return { value: '', error: 'Facebook handle is missing.' };
        }
        if (!/^[A-Za-z0-9.-]+$/.test(handle)) {
          return { value: '', error: 'Use letters, numbers, periods, or dashes.' };
        }
        return { value: `https://www.facebook.com/${handle}`, error: '' };
      }

      function addProtocolIfMissing(value) {
        const trimmed = value.trim();
        if (/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(trimmed)) {
          return trimmed;
        }
        if (trimmed.startsWith('//')) {
          return `https:${trimmed}`;
        }
        return `https://${trimmed}`;
      }

      function updateLinkFieldState(input, result) {
        if (!input) return;
        const hasError = Boolean(result.error);
        input.classList.toggle('is-invalid', hasError);
        if (hasError) {
          input.setAttribute('aria-invalid', 'true');
        } else {
          input.removeAttribute('aria-invalid');
        }
        const hint = getFieldHint(input);
        setFieldHint(hint, hasError ? result.error : '', hasError);
      }

      function getFieldHint(input) {
        const group = input ? input.closest('.field-group') : null;
        if (!group) return null;
        return group.querySelector('.field-hint');
      }

      function setFieldHint(hint, message, isError) {
        if (!hint) return;
        if (!hint.dataset.default) {
          hint.dataset.default = hint.textContent || '';
        }
        if (message) {
          hint.textContent = message;
          hint.classList.toggle('is-error', Boolean(isError));
        } else {
          hint.textContent = hint.dataset.default || '';
          hint.classList.remove('is-error');
        }
      }

      function syncLinkFieldStates() {
        updateLinkFieldState(dom.websiteInput, normalizeLinkValue('website', dom.websiteInput ? dom.websiteInput.value : ''));
        updateLinkFieldState(dom.ticketUrlInput, normalizeLinkValue('tickets', dom.ticketUrlInput ? dom.ticketUrlInput.value : ''));
        updateLinkFieldState(dom.instagramInput, normalizeLinkValue('instagram', dom.instagramInput ? dom.instagramInput.value : ''));
        updateLinkFieldState(dom.facebookInput, normalizeLinkValue('facebook', dom.facebookInput ? dom.facebookInput.value : ''));
        updateLinkFieldState(dom.gmapsInput, normalizeLinkValue('gmaps', dom.gmapsInput ? dom.gmapsInput.value : ''));
      }

      function resetForm() {
        const preservedCity = state.city;
        state = createDefaultState();
        state.city = preservedCity;
        recurrenceMode = 'builder';
        applyStateToForm();
        refreshUi();
        scheduleEventPush();
      }

      function updateCoordinatesFieldState() {
        if (!dom.coordinatesInput) return;
        const rawValue = dom.coordinatesInput.value.trim();
        const hint = getFieldHint(dom.coordinatesInput);
        if (!rawValue) {
          dom.coordinatesInput.classList.remove('is-invalid');
          dom.coordinatesInput.removeAttribute('aria-invalid');
          setFieldHint(hint, '', false);
          return;
        }
        const parsed = parseCoordinates(rawValue);
        const hasError = !parsed;
        dom.coordinatesInput.classList.toggle('is-invalid', hasError);
        if (hasError) {
          dom.coordinatesInput.setAttribute('aria-invalid', 'true');
          setFieldHint(hint, 'Use "lat, lng" like 40.7497, -73.9943.', true);
        } else {
          dom.coordinatesInput.removeAttribute('aria-invalid');
          setFieldHint(hint, '', false);
        }
      }

      function applyRecurrenceStateToForm() {
        const startDate = parseLocalDateTime(state.start, state.timezone);
        const fallback = getDefaultRecurrenceBuilder(startDate);
        if (state.recurrence) {
          const parsed = parseRruleToBuilder(state.recurrence, fallback);
          if (parsed) {
            applyRecurrenceBuilderState(parsed);
            recurrenceMode = 'builder';
          } else {
            applyRecurrenceBuilderState(fallback);
            recurrenceMode = 'raw';
          }
        } else {
          applyRecurrenceBuilderState(fallback);
          recurrenceMode = 'builder';
        }
        if (dom.recurrenceInput) {
          dom.recurrenceInput.value = state.recurrence || '';
        }
        setRecurrenceMode(recurrenceMode, { silent: true, force: true });
        updateRecurrenceUi();
        updateRecurrenceSummary();
      }

      function setRecurrenceMode(mode, options = {}) {
        const nextMode = mode === 'raw' ? 'raw' : 'builder';
        if (recurrenceMode === nextMode && !options.force) {
          return;
        }
        recurrenceMode = nextMode;
        if (!options.silent) {
          if (recurrenceMode === 'builder') {
            const rawValue = dom.recurrenceInput ? dom.recurrenceInput.value.trim() : '';
            if (rawValue) {
              const parsed = parseRruleToBuilder(rawValue);
              if (parsed) {
                applyRecurrenceBuilderState(parsed);
                state.recurrence = rawValue;
              }
            }
          } else {
            state.recurrence = buildRruleFromBuilder();
            if (dom.recurrenceInput) {
              dom.recurrenceInput.value = state.recurrence;
            }
          }
          refreshUi();
        }
        if (dom.recurrenceModeButtons && dom.recurrenceModeButtons.length) {
          dom.recurrenceModeButtons.forEach(button => {
            button.classList.toggle('is-active', button.dataset.recurrenceMode === recurrenceMode);
          });
        }
        updateRecurrenceUi();
        updateRecurrenceSummary();
      }

      function updateRecurrenceUi() {
        const frequency = dom.recurrenceFrequency ? dom.recurrenceFrequency.value : 'none';
        const showWeekly = frequency === 'weekly';
        const showMonthly = frequency === 'monthly';
        const showEnds = frequency !== 'none';
        if (dom.recurrenceWeeklyRow) {
          dom.recurrenceWeeklyRow.classList.toggle('is-hidden', !showWeekly);
        }
        if (dom.recurrenceMonthlyRow) {
          dom.recurrenceMonthlyRow.classList.toggle('is-hidden', !showMonthly);
        }
        if (dom.recurrenceBuilder) {
          dom.recurrenceBuilder.classList.toggle('is-hidden', recurrenceMode !== 'builder');
        }
        if (dom.recurrenceRaw) {
          dom.recurrenceRaw.classList.toggle('is-hidden', recurrenceMode !== 'raw');
        }
        if (dom.recurrenceIntervalLabel) {
          const label = frequency === 'daily'
            ? 'day(s)'
            : frequency === 'monthly'
              ? 'month(s)'
              : 'week(s)';
          dom.recurrenceIntervalLabel.textContent = label;
        }
        if (dom.recurrenceInterval) {
          dom.recurrenceInterval.disabled = frequency === 'none';
        }
        if (dom.recurrenceEndsRow) {
          dom.recurrenceEndsRow.classList.toggle('is-hidden', !showEnds);
        }
        if (dom.recurrenceEnds) {
          dom.recurrenceEnds.disabled = !showEnds;
        }
        if (dom.recurrenceEnds) {
          const endsValue = dom.recurrenceEnds.value || 'never';
          if (dom.recurrenceCountGroup) {
            dom.recurrenceCountGroup.classList.toggle('is-hidden', endsValue !== 'count');
          }
          if (dom.recurrenceUntilGroup) {
            dom.recurrenceUntilGroup.classList.toggle('is-hidden', endsValue !== 'until');
          }
        }
        const monthlyMode = getSelectedMonthlyMode();
        if (dom.recurrenceMonthday) {
          dom.recurrenceMonthday.disabled = monthlyMode !== 'monthday';
        }
        if (dom.recurrenceWeekPos) {
          dom.recurrenceWeekPos.disabled = monthlyMode !== 'weekday';
        }
        if (dom.recurrenceWeekday) {
          dom.recurrenceWeekday.disabled = monthlyMode !== 'weekday';
        }
      }

      function handleRecurrenceBuilderChange() {
        if (recurrenceMode !== 'builder' || isRecurrenceSyncing) return;
        isRecurrenceSyncing = true;
        const nextRule = buildRruleFromBuilder();
        state.recurrence = nextRule;
        if (dom.recurrenceInput) {
          dom.recurrenceInput.value = nextRule;
        }
        updateRecurrenceUi();
        updateRecurrenceSummary();
        refreshUi();
        isRecurrenceSyncing = false;
      }

      function toggleRecurrenceDay(button) {
        const isActive = !button.classList.contains('is-active');
        button.classList.toggle('is-active', isActive);
        button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      }

      function getSelectedMonthlyMode() {
        const selected = dom.recurrenceMonthlyMode
          ? [...dom.recurrenceMonthlyMode].find(input => input.checked)
          : null;
        return selected ? selected.value : 'monthday';
      }

      function getDefaultRecurrenceBuilder(startDate) {
        const dayCode = startDate ? getDayCode(startDate) : 'FR';
        const monthDay = startDate ? startDate.getDate() : 15;
        return {
          frequency: 'none',
          interval: 1,
          byDay: [dayCode],
          monthlyMode: 'monthday',
          monthDay,
          weekPos: 1,
          weekDay: dayCode,
          ends: 'never',
          count: '',
          until: ''
        };
      }

      function applyRecurrenceBuilderState(builder) {
        if (!builder) return;
        if (dom.recurrenceFrequency) dom.recurrenceFrequency.value = builder.frequency || 'none';
        if (dom.recurrenceInterval) dom.recurrenceInterval.value = builder.interval || 1;
        if (dom.recurrenceWeekdayButtons && dom.recurrenceWeekdayButtons.length) {
          dom.recurrenceWeekdayButtons.forEach(button => {
            const day = button.dataset.day;
            const isActive = builder.byDay && builder.byDay.includes(day);
            button.classList.toggle('is-active', isActive);
            button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
          });
        }
        if (dom.recurrenceMonthlyMode && dom.recurrenceMonthlyMode.length) {
          dom.recurrenceMonthlyMode.forEach(input => {
            input.checked = input.value === (builder.monthlyMode || 'monthday');
          });
        }
        if (dom.recurrenceMonthday) dom.recurrenceMonthday.value = builder.monthDay || '';
        if (dom.recurrenceWeekPos) dom.recurrenceWeekPos.value = builder.weekPos || 1;
        if (dom.recurrenceWeekday) dom.recurrenceWeekday.value = builder.weekDay || 'MO';
        if (dom.recurrenceEnds) dom.recurrenceEnds.value = builder.ends || 'never';
        if (dom.recurrenceCount) dom.recurrenceCount.value = builder.count || '';
        if (dom.recurrenceUntil) dom.recurrenceUntil.value = builder.until || '';
      }

      function buildRruleFromBuilder() {
        if (!dom.recurrenceFrequency) return '';
        const frequency = dom.recurrenceFrequency.value || 'none';
        if (frequency === 'none') return '';
        const parts = [`FREQ=${frequency.toUpperCase()}`];
        const interval = Math.max(1, parseInt(dom.recurrenceInterval ? dom.recurrenceInterval.value : '1', 10) || 1);
        if (interval > 1) {
          parts.push(`INTERVAL=${interval}`);
        }
        if (frequency === 'weekly') {
          let byDay = dom.recurrenceWeekdayButtons
            ? [...dom.recurrenceWeekdayButtons]
              .filter(button => button.classList.contains('is-active'))
              .map(button => button.dataset.day)
              .filter(Boolean)
            : [];
          if (!byDay.length) {
            const startDate = parseLocalDateTime(state.start, state.timezone);
            byDay = [getDayCode(startDate || new Date())];
            if (dom.recurrenceWeekdayButtons) {
              dom.recurrenceWeekdayButtons.forEach(button => {
                const isActive = byDay.includes(button.dataset.day);
                button.classList.toggle('is-active', isActive);
                button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
              });
            }
          }
          parts.push(`BYDAY=${byDay.join(',')}`);
        }
        if (frequency === 'monthly') {
          const monthlyMode = getSelectedMonthlyMode();
          if (monthlyMode === 'weekday') {
            let weekPos = dom.recurrenceWeekPos ? dom.recurrenceWeekPos.value : '1';
            let weekDay = dom.recurrenceWeekday ? dom.recurrenceWeekday.value : 'MO';
            if (!weekPos || !weekDay) {
              const startDate = parseLocalDateTime(state.start, state.timezone);
              weekDay = getDayCode(startDate || new Date());
              weekPos = '1';
              if (dom.recurrenceWeekPos) dom.recurrenceWeekPos.value = weekPos;
              if (dom.recurrenceWeekday) dom.recurrenceWeekday.value = weekDay;
            }
            parts.push(`BYDAY=${weekDay}`);
            parts.push(`BYSETPOS=${weekPos}`);
          } else {
            let monthDay = parseInt(dom.recurrenceMonthday ? dom.recurrenceMonthday.value : '', 10);
            if (!monthDay) {
              const startDate = parseLocalDateTime(state.start, state.timezone);
              monthDay = startDate ? startDate.getDate() : 1;
              if (dom.recurrenceMonthday) dom.recurrenceMonthday.value = monthDay;
            }
            parts.push(`BYMONTHDAY=${monthDay}`);
          }
        }
        if (dom.recurrenceEnds) {
          const ends = dom.recurrenceEnds.value;
          if (ends === 'count') {
            const count = parseInt(dom.recurrenceCount ? dom.recurrenceCount.value : '', 10);
            if (count) {
              parts.push(`COUNT=${count}`);
            }
          }
          if (ends === 'until') {
            const untilValue = dom.recurrenceUntil ? dom.recurrenceUntil.value : '';
            const untilDate = formatUntilDate(untilValue);
            if (untilDate) {
              parts.push(`UNTIL=${untilDate}`);
            }
          }
        }
        return parts.join(';');
      }

      function parseRruleToBuilder(rule, fallback = null) {
        if (!rule || typeof rule !== 'string') return null;
        const trimmed = rule.trim();
        if (!trimmed) return null;
        const parts = trimmed.split(';');
        const rules = {};
        parts.forEach(part => {
          const [key, value] = part.split('=');
          if (!key || !value) return;
          rules[key.toUpperCase()] = value;
        });
        const freq = rules.FREQ ? rules.FREQ.toLowerCase() : '';
        if (!['daily', 'weekly', 'monthly'].includes(freq)) {
          return null;
        }
        const builder = fallback ? { ...fallback } : getDefaultRecurrenceBuilder(null);
        builder.frequency = freq;
        builder.interval = Math.max(1, parseInt(rules.INTERVAL || '1', 10) || 1);
        if (freq === 'weekly') {
          builder.byDay = rules.BYDAY ? rules.BYDAY.split(',') : builder.byDay;
        }
        if (freq === 'monthly') {
          if (rules.BYMONTHDAY) {
            builder.monthlyMode = 'monthday';
            builder.monthDay = parseInt(rules.BYMONTHDAY.split(',')[0], 10) || builder.monthDay;
          } else if (rules.BYDAY && rules.BYSETPOS) {
            builder.monthlyMode = 'weekday';
            builder.weekDay = rules.BYDAY.split(',')[0] || builder.weekDay;
            builder.weekPos = parseInt(rules.BYSETPOS.split(',')[0], 10) || builder.weekPos;
          } else if (rules.BYDAY) {
            const token = rules.BYDAY.split(',')[0];
            const match = token.match(/^(-?\d+)?([A-Z]{2})$/);
            if (match) {
              builder.monthlyMode = 'weekday';
              builder.weekDay = match[2] || builder.weekDay;
              if (match[1]) {
                builder.weekPos = parseInt(match[1], 10) || builder.weekPos;
              }
            }
          }
        }
        if (rules.COUNT) {
          builder.ends = 'count';
          builder.count = parseInt(rules.COUNT, 10) || '';
        } else if (rules.UNTIL) {
          builder.ends = 'until';
          builder.until = parseUntilDate(rules.UNTIL);
        } else {
          builder.ends = 'never';
        }
        return builder;
      }

      function updateRecurrenceSummary() {
        if (!dom.recurrenceSummary) return;
        if (!state.recurrence) {
          dom.recurrenceSummary.textContent = 'Does not repeat.';
          return;
        }
        if (recurrenceMode === 'builder') {
          const builder = parseRruleToBuilder(state.recurrence, getDefaultRecurrenceBuilder(null));
          if (builder) {
            dom.recurrenceSummary.textContent = formatRecurrenceSummary(builder);
            return;
          }
        }
        dom.recurrenceSummary.textContent = `RRULE: ${state.recurrence}`;
      }

      function formatRecurrenceSummary(builder) {
        if (!builder || builder.frequency === 'none') return 'Does not repeat.';
        const interval = builder.interval || 1;
        const intervalLabel = interval > 1 ? `Every ${interval}` : 'Every';
        let label = '';
        if (builder.frequency === 'daily') {
          label = interval > 1 ? `${intervalLabel} days` : 'Daily';
        } else if (builder.frequency === 'weekly') {
          const days = builder.byDay && builder.byDay.length
            ? builder.byDay.map(code => DAY_CODE_LABELS[code] || code).join(', ')
            : 'selected days';
          label = interval > 1 ? `${intervalLabel} weeks on ${days}` : `Weekly on ${days}`;
        } else if (builder.frequency === 'monthly') {
          if (builder.monthlyMode === 'weekday') {
            const posLabel = WEEK_POSITION_LABELS[builder.weekPos] || 'First';
            const dayLabel = DAY_CODE_LABELS[builder.weekDay] || builder.weekDay;
            label = interval > 1
              ? `${intervalLabel} months on the ${posLabel} ${dayLabel}`
              : `Monthly on the ${posLabel} ${dayLabel}`;
          } else {
            const day = builder.monthDay || 1;
            label = interval > 1
              ? `${intervalLabel} months on day ${day}`
              : `Monthly on day ${day}`;
          }
        }
        if (builder.ends === 'count' && builder.count) {
          label += ` ¬∑ ${builder.count} times`;
        }
        if (builder.ends === 'until' && builder.until) {
          label += ` ¬∑ until ${builder.until}`;
        }
        return label;
      }

      function getRecurrenceChipLabel(recurrence) {
        if (!recurrence) return '';
        const parsed = parseRruleToBuilder(recurrence);
        if (!parsed) return 'Recurring';
        if (parsed.frequency === 'daily') return parsed.interval > 1 ? `Every ${parsed.interval} days` : 'Daily';
        if (parsed.frequency === 'weekly') return parsed.interval > 1 ? `Every ${parsed.interval} weeks` : 'Weekly';
        if (parsed.frequency === 'monthly') return parsed.interval > 1 ? `Every ${parsed.interval} months` : 'Monthly';
        return 'Recurring';
      }

      function ensureDateOrder() {
        if (!state.start) {
          state.start = formatInputValue(new Date());
        }
        if (!state.end) {
          const startDate = parseLocalDateTime(state.start, state.timezone);
          if (startDate) {
            const fallback = new Date(startDate.getTime() + DEFAULT_DURATION_MINUTES * 60000);
            state.end = formatInputValue(fallback);
          }
        }
        const startDate = parseLocalDateTime(state.start, state.timezone);
        const endDate = parseLocalDateTime(state.end, state.timezone);
        if (startDate && endDate && endDate <= startDate) {
          const newEnd = new Date(startDate.getTime() + DEFAULT_DURATION_MINUTES * 60000);
          state.end = formatInputValue(newEnd);
          if (dom.endInput) {
            dom.endInput.value = state.end;
          }
        }
      }

      function updateTimeNotes() {
        if (dom.durationNote) {
          const startDate = parseLocalDateTime(state.start, state.timezone);
          const endDate = parseLocalDateTime(state.end, state.timezone);
          if (!startDate || !endDate) {
            dom.durationNote.innerHTML = '<strong>Duration:</strong> Add start &amp; end';
          } else {
            const minutes = Math.max(0, Math.round((endDate - startDate) / 60000));
            const label = minutes ? formatDurationLabel(minutes) : 'TBD';
            dom.durationNote.innerHTML = `<strong>Duration:</strong> ${label}`;
          }
        }
        if (dom.timezoneNote) {
          dom.timezoneNote.innerHTML = `<strong>Local timezone:</strong> ${browserTimezone}`;
        }
      }

      function updatePreviewCard() {
        if (!dom.previewTitle) return;
        const event = buildEventPayload();
        const title = event.name || 'Untitled event';
        if (dom.previewTitle) dom.previewTitle.textContent = title;
        if (dom.previewCity) {
          dom.previewCity.textContent = getCityLabel(state.city) || 'City';
        }
        if (dom.previewTime) {
          dom.previewTime.textContent = formatPreviewDate(event.startDate, event.endDate, event.timezone);
        }
        if (dom.previewVenue) {
          dom.previewVenue.textContent = event.bar || 'Venue TBA';
        }
        if (dom.previewAddress) {
          dom.previewAddress.textContent = event.address || 'Address TBD';
        }
        const imageUrl = (state.image || '').trim();
        if (dom.previewMedia) {
          dom.previewMedia.classList.toggle('has-image', Boolean(imageUrl));
        }
        if (dom.previewImage) {
          if (imageUrl) {
            dom.previewImage.src = imageUrl;
            dom.previewImage.alt = title ? `${title} promo` : 'Event promo image';
          } else {
            dom.previewImage.removeAttribute('src');
            dom.previewImage.alt = '';
          }
        }
        const hasTimeRange = Boolean(event.startDate && event.endDate);
        const durationLabel = hasTimeRange
          ? formatDurationLabel(event.durationMinutes)
          : 'Duration TBD';
        setChip(dom.previewDuration, durationLabel, true);
        setChip(dom.previewTimezone, `Local TZ: ${browserTimezone}`, true, true);
        const recurrenceLabel = getRecurrenceChipLabel(event.recurrence);
        setChip(dom.previewRecurring, recurrenceLabel, Boolean(event.recurrence));
        setChip(dom.previewCover, state.cover ? `Cover: ${state.cover}` : '', Boolean(state.cover), true);
        updatePreviewLinks(event.links);
      }

      function updatePreviewLinks(links) {
        if (!dom.previewLinks) return;
        dom.previewLinks.innerHTML = '';
        if (!Array.isArray(links) || !links.length) {
          dom.previewLinks.classList.add('is-hidden');
          return;
        }
        dom.previewLinks.classList.remove('is-hidden');
        links.forEach(link => {
          const anchor = document.createElement('a');
          anchor.href = link.url;
          anchor.target = '_blank';
          anchor.rel = 'noopener';
          anchor.textContent = link.label || link.type || 'Link';
          dom.previewLinks.appendChild(anchor);
        });
      }

      function updateUrl() {
        const params = new URLSearchParams();
        if (state.name) params.set('name', state.name);
        if (state.shortName) params.set('short', state.shortName);
        if (state.city) params.set('city', state.city);
        if (state.venue) params.set('venue', state.venue);
        if (state.address) params.set('addr', state.address);
        if (state.description) params.set('desc', state.description);
        if (state.cover) params.set('cover', state.cover);
        if (state.start) params.set('start', state.start);
        if (state.end) params.set('end', state.end);
        if (state.recurrence) params.set('rrule', state.recurrence);
        if (state.website) params.set('web', state.website);
        if (state.ticketUrl) params.set('tickets', state.ticketUrl);
        if (state.instagram) params.set('insta', state.instagram);
        if (state.facebook) params.set('fb', state.facebook);
        if (state.gmaps) params.set('gmaps', state.gmaps);
        if (state.image) params.set('img', state.image);
        const coordsValue = (state.location || '').trim();
        if (coordsValue) params.set('coords', coordsValue);
        const sorted = new URLSearchParams();
        [...params.keys()].sort().forEach(key => sorted.set(key, params.get(key)));
        const query = sorted.toString();
        const newUrl = query ? `${window.location.pathname}?${query}` : window.location.pathname;
        const current = `${window.location.pathname}${window.location.search}`;
        if (current !== newUrl) {
          window.history.replaceState({}, '', newUrl);
        }
        updateShareUrl();
      }

      function scheduleUrlUpdate() {
        if (urlTimeoutId) {
          clearTimeout(urlTimeoutId);
        }
        urlTimeoutId = setTimeout(() => {
          urlTimeoutId = null;
          updateUrl();
        }, URL_UPDATE_DELAY);
      }

      function updateShareUrl() {
        if (dom.shareUrl) {
          dom.shareUrl.value = window.location.href;
        }
      }

      function refreshUi() {
        ensureDateOrder();
        updateTimeNotes();
        updateRecurrenceUi();
        updateRecurrenceSummary();
        updatePreviewCard();
        updateCoordinatesFieldState();
        scheduleUrlUpdate();
        scheduleEventPush();
      }

      function scheduleEventPush() {
        if (!dom.calendarIframe) return;
        if (sendTimeoutId) {
          clearTimeout(sendTimeoutId);
        }
        sendTimeoutId = setTimeout(() => {
          sendTimeoutId = null;
          pushEventToCalendar();
        }, EVENT_PUSH_DELAY);
      }

      function pushEventToCalendar() {
        if (!dom.calendarIframe || !dom.calendarIframe.contentWindow) return;
        const payload = buildMessagePayload();
        if (!payload) {
          updateCalendarStatus('Add start & end times to preview', 'warn');
          return;
        }
        updateCalendarStatus('Updating preview‚Ä¶', 'sending');
        try {
          dom.calendarIframe.contentWindow.postMessage({
            type: 'addTestEvent',
            data: payload
          }, '*');
        } catch (error) {
          console.error('Failed to send event to calendar iframe', error);
          updateCalendarStatus('Could not reach preview', 'error');
        }
      }

      function buildEventPayload() {
        const startDate = parseLocalDateTime(state.start, state.timezone);
        const endDate = parseLocalDateTime(state.end, state.timezone);
        const computedLabel = formatTimeRange(startDate, endDate, state.timezone);
        const timeLabel = computedLabel;
        const dayLabel = startDate
          ? startDate.toLocaleDateString('en-US', { weekday: 'long', timeZone: state.timezone || browserTimezone })
          : '';
        const durationMinutes = startDate && endDate
          ? Math.max(1, Math.round((endDate - startDate) / 60000))
          : DEFAULT_DURATION_MINUTES;
        const links = buildLinks();
        const locationValue = (state.location || '').trim();
        const coordinates = parseCoordinates(locationValue);
        return {
          name: (state.name || '').trim(),
          shortName: (state.shortName || '').trim(),
          tea: (state.description || '').trim(),
          cover: (state.cover || '').trim(),
          bar: (state.venue || 'Venue TBA').trim(),
          address: (state.address || '').trim(),
          location: locationValue,
          coordinates,
          city: state.city,
          time: timeLabel,
          day: dayLabel,
          startDate,
          endDate,
          timezone: browserTimezone,
          image: (state.image || '').trim() || null,
          website: (state.website || '').trim() || null,
          instagram: (state.instagram || '').trim() || null,
          facebook: (state.facebook || '').trim() || null,
          gmaps: (state.gmaps || '').trim() || null,
          ticketUrl: (state.ticketUrl || '').trim() || null,
          links,
          recurring: Boolean(state.recurrence),
          recurrence: (state.recurrence || '').trim(),
          durationMinutes
        };
      }

      function buildMessagePayload() {
        const event = buildEventPayload();
        if (!event.startDate || !event.endDate) {
          return null;
        }
        return {
          name: event.name,
          shortName: event.shortName,
          nickname: event.shortName,
          tea: event.tea,
          description: event.tea,
          cover: event.cover,
          bar: event.bar,
          venue: event.bar,
          address: event.address,
          location: event.location,
          coordinates: event.coordinates,
          city: event.city,
          time: event.time,
          day: event.day,
          startDate: event.startDate.toISOString(),
          endDate: event.endDate.toISOString(),
          timezone: event.timezone,
          durationMinutes: event.durationMinutes,
          image: event.image,
          website: event.website,
          instagram: event.instagram,
          facebook: event.facebook,
          gmaps: event.gmaps,
          ticketUrl: event.ticketUrl,
          tickets: event.ticketUrl,
          links: event.links,
          recurring: event.recurring,
          recurrence: event.recurrence || null,
          notChecked: false
        };
      }

      function buildLinks() {
        const links = [];
        const addLink = (label, url, type) => {
          const trimmedUrl = (url || '').trim();
          if (!trimmedUrl) return;
          links.push({
            label: label || type,
            url: trimmedUrl,
            type
          });
        };
        addLink('üåê Website', state.website, 'website');
        addLink('üé´ Tickets', state.ticketUrl, 'tickets');
        addLink('üì∑ Instagram', state.instagram, 'instagram');
        addLink('üìò Facebook', state.facebook, 'facebook');
        addLink('üó∫Ô∏è Google Maps', state.gmaps, 'gmaps');
        return links;
      }

      function setupMessaging() {
        if (dom.calendarIframe) {
          dom.calendarIframe.addEventListener('load', () => {
            iframeLoaded = true;
            calendarReady = false;
            updateCalendarStatus('Loading calendar‚Ä¶', 'loading');
            setTimeout(() => {
              pushEventToCalendar();
            }, 350);
          });
        }
        window.addEventListener('message', event => {
          const data = event.data;
          if (!data || typeof data !== 'object') return;
          if (data.type === 'calendarInitialized') {
            if (!data.city || data.city === state.city) {
              calendarReady = true;
              updateCalendarStatus('Calendar ready', 'ready');
              pushEventToCalendar();
            }
          }
          if (data.type === 'testEventRendered') {
            if (!data.city || data.city === state.city) {
              calendarReady = true;
              updateCalendarStatus('Preview updated', 'ready');
            }
          }
        });
      }

      function updateCalendarSource(force = false) {
        if (!dom.calendarIframe) return;
        const targetCity = state.city || 'nyc';
        if (!force && currentCalendarCity === targetCity) {
          return;
        }
        currentCalendarCity = targetCity;
        calendarReady = false;
        iframeLoaded = false;
        const newSrc = `../city.html?city=${encodeURIComponent(targetCity)}`;
        dom.calendarIframe.src = newSrc;
        updateCalendarStatus('Loading calendar‚Ä¶', 'loading');
      }

      function updateCalendarStatus(message, status) {
        if (!dom.calendarStatus) return;
        dom.calendarStatus.textContent = message;
        dom.calendarStatus.className = status ? `status-badge status-${status}` : 'status-badge';
      }

      function parseLocalDateTime(value, timeZone) {
        if (!value) return null;
        const [datePart, timePart = '00:00'] = value.split('T');
        if (!datePart) return null;
        const [year, month, day] = datePart.split('-').map(Number);
        const [hour, minute] = timePart.split(':').map(Number);
        const utcDate = new Date(Date.UTC(year, (month || 1) - 1, day || 1, hour || 0, minute || 0));
        return new Date(utcDate.getTime() - getTimeZoneOffset(utcDate, timeZone || browserTimezone));
      }

      function getTimeZoneOffset(date, timeZone) {
        const parts = new Intl.DateTimeFormat('en-US', {
          timeZone,
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          hour12: false
        }).formatToParts(date);
        const values = {};
        parts.forEach(part => {
          if (part.type !== 'literal') {
            values[part.type] = part.value;
          }
        });
        const asUTC = Date.UTC(
          Number(values.year),
          Number(values.month) - 1,
          Number(values.day),
          Number(values.hour),
          Number(values.minute),
          Number(values.second || '0')
        );
        return asUTC - date.getTime();
      }

      function formatTimeRange(startDate, endDate, timeZone) {
        if (!startDate || !endDate) return '';
        const formatter = new Intl.DateTimeFormat('en-US', {
          timeZone: timeZone || browserTimezone,
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        });
        const startParts = formatter.formatToParts(startDate);
        const endParts = formatter.formatToParts(endDate);
        const startLabel = formatTimeParts(startParts);
        const endLabel = formatTimeParts(endParts);
        return startLabel === endLabel ? startLabel : `${startLabel}-${endLabel}`;
      }

      function formatTimeParts(parts) {
        const values = {};
        parts.forEach(part => {
          if (part.type !== 'literal') {
            values[part.type] = part.value;
          }
        });
        const hour = values.hour ? parseInt(values.hour, 10).toString() : '';
        const minute = values.minute && values.minute !== '00' ? `:${values.minute}` : '';
        const period = values.dayPeriod ? values.dayPeriod.toUpperCase() : '';
        return `${hour}${minute}${period}`;
      }

      function formatInputValue(date) {
        const local = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
        return local.toISOString().slice(0, 16);
      }

      function sanitizeDateTimeInput(value) {
        if (typeof value !== 'string') return '';
        const trimmed = value.trim();
        if (!trimmed) return '';
        if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(trimmed)) return trimmed;
        if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(trimmed)) return trimmed.slice(0, 16);
        return '';
      }

      function formatPreviewDate(startDate, endDate, timeZone) {
        if (!startDate || !endDate) {
          return 'Add start and end times to preview timing.';
        }
        const dateLabel = startDate.toLocaleDateString('en-US', {
          weekday: 'long',
          month: 'short',
          day: 'numeric',
          timeZone: timeZone || browserTimezone
        });
        const rangeLabel = formatTimeRange(startDate, endDate, timeZone);
        return rangeLabel ? `${dateLabel} ¬∑ ${rangeLabel}` : dateLabel;
      }

      function formatDurationLabel(minutes) {
        if (!minutes) return 'Duration TBD';
        const hours = Math.floor(minutes / 60);
        const remainder = minutes % 60;
        const parts = [];
        if (hours) parts.push(`${hours} hr${hours === 1 ? '' : 's'}`);
        if (remainder) parts.push(`${remainder} min`);
        return parts.join(' ') || `${minutes} min`;
      }

      function getDayCode(date) {
        if (!(date instanceof Date)) return 'FR';
        const codes = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
        return codes[date.getDay()] || 'FR';
      }

      function formatUntilDate(value) {
        if (!value || !/^\d{4}-\d{2}-\d{2}$/.test(value)) return '';
        const compact = value.replace(/-/g, '');
        return `${compact}T235959Z`;
      }

      function parseUntilDate(value) {
        if (!value) return '';
        const match = String(value).match(/^(\d{4})(\d{2})(\d{2})/);
        if (!match) return '';
        return `${match[1]}-${match[2]}-${match[3]}`;
      }

      function parseCoordinates(value) {
        if (!value) return null;
        const parts = value.split(',');
        if (parts.length < 2) return null;
        const lat = parseFloat(parts[0].trim());
        const lng = parseFloat(parts[1].trim());
        if (!Number.isFinite(lat) || !Number.isFinite(lng)) return null;
        if (lat < -90 || lat > 90 || lng < -180 || lng > 180) return null;
        return { lat, lng };
      }

      function getCityLabel(cityKey) {
        if (dom.citySelect) {
          const option = [...dom.citySelect.options].find(option => option.value === cityKey);
          if (option) return option.textContent;
        }
        if (typeof CITY_CONFIG === 'object' && CITY_CONFIG && CITY_CONFIG[cityKey]) {
          const city = CITY_CONFIG[cityKey];
          return city.emoji ? `${city.emoji} ${city.name}` : city.name || cityKey;
        }
        if (!cityKey) return '';
        return cityKey.replace(/-/g, ' ').replace(/\b\w/g, char => char.toUpperCase());
      }

      function setChip(element, text, show, muted = false) {
        if (!element) return;
        element.textContent = text || '';
        element.classList.toggle('is-hidden', !show);
        element.classList.toggle('is-muted', muted && show);
      }

      function copyToClipboard(text, button) {
        if (!text) return;
        const fallbackCopy = () => {
          const textarea = document.createElement('textarea');
          textarea.value = text;
          textarea.style.position = 'fixed';
          textarea.style.opacity = '0';
          document.body.appendChild(textarea);
          textarea.focus();
          textarea.select();
          try {
            document.execCommand('copy');
            showTemporaryState(button, 'Copied!');
          } catch (error) {
            console.warn('Clipboard copy failed', error);
          }
          document.body.removeChild(textarea);
        };
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text)
            .then(() => showTemporaryState(button, 'Copied!'))
            .catch(() => fallbackCopy());
        } else {
          fallbackCopy();
        }
      }

      function showTemporaryState(button, message, duration = 1800) {
        if (!button) return;
        const original = button.textContent;
        button.textContent = message;
        button.disabled = true;
        setTimeout(() => {
          button.textContent = original;
          button.disabled = false;
        }, duration);
      }

      function handleAddToCalendar() {
        const event = buildEventPayload();
        if (!event.startDate || !event.endDate) {
          updateCalendarStatus('Add start & end times before exporting', 'warn');
          return;
        }
        const icsContent = generateICS(event);
        const filename = `${slugify(event.name || 'chunky-dad-event') || 'chunky-dad-event'}.ics`;
        const blob = new Blob([icsContent], { type: 'text/calendar' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        setTimeout(() => URL.revokeObjectURL(url), 1000);
        showTemporaryState(dom.addToCalendarButton, 'ICS ready!');
      }

      function generateICS(event) {
        const lines = [
          'BEGIN:VCALENDAR',
          'VERSION:2.0',
          'PRODID:-//chunky.dad//Event Builder//EN',
          'CALSCALE:GREGORIAN',
          'METHOD:PUBLISH',
          'BEGIN:VEVENT',
          `UID:${slugify(event.name || 'chunky-dad')}-${formatICSDate(new Date())}@chunky.dad`,
          `DTSTAMP:${formatICSDate(new Date())}`,
          `DTSTART:${formatICSDate(event.startDate)}`,
          `DTEND:${formatICSDate(event.endDate)}`,
          `SUMMARY:${escapeICS(event.name)}`
        ];
        const notes = formatEventNotes(event);
        if (notes) {
          lines.push(`DESCRIPTION:${escapeICS(notes)}`);
        }
        if (event.recurrence) {
          lines.push(`RRULE:${event.recurrence}`);
        }
        const location = (event.location || '').trim();
        if (location && parseCoordinates(location)) {
          lines.push(`LOCATION:${escapeICS(location)}`);
        }
        const primaryUrl = event.website || event.ticketUrl || event.facebook || event.instagram || event.gmaps;
        if (primaryUrl) {
          lines.push(`URL:${escapeICS(primaryUrl)}`);
        }
        lines.push('END:VEVENT', 'END:VCALENDAR');
        return lines.join('\r\n');
      }

      function formatEventNotes(event) {
        if (!event || typeof event !== 'object') return '';
        const excludeFields = new Set([
          'title', 'startDate', 'endDate', 'location', 'coordinates', 'notes',
          'isBearEvent', 'source', 'city', 'setDescription', '_analysis', '_action',
          '_existingEvent', '_existingKey', '_conflicts', '_parserConfig', '_fieldPriorities',
          '_original', '_mergeInfo', '_changes', '_mergeDiff',
          'originalTitle', 'name', 'links', 'durationMinutes'
        ]);
        const notes = [];
        Object.keys(event).forEach(fieldName => {
          if (excludeFields.has(fieldName)) return;
          const value = event[fieldName];
          if (value === undefined || value === null || value === '') return;
          const valueString = String(value);
          const valueForNotes = isUrlLikeField(fieldName, valueString)
            ? valueString
            : escapeText(valueString);
          notes.push(`${fieldName}: ${valueForNotes}`);
        });
        return notes.join('\n');
      }

      function isUrlLikeField(fieldName, valueString) {
        const urlFields = new Set([
          'url', 'ticketUrl', 'gmaps', 'website', 'facebook', 'instagram', 'twitter', 'image'
        ]);
        if (urlFields.has(fieldName)) return true;
        if (!valueString || typeof valueString !== 'string') return false;
        const lower = valueString.trim().toLowerCase();
        return lower.startsWith('http://') ||
          lower.startsWith('https://') ||
          lower.startsWith('mailto:') ||
          lower.startsWith('tel:') ||
          lower.startsWith('sms:');
      }

      function escapeText(text) {
        if (!text || typeof text !== 'string') {
          return text;
        }
        return text
          .replace(/\\/g, '\\\\')
          .replace(/:/g, '\\:');
      }

      function formatICSDate(date) {
        return date.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
      }

      function escapeICS(value) {
        return String(value || '')
          .replace(/\\/g, '\\\\')
          .replace(/\r?\n/g, '\\n')
          .replace(/,/g, '\\,')
          .replace(/;/g, '\\;');
      }

      function slugify(value) {
        return String(value || '')
          .toLowerCase()
          .trim()
          .replace(/[\s_]+/g, '-')
          .replace(/[^\w-]+/g, '')
          .replace(/-+/g, '-')
          .replace(/^-|-$/g, '')
          .slice(0, 60);
      }
    })();
  </script>
</body>
</html>
